{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kn-sock","text":"<ul> <li>Documentation </li> </ul> <p>A simplified socket programming toolkit for Python that makes network communication easy and efficient.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>TCP/UDP Messaging: Supports both synchronous and asynchronous communication</li> <li>Secure Communication: SSL/TLS support for encrypted connections</li> <li>JSON Socket Communication: Easily send and receive JSON data over sockets</li> <li>File Transfer: Transfer files between clients and servers with progress tracking</li> <li>Live Streaming: Multi-video streaming with adaptive bitrate</li> <li>Video Chat: Real-time multi-client video chat with voice</li> <li>WebSocket Support: Full WebSocket server and client implementation</li> <li>HTTP/HTTPS: Simple HTTP client and server helpers</li> <li>Pub/Sub &amp; RPC: Publish/subscribe messaging and remote procedure calls</li> <li>Message Queuing: Advanced queue management for reliable message delivery</li> <li>Load Balancing: Distribute connections across multiple servers</li> <li>Data Compression: Built-in compression for bandwidth optimization</li> <li>Protocol Buffers: Support for efficient binary serialization</li> <li>Decorators &amp; Utilities: Helper decorators and utility functions</li> <li>Docker Support: Ready-to-use Docker containers and compose files</li> <li>Interactive CLI: Real-time interactive command-line interface</li> <li>Command-Line Interface: Simple CLI for quick socket operations</li> <li>Connection Pooling: Efficient connection reuse for high-performance applications</li> <li>Network Visibility: ARP scanning, MAC lookup, and DNS monitoring tools</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example to get you started:</p> <pre><code># Server\nfrom kn_sock import start_tcp_server\n\ndef handle_message(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received!\")\n\nstart_tcp_server(8080, handle_message)\n</code></pre> <pre><code># Client\nfrom kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#docker-quick-start","title":"Docker Quick Start","text":"<pre><code># Run with Docker Compose\ndocker-compose run knsock --help\n\n# Run tests\ndocker-compose run test\n</code></pre> <p>For detailed Docker usage, see the Docker guide.</p>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li>Getting Started - Learn the basics and set up your first project</li> <li>Docker Setup - Get started with Docker containers and deployment</li> </ul>"},{"location":"#protocol-documentation","title":"Protocol Documentation","text":"<ul> <li>TCP Protocol - Reliable connection-based communication</li> <li>UDP Protocol - Fast connectionless messaging</li> <li>WebSocket Protocol - Real-time bidirectional communication</li> <li>JSON Communication - Structured data exchange</li> <li>File Transfer - Efficient file sharing</li> <li>Secure TCP (SSL/TLS) - Encrypted communication</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>Pub/Sub Messaging - Event-driven messaging patterns</li> <li>Remote Procedure Calls - Call remote functions seamlessly</li> <li>Live Streaming - Multi-video streaming with adaptive bitrate</li> <li>Video Chat - Real-time video conferencing</li> <li>HTTP/HTTPS - Web server and client functionality</li> </ul>"},{"location":"#reference-examples","title":"Reference &amp; Examples","text":"<ul> <li>API Reference - Complete function and class documentation</li> <li>CLI Guide - Command-line interface usage</li> <li>Examples - Real-world usage examples</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#network-visibility-tools","title":"Network Visibility Tools","text":"<p>\u26a0\ufe0f ETHICAL WARNING: These tools are intended for use in authorized networks such as schools, labs, or controlled IT environments. Monitoring user traffic may be illegal without explicit consent. Use responsibly and ethically.</p>"},{"location":"#network-monitoring","title":"Network Monitoring","text":"<ul> <li>ARP Scanning - Discover active devices on your network</li> <li>MAC Address Lookup - Identify device vendors by MAC address</li> <li>DNS Monitoring - Monitor and analyze DNS requests</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page provides a comprehensive reference for all public functions and classes in kn-sock.</p>"},{"location":"api-reference/#tcp-functions","title":"TCP Functions","text":""},{"location":"api-reference/#server-functions","title":"Server Functions","text":""},{"location":"api-reference/#start_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a synchronous TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each client (data, addr, client_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_threaded_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_threaded_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a threaded TCP server for handling multiple clients concurrently.</p> <p>Parameters: Same as <code>start_tcp_server</code></p> <p>Returns: None</p>"},{"location":"api-reference/#start_async_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_async_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (async callable): Async function called for each client (data, addr, writer). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (asyncio.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions","title":"Client Functions","text":""},{"location":"api-reference/#send_tcp_messagehost-port-message","title":"<code>send_tcp_message(host, port, message)</code>","text":"<p>Send a string message over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_tcp_byteshost-port-data","title":"<code>send_tcp_bytes(host, port, data)</code>","text":"<p>Send raw bytes over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>data</code> (bytes): Data to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_tcp_message_asynchost-port-message","title":"<code>send_tcp_message_async(host, port, message)</code>","text":"<p>Send a string message over TCP asynchronously.</p> <p>Parameters: Same as <code>send_tcp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#secure-tcp-ssltls-functions","title":"Secure TCP (SSL/TLS) Functions","text":""},{"location":"api-reference/#server-functions_1","title":"Server Functions","text":""},{"location":"api-reference/#start_ssl_tcp_serverport-handler_func-certfile-keyfile-cafilenone-require_client_certfalse-host0000-shutdown_eventnone","title":"<code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a secure SSL/TLS TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each client (data, addr, client_socket). - <code>certfile</code> (str): Path to server certificate (PEM). - <code>keyfile</code> (str): Path to private key (PEM). - <code>cafile</code> (str, optional): CA cert for client verification. - <code>require_client_cert</code> (bool): Require client cert (mutual TLS). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_async_ssl_tcp_serverport-handler_func-certfile-keyfile-cafilenone-require_client_certfalse-host0000-shutdown_eventnone","title":"<code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async secure SSL/TLS TCP server.</p> <p>Parameters: Same as <code>start_ssl_tcp_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_1","title":"Client Functions","text":""},{"location":"api-reference/#send_ssl_tcp_messagehost-port-message-cafilenone-certfilenone-keyfilenone-verifytrue","title":"<code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Send a message over SSL/TLS TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send. - <code>cafile</code> (str, optional): CA cert for server verification. - <code>certfile</code> (str, optional): Client certificate. - <code>keyfile</code> (str, optional): Client private key. - <code>verify</code> (bool): Verify server cert (default: True).</p> <p>Returns: None</p>"},{"location":"api-reference/#send_ssl_tcp_message_asynchost-port-message-cafilenone-certfilenone-keyfilenone-verifytrue","title":"<code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Send a message over SSL/TLS TCP asynchronously.</p> <p>Parameters: Same as <code>send_ssl_tcp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#udp-functions","title":"UDP Functions","text":""},{"location":"api-reference/#server-functions_2","title":"Server Functions","text":""},{"location":"api-reference/#start_udp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_udp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a synchronous UDP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message (data, addr, server_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_udp_server_asyncport-handler_func-host0000-shutdown_eventnone","title":"<code>start_udp_server_async(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async UDP server.</p> <p>Parameters: Same as <code>start_udp_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_2","title":"Client Functions","text":""},{"location":"api-reference/#send_udp_messagehost-port-message","title":"<code>send_udp_message(host, port, message)</code>","text":"<p>Send a string message over UDP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_udp_message_asynchost-port-message","title":"<code>send_udp_message_async(host, port, message)</code>","text":"<p>Send a string message over UDP asynchronously.</p> <p>Parameters: Same as <code>send_udp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#send_udp_multicastgroup-port-message-ttl1","title":"<code>send_udp_multicast(group, port, message, ttl=1)</code>","text":"<p>Send a message to a UDP multicast group.</p> <p>Parameters: - <code>group</code> (str): Multicast group address. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send. - <code>ttl</code> (int): Time-to-live for multicast packets.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_udp_multicast_servergroup-port-handler_func-listen_ip0000-shutdown_eventnone","title":"<code>start_udp_multicast_server(group, port, handler_func, listen_ip='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a UDP multicast server.</p> <p>Parameters: - <code>group</code> (str): Multicast group address. - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message. - <code>listen_ip</code> (str): IP to listen on for multicast. - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#file-transfer-functions","title":"File Transfer Functions","text":""},{"location":"api-reference/#server-functions_3","title":"Server Functions","text":""},{"location":"api-reference/#start_file_serverport-save_dir-host0000","title":"<code>start_file_server(port, save_dir, host='0.0.0.0')</code>","text":"<p>Start a TCP file receiver.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>save_dir</code> (str): Directory to save received files. - <code>host</code> (str): Host to bind (default: '0.0.0.0').</p> <p>Returns: None</p>"},{"location":"api-reference/#start_file_server_asyncport-save_dir-host0000","title":"<code>start_file_server_async(port, save_dir, host='0.0.0.0')</code>","text":"<p>Start an async TCP file receiver.</p> <p>Parameters: Same as <code>start_file_server</code></p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_3","title":"Client Functions","text":""},{"location":"api-reference/#send_filehost-port-filepath-show_progresstrue-progress_callbacknone","title":"<code>send_file(host, port, filepath, show_progress=True, progress_callback=None)</code>","text":"<p>Send a file over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>filepath</code> (str): Path to file to send. - <code>show_progress</code> (bool): Show progress bar (default: True). - <code>progress_callback</code> (callable, optional): Custom progress function.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_file_asynchost-port-filepath","title":"<code>send_file_async(host, port, filepath)</code>","text":"<p>Send a file over TCP asynchronously.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>filepath</code> (str): Path to file to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#json-socket-functions","title":"JSON Socket Functions","text":""},{"location":"api-reference/#server-functions_4","title":"Server Functions","text":""},{"location":"api-reference/#start_json_serverport-handler_func-host0000","title":"<code>start_json_server(port, handler_func, host='0.0.0.0')</code>","text":"<p>Start a JSON-over-TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message (data: dict, addr, client_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0').</p> <p>Returns: None</p>"},{"location":"api-reference/#start_json_server_asyncport-handler_func-host0000","title":"<code>start_json_server_async(port, handler_func, host='0.0.0.0')</code>","text":"<p>Start an async JSON-over-TCP server.</p> <p>Parameters: Same as <code>start_json_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_4","title":"Client Functions","text":""},{"location":"api-reference/#send_jsonhost-port-obj-timeout5","title":"<code>send_json(host, port, obj, timeout=5)</code>","text":"<p>Send a JSON object over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>obj</code> (dict): JSON-serializable object. - <code>timeout</code> (int): Timeout in seconds.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_json_asynchost-port-obj","title":"<code>send_json_async(host, port, obj)</code>","text":"<p>Send a JSON object over TCP asynchronously.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>obj</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#response-helpers","title":"Response Helpers","text":""},{"location":"api-reference/#send_json_responsesock-data","title":"<code>send_json_response(sock, data)</code>","text":"<p>Send a JSON response to a client.</p> <p>Parameters: - <code>sock</code> (socket.socket): Client socket. - <code>data</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_json_response_asyncwriter-data","title":"<code>send_json_response_async(writer, data)</code>","text":"<p>Send a JSON response to a client asynchronously.</p> <p>Parameters: - <code>writer</code> (asyncio.StreamWriter): Writer object. - <code>data</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#websocket-functions","title":"WebSocket Functions","text":""},{"location":"api-reference/#server-functions_5","title":"Server Functions","text":""},{"location":"api-reference/#start_websocket_serverhost-port-handler-shutdown_eventnone","title":"<code>start_websocket_server(host, port, handler, shutdown_event=None)</code>","text":"<p>Start a WebSocket server.</p> <p>Parameters: - <code>host</code> (str): Host to bind. - <code>port</code> (int): Port to bind. - <code>handler</code> (callable): Function called for each client (ws). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_5","title":"Client Functions","text":""},{"location":"api-reference/#connect_websockethost-port-resource-headersnone","title":"<code>connect_websocket(host, port, resource='/', headers=None)</code>","text":"<p>Connect to a WebSocket server.</p> <p>Parameters: - <code>host</code> (str): Server host. - <code>port</code> (int): Server port. - <code>resource</code> (str): WebSocket resource path. - <code>headers</code> (dict, optional): Extra headers.</p> <p>Returns: WebSocket client object</p>"},{"location":"api-reference/#async_connect_websockethost-port-resource-headersnone","title":"<code>async_connect_websocket(host, port, resource='/', headers=None)</code>","text":"<p>Connect to a WebSocket server asynchronously.</p> <p>Parameters: Same as <code>connect_websocket</code></p> <p>Returns: AsyncWebSocketConnection</p>"},{"location":"api-reference/#httphttps-functions","title":"HTTP/HTTPS Functions","text":""},{"location":"api-reference/#client-functions_6","title":"Client Functions","text":""},{"location":"api-reference/#http_gethost-port80-path-headersnone","title":"<code>http_get(host, port=80, path='/', headers=None)</code>","text":"<p>Send an HTTP GET request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 80). - <code>path</code> (str): URL path. - <code>headers</code> (dict): HTTP headers.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#http_posthost-port80-path-data-headersnone","title":"<code>http_post(host, port=80, path='/', data='', headers=None)</code>","text":"<p>Send an HTTP POST request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 80). - <code>path</code> (str): URL path. - <code>data</code> (str): POST data. - <code>headers</code> (dict): HTTP headers.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#https_gethost-port443-path-headersnone-cafilenone","title":"<code>https_get(host, port=443, path='/', headers=None, cafile=None)</code>","text":"<p>Send an HTTPS GET request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 443). - <code>path</code> (str): URL path. - <code>headers</code> (dict): HTTP headers. - <code>cafile</code> (str): CA cert for verification.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#https_posthost-port443-path-data-headersnone-cafilenone","title":"<code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code>","text":"<p>Send an HTTPS POST request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 443). - <code>path</code> (str): URL path. - <code>data</code> (str): POST data. - <code>headers</code> (dict): HTTP headers. - <code>cafile</code> (str): CA cert for verification.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#server-functions_6","title":"Server Functions","text":""},{"location":"api-reference/#start_http_serverhost-port-static_dirnone-routesnone-shutdown_eventnone","title":"<code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code>","text":"<p>Start an HTTP server.</p> <p>Parameters: - <code>host</code> (str): Host to bind. - <code>port</code> (int): Port to bind. - <code>static_dir</code> (str, optional): Directory to serve files from. - <code>routes</code> (dict, optional): Dict mapping (method, path) to handler functions. - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#pubsub-functions","title":"Pub/Sub Functions","text":""},{"location":"api-reference/#server-functions_7","title":"Server Functions","text":""},{"location":"api-reference/#start_pubsub_serverport-handler_funcnone-host0000-shutdown_eventnone","title":"<code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a TCP pub/sub server for topic-based message distribution.</p> <p>Parameters: - <code>port</code> (int): Port to bind the server to. - <code>handler_func</code> (callable, optional): Custom handler for processing messages. Called with <code>(data, client_sock, server)</code> where <code>data</code> is the parsed JSON message, <code>client_sock</code> is the client socket, and <code>server</code> is the PubSubServer instance. - <code>host</code> (str): Host address to bind to (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): Event for graceful shutdown.</p> <p>Returns: None</p> <p>Handler Function Signature: <pre><code>def custom_handler(data, client_sock, server):\n    \"\"\"\n    Args:\n        data (dict): Parsed JSON message from client\n        client_sock (socket.socket): Client socket connection\n        server (PubSubServer): Server instance\n    \"\"\"\n    pass\n</code></pre></p> <p>Example: <pre><code>from kn_sock import start_pubsub_server\n\ndef message_handler(data, client_sock, server):\n    action = data.get(\"action\")\n    if action == \"publish\":\n        print(f\"Message: {data.get('message')}\")\n\nstart_pubsub_server(8080, message_handler)\n</code></pre></p>"},{"location":"api-reference/#client-class","title":"Client Class","text":""},{"location":"api-reference/#pubsubclienthost-port","title":"<code>PubSubClient(host, port)</code>","text":"<p>Create a PubSub client for publishing and subscribing to topics.</p> <p>Parameters: - <code>host</code> (str): Server hostname or IP address. - <code>port</code> (int): Server port number.</p> <p>Methods:</p>"},{"location":"api-reference/#subscribetopic-str-none","title":"<code>subscribe(topic: str) -&gt; None</code>","text":"<p>Subscribe to a topic to receive messages published to it.</p> <p>Parameters: - <code>topic</code> (str): Topic name to subscribe to.</p>"},{"location":"api-reference/#unsubscribetopic-str-none","title":"<code>unsubscribe(topic: str) -&gt; None</code>","text":"<p>Unsubscribe from a topic to stop receiving its messages.</p> <p>Parameters: - <code>topic</code> (str): Topic name to unsubscribe from.</p>"},{"location":"api-reference/#publishtopic-str-message-str-none","title":"<code>publish(topic: str, message: str) -&gt; None</code>","text":"<p>Publish a message to a topic for distribution to subscribers.</p> <p>Parameters: - <code>topic</code> (str): Topic name to publish to. - <code>message</code> (str): Message content to publish.</p>"},{"location":"api-reference/#recvtimeout-float-none-optionaldict","title":"<code>recv(timeout: float = None) -&gt; Optional[dict]</code>","text":"<p>Receive a message from subscribed topics.</p> <p>Parameters: - <code>timeout</code> (float, optional): Timeout in seconds. None for blocking receive.</p> <p>Returns: Dictionary with 'topic' and 'message' keys, or None if timeout.</p>"},{"location":"api-reference/#close-none","title":"<code>close() -&gt; None</code>","text":"<p>Close the client connection and cleanup resources.</p> <p>Example: <pre><code>from kn_sock import PubSubClient\n\n# Publisher\nclient = PubSubClient(\"localhost\", 8080)\nclient.publish(\"news\", \"Breaking news!\")\nclient.close()\n\n# Subscriber\nclient = PubSubClient(\"localhost\", 8080)\nclient.subscribe(\"news\")\nmessage = client.recv(timeout=5.0)\nif message:\n    print(f\"Received: {message['message']}\")\nclient.close()\n</code></pre></p>"},{"location":"api-reference/#rpc-functions","title":"RPC Functions","text":""},{"location":"api-reference/#server-functions_8","title":"Server Functions","text":""},{"location":"api-reference/#start_rpc_serverport-register_funcs-host0000-shutdown_eventnone","title":"<code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an RPC server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>register_funcs</code> (dict): Function name to callable mapping. - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-class_1","title":"Client Class","text":""},{"location":"api-reference/#rpcclienthost-port","title":"<code>RPCClient(host, port)</code>","text":"<p>RPC client class.</p> <p>Methods: - <code>call(function, *args, **kwargs)</code>: Call a remote function. - <code>close()</code>: Close the connection.</p>"},{"location":"api-reference/#live-streaming-functions","title":"Live Streaming Functions","text":""},{"location":"api-reference/#server-functions_9","title":"Server Functions","text":""},{"location":"api-reference/#start_live_streamport-video_paths-host0000-audio_portnone","title":"<code>start_live_stream(port, video_paths, host='0.0.0.0', audio_port=None)</code>","text":"<p>Start a live video/audio stream server.</p> <p>Parameters: - <code>port</code> (int): Video port. - <code>video_paths</code> (list of str): Video file paths. - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>audio_port</code> (int, optional): Audio port.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_7","title":"Client Functions","text":""},{"location":"api-reference/#connect_to_live_serverip-port-audio_portnone","title":"<code>connect_to_live_server(ip, port, audio_port=None)</code>","text":"<p>Connect to a live stream server.</p> <p>Parameters: - <code>ip</code> (str): Server IP. - <code>port</code> (int): Video port. - <code>audio_port</code> (int, optional): Audio port.</p> <p>Returns: None</p>"},{"location":"api-reference/#classes","title":"Classes","text":""},{"location":"api-reference/#livestreamservervideo_paths-host0000-video_port9000-audio_port9001-control_port9010","title":"<code>LiveStreamServer(video_paths, host='0.0.0.0', video_port=9000, audio_port=9001, control_port=9010)</code>","text":"<p>Live stream server class.</p> <p>Methods: - <code>start()</code>: Start the server.</p>"},{"location":"api-reference/#livestreamclienthost-video_port9000-audio_port9001-control_port9010-video_buffer_ms200-audio_buffer_ms100-video_fps30","title":"<code>LiveStreamClient(host, video_port=9000, audio_port=9001, control_port=9010, video_buffer_ms=200, audio_buffer_ms=100, video_fps=30)</code>","text":"<p>Live stream client class.</p> <p>Methods: - <code>start()</code>: Start the client.</p>"},{"location":"api-reference/#video-chat-functions","title":"Video Chat Functions","text":""},{"location":"api-reference/#classes_1","title":"Classes","text":""},{"location":"api-reference/#videochatserverhost0000-video_port9000-audio_port9001-text_port9002","title":"<code>VideoChatServer(host='0.0.0.0', video_port=9000, audio_port=9001, text_port=9002)</code>","text":"<p>Multi-client video chat server class.</p> <p>Methods: - <code>start()</code>: Start the server.</p>"},{"location":"api-reference/#videochatclientserver_ip-video_port9000-audio_port9001-text_port9002-roomdefault-nicknameuser","title":"<code>VideoChatClient(server_ip, video_port=9000, audio_port=9001, text_port=9002, room='default', nickname='user')</code>","text":"<p>Video chat client class.</p> <p>Methods: - <code>start()</code>: Start the client. - <code>send_message(message)</code>: Send a text message. - <code>mute()</code>: Mute microphone. - <code>unmute()</code>: Unmute microphone. - <code>toggle_video()</code>: Toggle video on/off.</p>"},{"location":"api-reference/#connection-pooling","title":"Connection Pooling","text":""},{"location":"api-reference/#classes_2","title":"Classes","text":""},{"location":"api-reference/#tcpconnectionpoolhost-port-max_size10-idle_timeout60-sslfalse-ssl_kwargs","title":"<code>TCPConnectionPool(host, port, max_size=10, idle_timeout=60, ssl=False, **ssl_kwargs)</code>","text":"<p>TCP connection pool for efficient connection reuse.</p> <p>Methods: - <code>connection()</code>: Get a connection from the pool. - <code>closeall()</code>: Close all connections in the pool.</p>"},{"location":"api-reference/#utilities","title":"Utilities","text":""},{"location":"api-reference/#network-utilities","title":"Network Utilities","text":""},{"location":"api-reference/#get_free_port","title":"<code>get_free_port()</code>","text":"<p>Find a free TCP port.</p> <p>Returns: int</p>"},{"location":"api-reference/#get_local_ip","title":"<code>get_local_ip()</code>","text":"<p>Get the local IP address.</p> <p>Returns: str</p>"},{"location":"api-reference/#file-utilities","title":"File Utilities","text":""},{"location":"api-reference/#chunked_file_readerfilepath-chunk_size4096","title":"<code>chunked_file_reader(filepath, chunk_size=4096)</code>","text":"<p>Yield file data in chunks.</p> <p>Parameters: - <code>filepath</code> (str): Path to file. - <code>chunk_size</code> (int): Bytes per chunk.</p> <p>Returns: Iterator[bytes]</p>"},{"location":"api-reference/#recv_allsock-total_bytes","title":"<code>recv_all(sock, total_bytes)</code>","text":"<p>Receive exactly <code>total_bytes</code> from a socket.</p> <p>Parameters: - <code>sock</code> (socket.socket): Socket. - <code>total_bytes</code> (int): Number of bytes to receive.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#progress-display","title":"Progress Display","text":""},{"location":"api-reference/#print_progressreceived_bytes-total_bytes","title":"<code>print_progress(received_bytes, total_bytes)</code>","text":"<p>Print file transfer progress.</p> <p>Parameters: - <code>received_bytes</code> (int): Bytes received. - <code>total_bytes</code> (int): Total bytes.</p> <p>Returns: None</p>"},{"location":"api-reference/#json-utility","title":"JSON Utility","text":""},{"location":"api-reference/#is_valid_jsonjson_string","title":"<code>is_valid_json(json_string)</code>","text":"<p>Check if a string is valid JSON.</p> <p>Parameters: - <code>json_string</code> (str): String to check.</p> <p>Returns: bool</p>"},{"location":"api-reference/#decorators","title":"Decorators","text":"<p>kn-sock provides utility decorators for enhanced error handling, performance monitoring, retry logic, and data validation. For detailed examples and usage patterns, see Decorators Guide.</p>"},{"location":"api-reference/#log_exceptionsraise_errortrue","title":"<code>@log_exceptions(raise_error=True)</code>","text":"<p>Automatically logs exceptions that occur in decorated functions, with optional re-raising.</p> <p>Parameters: - <code>raise_error</code> (bool, default: True): Whether to re-raise the exception after logging.</p> <p>Returns: Decorator function</p> <p>Example: <pre><code>from kn_sock.decorators import log_exceptions\n\n@log_exceptions(raise_error=False)\ndef tolerant_handler(data, addr, socket):\n    # Exceptions are logged but don't crash the server\n    pass\n</code></pre></p>"},{"location":"api-reference/#retryretries3-delay10-exceptionsexception","title":"<code>@retry(retries=3, delay=1.0, exceptions=(Exception,))</code>","text":"<p>Automatically retries functions that fail, with configurable retry count, delay, and exception types.</p> <p>Parameters: - <code>retries</code> (int, default: 3): Maximum number of retry attempts. - <code>delay</code> (float, default: 1.0): Delay in seconds between retries. - <code>exceptions</code> (tuple, default: (Exception,)): Tuple of exception types to catch and retry.</p> <p>Returns: Decorator function</p> <p>Example: <pre><code>from kn_sock.decorators import retry\n\n@retry(retries=5, delay=2.0, exceptions=(ConnectionError, TimeoutError))\ndef network_operation():\n    # Retries up to 5 times on network errors\n    pass\n</code></pre></p>"},{"location":"api-reference/#measure_time","title":"<code>@measure_time</code>","text":"<p>Measures and logs the execution time of decorated functions using the standard Python logging system.</p> <p>Parameters: None</p> <p>Returns: Decorator function</p> <p>Example: <pre><code>from kn_sock.decorators import measure_time\n\n@measure_time\ndef process_data(data):\n    # Logs: \"[TIMER] process_data executed in 1.2345 seconds\"\n    return expensive_computation(data)\n</code></pre></p>"},{"location":"api-reference/#ensure_json_input","title":"<code>@ensure_json_input</code>","text":"<p>Validates that the first argument to a function is valid JSON data (dict or JSON string). Automatically converts JSON strings to dictionaries.</p> <p>Parameters: None</p> <p>Returns: Decorator function</p> <p>Raises: - <code>InvalidJSONError</code>: If input is not valid JSON</p> <p>Example: <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, socket):\n    # data is guaranteed to be a dict at this point\n    message_type = data.get('type')\n    # Process the message...\n</code></pre></p> <p>Stacking Decorators: <pre><code>@log_exceptions(raise_error=False)\n@retry(retries=2, delay=0.5)\n@measure_time\n@ensure_json_input\ndef robust_handler(data, addr, socket):\n    # Fully decorated handler with all features\n    pass\n</code></pre></p>"},{"location":"api-reference/#errors","title":"Errors","text":""},{"location":"api-reference/#base-exception","title":"Base Exception","text":""},{"location":"api-reference/#easysocketerror","title":"<code>EasySocketError</code>","text":"<p>Base exception for all kn_sock errors.</p>"},{"location":"api-reference/#connection-errors","title":"Connection Errors","text":""},{"location":"api-reference/#connectiontimeouterror","title":"<code>ConnectionTimeoutError</code>","text":"<p>Raised when a connection or read/write operation times out.</p>"},{"location":"api-reference/#portinuseerror","title":"<code>PortInUseError</code>","text":"<p>Raised when a specified port is already in use.</p>"},{"location":"api-reference/#data-protocol-errors","title":"Data &amp; Protocol Errors","text":""},{"location":"api-reference/#invalidjsonerror","title":"<code>InvalidJSONError</code>","text":"<p>Raised when a JSON message cannot be decoded.</p>"},{"location":"api-reference/#unsupportedprotocolerror","title":"<code>UnsupportedProtocolError</code>","text":"<p>Raised when a requested protocol is not supported.</p>"},{"location":"api-reference/#file-transfer-errors","title":"File Transfer Errors","text":""},{"location":"api-reference/#filetransfererror","title":"<code>FileTransferError</code>","text":"<p>Raised when file transfer fails.</p>"},{"location":"api-reference/#compression","title":"Compression","text":""},{"location":"api-reference/#functions","title":"Functions","text":""},{"location":"api-reference/#compress_datadata-methodgzip","title":"<code>compress_data(data, method='gzip')</code>","text":"<p>Compress data using gzip or deflate.</p> <p>Parameters: - <code>data</code> (bytes): Data to compress. - <code>method</code> (str): Compression method ('gzip' or 'deflate').</p> <p>Returns: bytes</p>"},{"location":"api-reference/#decompress_datadata","title":"<code>decompress_data(data)</code>","text":"<p>Decompress data (auto-detects gzip/deflate).</p> <p>Parameters: - <code>data</code> (bytes): Compressed data.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#detect_compressiondata","title":"<code>detect_compression(data)</code>","text":"<p>Detect compression type.</p> <p>Parameters: - <code>data</code> (bytes): Data to analyze.</p> <p>Returns: str ('gzip', 'deflate', or 'none')</p>"},{"location":"api-reference/#message-queues","title":"Message Queues","text":""},{"location":"api-reference/#classes_3","title":"Classes","text":""},{"location":"api-reference/#inmemoryqueue","title":"<code>InMemoryQueue()</code>","text":"<p>Thread-safe FIFO queue for fast, in-memory message passing.</p> <p>Methods: - <code>put(item)</code>: Add item to queue. - <code>get()</code>: Get item from queue. - <code>task_done()</code>: Mark task as done. - <code>join()</code>: Wait for all tasks to complete. - <code>empty()</code>: Check if queue is empty. - <code>qsize()</code>: Get queue size.</p>"},{"location":"api-reference/#filequeuefilename","title":"<code>FileQueue(filename)</code>","text":"<p>Persistent queue that stores messages on disk.</p> <p>Methods: Same as InMemoryQueue plus: - <code>close()</code>: Close the queue.</p>"},{"location":"api-reference/#protocol-buffers","title":"Protocol Buffers","text":""},{"location":"api-reference/#functions_1","title":"Functions","text":""},{"location":"api-reference/#serialize_messagemsg","title":"<code>serialize_message(msg)</code>","text":"<p>Serialize a protobuf message to bytes.</p> <p>Parameters: - <code>msg</code>: Protobuf message object.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#deserialize_messagedata-schema","title":"<code>deserialize_message(data, schema)</code>","text":"<p>Deserialize bytes to a protobuf message.</p> <p>Parameters: - <code>data</code> (bytes): Serialized data. - <code>schema</code>: Protobuf message class.</p> <p>Returns: Protobuf message object</p>"},{"location":"api-reference/#load-balancing","title":"Load Balancing","text":""},{"location":"api-reference/#classes_4","title":"Classes","text":""},{"location":"api-reference/#roundrobinloadbalancer","title":"<code>RoundRobinLoadBalancer()</code>","text":"<p>Cycles through servers in order.</p> <p>Methods: - <code>add_server(server)</code>: Add a server. - <code>remove_server(server)</code>: Remove a server. - <code>get_server()</code>: Get next server in round-robin order.</p>"},{"location":"api-reference/#leastconnectionsloadbalancer","title":"<code>LeastConnectionsLoadBalancer()</code>","text":"<p>Selects server with fewest active connections.</p> <p>Methods: Same as RoundRobinLoadBalancer plus: - <code>update_connections(server, count)</code>: Update connection count for server.</p>"},{"location":"api-reference/#interactive-cli","title":"Interactive CLI","text":""},{"location":"api-reference/#functions_2","title":"Functions","text":""},{"location":"api-reference/#start_interactive_cli","title":"<code>start_interactive_cli()</code>","text":"<p>Start the interactive command-line interface.</p> <p>Returns: None</p>"},{"location":"api-reference/#commands","title":"Commands","text":"<ul> <li><code>connect &lt;name&gt; &lt;host&gt; &lt;port&gt;</code>: Connect to a server</li> <li><code>list</code>: List all active connections</li> <li><code>select &lt;name&gt;</code>: Set default connection</li> <li><code>send &lt;message&gt;</code>: Send a message</li> <li><code>receive</code>: Receive a message</li> <li><code>bg_receive</code>: Toggle background receive mode</li> <li><code>history</code>: Show message history</li> <li><code>disconnect &lt;name&gt;</code>: Disconnect a connection</li> <li><code>quit</code>/<code>exit</code>: Exit the CLI</li> <li><code>help</code>: Show help</li> </ul>"},{"location":"api-reference/#network-visibility-functions","title":"Network Visibility Functions","text":"<p>\u26a0\ufe0f ETHICAL WARNING: These functions are intended for use in authorized networks such as schools, labs, or controlled IT environments. Monitoring user traffic may be illegal without explicit consent. Use responsibly and ethically.</p>"},{"location":"api-reference/#arp-scanning-functions","title":"ARP Scanning Functions","text":""},{"location":"api-reference/#arp_scannetwork_range-interfacenone-timeout2-verbosefalse","title":"<code>arp_scan(network_range, interface=None, timeout=2, verbose=False)</code>","text":"<p>Perform ARP scan on a network range to discover active devices.</p> <p>Parameters: - <code>network_range</code> (str): Network range to scan (e.g., \"192.168.1.0/24\") - <code>interface</code> (str, optional): Network interface to use (auto-detect if None) - <code>timeout</code> (int): Timeout in seconds for each ARP request (default: 2) - <code>verbose</code> (bool): Enable verbose logging (default: False)</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of dictionaries containing IP and MAC addresses of discovered devices</p> <p>Raises: - <code>ImportError</code>: If scapy is not available - <code>ValueError</code>: If network range is invalid - <code>RuntimeError</code>: If scanning fails</p> <p>Example: <pre><code>from kn_sock.network import arp_scan\n\ndevices = arp_scan(\"192.168.1.0/24\", verbose=True)\nfor device in devices:\n    print(f\"IP: {device['ip']}, MAC: {device['mac']}\")\n</code></pre></p>"},{"location":"api-reference/#arp_scan_simpleip_range","title":"<code>arp_scan_simple(ip_range)</code>","text":"<p>Simple ARP scan that returns IP and MAC pairs.</p> <p>Parameters: - <code>ip_range</code> (str): IP range to scan (e.g., \"192.168.1.0/24\")</p> <p>Returns: - <code>List[Tuple[str, str]]</code>: List of tuples containing (IP, MAC) pairs</p>"},{"location":"api-reference/#get_local_network_info","title":"<code>get_local_network_info()</code>","text":"<p>Get information about the local network.</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing network information (local_ip, interface, gateway)</p>"},{"location":"api-reference/#mac-address-lookup-functions","title":"MAC Address Lookup Functions","text":""},{"location":"api-reference/#mac_lookupmac-use_apitrue-api_keynone","title":"<code>mac_lookup(mac, use_api=True, api_key=None)</code>","text":"<p>Lookup MAC address vendor information.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup - <code>use_api</code> (bool): Whether to use online API (default: True) - <code>api_key</code> (str, optional): Optional API key for online lookup</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information (mac, oui, vendor, source)</p> <p>Raises: - <code>ValueError</code>: If MAC address is invalid - <code>requests.RequestException</code>: If API request fails</p> <p>Example: <pre><code>from kn_sock.network import mac_lookup\n\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\")\nprint(f\"Vendor: {result['vendor']}\")\n</code></pre></p>"},{"location":"api-reference/#mac_lookup_apimac-api_keynone","title":"<code>mac_lookup_api(mac, api_key=None)</code>","text":"<p>Lookup MAC address vendor using macvendors.co API.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup - <code>api_key</code> (str, optional): Optional API key for higher rate limits</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information</p>"},{"location":"api-reference/#mac_lookup_offlinemac","title":"<code>mac_lookup_offline(mac)</code>","text":"<p>Lookup MAC address vendor using built-in OUI database.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information</p>"},{"location":"api-reference/#batch_mac_lookupmacs-use_apitrue-api_keynone","title":"<code>batch_mac_lookup(macs, use_api=True, api_key=None)</code>","text":"<p>Lookup multiple MAC addresses.</p> <p>Parameters: - <code>macs</code> (List[str]): List of MAC addresses to lookup - <code>use_api</code> (bool): Whether to use online API - <code>api_key</code> (str, optional): Optional API key for online lookup</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of dictionaries containing vendor information</p>"},{"location":"api-reference/#validate_macmac","title":"<code>validate_mac(mac)</code>","text":"<p>Validate MAC address format.</p> <p>Parameters: - <code>mac</code> (str): MAC address to validate</p> <p>Returns: - <code>bool</code>: True if valid, False otherwise</p>"},{"location":"api-reference/#dns-monitoring-functions","title":"DNS Monitoring Functions","text":""},{"location":"api-reference/#monitor_dnsduration60-interfacenone-log_filenone-callbacknone-verbosefalse","title":"<code>monitor_dns(duration=60, interface=None, log_file=None, callback=None, verbose=False)</code>","text":"<p>Monitor DNS requests on the network.</p> <p>Parameters: - <code>duration</code> (int): Duration to monitor in seconds (default: 60) - <code>interface</code> (str, optional): Network interface to monitor (auto-detect if None) - <code>log_file</code> (str, optional): File to save DNS logs (JSON format) - <code>callback</code> (callable, optional): Function to call for each DNS request - <code>verbose</code> (bool): Enable verbose logging (default: False)</p> <p>Returns: - <code>List[Dict[str, Any]]</code>: List of DNS request records</p> <p>Raises: - <code>ImportError</code>: If scapy is not available - <code>PermissionError</code>: If insufficient privileges - <code>RuntimeError</code>: If monitoring fails</p> <p>Example: <pre><code>from kn_sock.network import monitor_dns\n\nresults = monitor_dns(duration=60, log_file=\"dns_log.json\", verbose=True)\nfor result in results:\n    print(f\"{result['source_ip']} -&gt; {result['domain']}\")\n</code></pre></p>"},{"location":"api-reference/#monitor_dns_asyncduration60-interfacenone-log_filenone-callbacknone-verbosefalse","title":"<code>monitor_dns_async(duration=60, interface=None, log_file=None, callback=None, verbose=False)</code>","text":"<p>Start DNS monitoring in a separate thread.</p> <p>Parameters: - <code>duration</code> (int): Duration to monitor in seconds - <code>interface</code> (str, optional): Network interface to monitor - <code>log_file</code> (str, optional): File to save DNS logs - <code>callback</code> (callable, optional): Function to call for each DNS request - <code>verbose</code> (bool): Enable verbose logging</p> <p>Returns: - <code>threading.Thread</code>: Thread object running the monitoring</p>"},{"location":"api-reference/#analyze_dns_logslog_file","title":"<code>analyze_dns_logs(log_file)</code>","text":"<p>Analyze DNS logs and provide statistics.</p> <p>Parameters: - <code>log_file</code> (str): Path to DNS log file (JSON format)</p> <p>Returns: - <code>Dict[str, Any]</code>: Dictionary containing analysis results</p> <p>Raises: - <code>FileNotFoundError</code>: If log file not found - <code>ValueError</code>: If invalid JSON in log file</p>"},{"location":"api-reference/#get_network_interfaces","title":"<code>get_network_interfaces()</code>","text":"<p>Get list of available network interfaces.</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of interface information</p>"},{"location":"api-reference/#cli-commands","title":"CLI Commands","text":"<p>The network module provides the following CLI commands:</p>"},{"location":"api-reference/#knsock-scan-range-options","title":"<code>knsock scan &lt;range&gt; [options]</code>","text":"<p>Scan network for devices using ARP.</p> <p>Arguments: - <code>range</code>: Network range to scan (e.g., 192.168.1.0/24) - <code>--interface</code>: Network interface to use (auto-detect if not specified) - <code>--timeout</code>: Timeout in seconds for each ARP request (default: 2) - <code>--verbose</code>: Enable verbose output</p> <p>Example: <pre><code>knsock scan 192.168.1.0/24 --verbose\n</code></pre></p>"},{"location":"api-reference/#knsock-mac-lookup-mac-options","title":"<code>knsock mac-lookup &lt;mac&gt; [options]</code>","text":"<p>Lookup MAC address vendor information.</p> <p>Arguments: - <code>mac</code>: MAC address to lookup (e.g., 00:1A:2B:3C:4D:5E) - <code>--offline</code>: Use offline lookup only (no API calls) - <code>--api-key</code>: API key for macvendors.co (optional)</p> <p>Example: <pre><code>knsock mac-lookup 00:1A:2B:3C:4D:5E --offline\n</code></pre></p>"},{"location":"api-reference/#knsock-monitor-options","title":"<code>knsock monitor [options]</code>","text":"<p>Monitor DNS requests on the network.</p> <p>Arguments: - <code>--duration</code>: Duration to monitor in seconds (default: 60) - <code>--interface</code>: Network interface to monitor (auto-detect if not specified) - <code>--log</code>: File to save DNS logs (JSON format) - <code>--verbose</code>: Enable verbose output</p> <p>Example: <pre><code>knsock monitor --duration 120 --log dns_log.json --verbose\n</code></pre></p>"},{"location":"api-reference/#dependencies","title":"Dependencies","text":"<p>The network module requires the following optional dependencies:</p> <ul> <li> <p>scapy: For ARP scanning and DNS monitoring   <pre><code>pip install scapy\n</code></pre></p> </li> <li> <p>psutil: For network interface detection   <pre><code>pip install psutil\n</code></pre></p> </li> <li> <p>requests: For MAC vendor API lookups   <pre><code>pip install requests\n</code></pre></p> </li> </ul>"},{"location":"api-reference/#security-and-legal-considerations","title":"Security and Legal Considerations","text":"<p>\u26a0\ufe0f IMPORTANT LEGAL NOTICE:</p> <ol> <li> <p>Authorization Required: Only use these tools on networks you own or have explicit permission to monitor.</p> </li> <li> <p>Legal Compliance: Network monitoring may be subject to local laws and regulations. Ensure compliance with applicable privacy and surveillance laws.</p> </li> <li> <p>Ethical Use: These tools should only be used for legitimate network administration, security testing, or educational purposes.</p> </li> <li> <p>Privilege Requirements: Some functions require root/administrator privileges for packet sniffing.</p> </li> <li> <p>Data Privacy: Be mindful of sensitive information that may be captured during monitoring.</p> </li> </ol>"},{"location":"api-reference/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues:</p> <ol> <li> <p>Permission Denied: Run with <code>sudo</code> or as administrator for packet sniffing operations.</p> </li> <li> <p>Scapy Import Error: Install scapy with <code>pip install scapy</code>.</p> </li> <li> <p>No Devices Found: Check network range and interface selection.</p> </li> <li> <p>API Rate Limits: Use offline mode or provide API key for MAC lookups.</p> </li> <li> <p>Interface Detection: Manually specify interface if auto-detection fails.</p> </li> </ol>"},{"location":"cli/","title":"Command-Line Interface","text":"<p>kn-sock provides a comprehensive command-line interface for quick socket operations and testing.</p>"},{"location":"cli/#overview","title":"Overview","text":"<p>The <code>kn-sock</code> CLI allows you to: - Start servers for various protocols - Send messages and files - Connect to live streams and video chat - Use interactive mode for real-time communication - Test network connectivity</p>"},{"location":"cli/#basic-commands","title":"Basic Commands","text":""},{"location":"cli/#tcp-commands","title":"TCP Commands","text":""},{"location":"cli/#start-tcp-server","title":"Start TCP Server","text":"<pre><code>kn-sock run-tcp-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-tcp-server 8080\nkn-sock run-tcp-server 8080 --host 127.0.0.1\n</code></pre></p>"},{"location":"cli/#send-tcp-message","title":"Send TCP Message","text":"<pre><code>kn-sock send-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-tcp localhost 8080 \"Hello, World!\"\nkn-sock send-tcp 192.168.1.10 8080 \"Test message\"\n</code></pre></p>"},{"location":"cli/#udp-commands","title":"UDP Commands","text":""},{"location":"cli/#start-udp-server","title":"Start UDP Server","text":"<pre><code>kn-sock run-udp-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-udp-server 8080\n</code></pre></p>"},{"location":"cli/#send-udp-message","title":"Send UDP Message","text":"<pre><code>kn-sock send-udp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-udp localhost 8080 \"Hello, UDP!\"\n</code></pre></p>"},{"location":"cli/#send-udp-multicast","title":"Send UDP Multicast","text":"<pre><code>kn-sock send-udp-multicast &lt;group&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Options: - <code>--ttl &lt;ttl&gt;</code>: Time-to-live for multicast packets (default: 1)</p> <p>Example: <pre><code>kn-sock send-udp-multicast 224.0.0.1 8080 \"Multicast message\"\n</code></pre></p>"},{"location":"cli/#secure-tcp-ssltls-commands","title":"Secure TCP (SSL/TLS) Commands","text":""},{"location":"cli/#start-secure-tcp-server","title":"Start Secure TCP Server","text":"<pre><code>kn-sock run-ssl-tcp-server &lt;port&gt; &lt;certfile&gt; &lt;keyfile&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--cafile &lt;cafile&gt;</code>: CA certificate for client verification - <code>--require-client-cert</code>: Require client certificates (mutual TLS)</p> <p>Example: <pre><code>kn-sock run-ssl-tcp-server 8443 server.crt server.key\nkn-sock run-ssl-tcp-server 8443 server.crt server.key --cafile ca.crt --require-client-cert\n</code></pre></p>"},{"location":"cli/#send-secure-tcp-message","title":"Send Secure TCP Message","text":"<pre><code>kn-sock send-ssl-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Options: - <code>--cafile &lt;cafile&gt;</code>: CA certificate for server verification - <code>--certfile &lt;certfile&gt;</code>: Client certificate - <code>--keyfile &lt;keyfile&gt;</code>: Client private key - <code>--no-verify</code>: Disable server certificate verification</p> <p>Example: <pre><code>kn-sock send-ssl-tcp localhost 8443 \"Hello Secure\"\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\" --cafile ca.crt --certfile client.crt --keyfile client.key\n</code></pre></p>"},{"location":"cli/#file-transfer-commands","title":"File Transfer Commands","text":""},{"location":"cli/#start-file-server","title":"Start File Server","text":"<pre><code>kn-sock run-file-server &lt;port&gt; &lt;save_directory&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-file-server 8080 /path/to/save/directory\n</code></pre></p>"},{"location":"cli/#send-file","title":"Send File","text":"<pre><code>kn-sock send-file &lt;host&gt; &lt;port&gt; &lt;filepath&gt;\n</code></pre> <p>Options: - <code>--show-progress</code>: Show progress bar (default: true) - <code>--no-progress</code>: Hide progress bar</p> <p>Example: <pre><code>kn-sock send-file localhost 8080 /path/to/file.txt\nkn-sock send-file localhost 8080 large_file.zip --show-progress\n</code></pre></p>"},{"location":"cli/#json-commands","title":"JSON Commands","text":""},{"location":"cli/#send-json-data","title":"Send JSON Data","text":"<pre><code>kn-sock send-json &lt;host&gt; &lt;port&gt; &lt;json_data&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-json localhost 8080 '{\"message\": \"Hello\", \"type\": \"greeting\"}'\nkn-sock send-json localhost 8080 '{\"user_id\": 123, \"action\": \"login\"}'\n</code></pre></p>"},{"location":"cli/#websocket-commands","title":"WebSocket Commands","text":""},{"location":"cli/#start-websocket-server","title":"Start WebSocket Server","text":"<pre><code>kn-sock run-websocket-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Example: <pre><code>kn-sock run-websocket-server 127.0.0.1 8765\n</code></pre></p>"},{"location":"cli/#connect-to-websocket","title":"Connect to WebSocket","text":"<pre><code>kn-sock connect-websocket &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--resource &lt;path&gt;</code>: WebSocket resource path (default: /) - <code>--headers &lt;json&gt;</code>: Additional headers as JSON</p> <p>Example: <pre><code>kn-sock connect-websocket localhost 8765\nkn-sock connect-websocket localhost 8765 --resource /chat --headers '{\"Authorization\": \"Bearer token\"}'\n</code></pre></p>"},{"location":"cli/#http-commands","title":"HTTP Commands","text":""},{"location":"cli/#start-http-server","title":"Start HTTP Server","text":"<pre><code>kn-sock run-http-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--static-dir &lt;directory&gt;</code>: Directory to serve static files - <code>--routes &lt;json&gt;</code>: Custom routes as JSON</p> <p>Example: <pre><code>kn-sock run-http-server 127.0.0.1 8080\nkn-sock run-http-server 127.0.0.1 8080 --static-dir /path/to/static\n</code></pre></p>"},{"location":"cli/#http-get-request","title":"HTTP GET Request","text":"<pre><code>kn-sock http-get &lt;host&gt; &lt;port&gt; &lt;path&gt;\n</code></pre> <p>Options: - <code>--headers &lt;json&gt;</code>: HTTP headers as JSON</p> <p>Example: <pre><code>kn-sock http-get example.com 80 /\nkn-sock http-get api.example.com 443 /users --headers '{\"Authorization\": \"Bearer token\"}'\n</code></pre></p>"},{"location":"cli/#http-post-request","title":"HTTP POST Request","text":"<pre><code>kn-sock http-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;\n</code></pre> <p>Options: - <code>--headers &lt;json&gt;</code>: HTTP headers as JSON</p> <p>Example: <pre><code>kn-sock http-post api.example.com 80 /users '{\"name\": \"John\", \"email\": \"john@example.com\"}'\n</code></pre></p>"},{"location":"cli/#pubsub-commands","title":"Pub/Sub Commands","text":""},{"location":"cli/#start-pubsub-server","title":"Start Pub/Sub Server","text":"<pre><code>kn-sock run-pubsub-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-pubsub-server 9000\n</code></pre></p>"},{"location":"cli/#pubsub-client-commands","title":"Pub/Sub Client Commands","text":"<pre><code># Subscribe to a topic\nkn-sock pubsub-subscribe &lt;host&gt; &lt;port&gt; &lt;topic&gt;\n\n# Publish a message\nkn-sock pubsub-publish &lt;host&gt; &lt;port&gt; &lt;topic&gt; &lt;message&gt;\n\n# Receive messages\nkn-sock pubsub-receive &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Example: <pre><code>kn-sock pubsub-subscribe localhost 9000 news\nkn-sock pubsub-publish localhost 9000 news \"Breaking news!\"\nkn-sock pubsub-receive localhost 9000\n</code></pre></p>"},{"location":"cli/#rpc-commands","title":"RPC Commands","text":""},{"location":"cli/#start-rpc-server","title":"Start RPC Server","text":"<pre><code>kn-sock run-rpc-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--functions &lt;json&gt;</code>: Functions to register as JSON</p> <p>Example: <pre><code>kn-sock run-rpc-server 9001\nkn-sock run-rpc-server 9001 --functions '{\"add\": \"lambda x, y: x + y\", \"echo\": \"lambda msg: msg\"}'\n</code></pre></p>"},{"location":"cli/#rpc-client-commands","title":"RPC Client Commands","text":"<pre><code># Call a remote function\nkn-sock rpc-call &lt;host&gt; &lt;port&gt; &lt;function&gt; &lt;args...&gt;\n</code></pre> <p>Example: <pre><code>kn-sock rpc-call localhost 9001 add 2 3\nkn-sock rpc-call localhost 9001 echo \"Hello RPC\"\n</code></pre></p>"},{"location":"cli/#live-streaming-commands","title":"Live Streaming Commands","text":""},{"location":"cli/#start-live-stream-server","title":"Start Live Stream Server","text":"<pre><code>kn-sock run-live-server &lt;port&gt; &lt;video_files...&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: port + 1)</p> <p>Example: <pre><code>kn-sock run-live-server 9000 video1.mp4 video2.mp4 video3.mp4\nkn-sock run-live-server 9000 movie.mp4 --host 0.0.0.0 --audio-port 9001\n</code></pre></p>"},{"location":"cli/#connect-to-live-stream","title":"Connect to Live Stream","text":"<pre><code>kn-sock connect-live-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--audio-port &lt;port&gt;</code>: Audio port (default: port + 1)</p> <p>Example: <pre><code>kn-sock connect-live-server 192.168.1.10 9000\nkn-sock connect-live-server 192.168.1.10 9000 --audio-port 9001\n</code></pre></p>"},{"location":"cli/#video-chat-commands","title":"Video Chat Commands","text":""},{"location":"cli/#start-video-chat-server","title":"Start Video Chat Server","text":"<pre><code>kn-sock run-video-chat-server\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--video-port &lt;port&gt;</code>: Video port (default: 9000) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: 9001) - <code>--text-port &lt;port&gt;</code>: Text port (default: 9002)</p> <p>Example: <pre><code>kn-sock run-video-chat-server\nkn-sock run-video-chat-server --host 0.0.0.0 --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre></p>"},{"location":"cli/#connect-to-video-chat","title":"Connect to Video Chat","text":"<pre><code>kn-sock connect-video-chat &lt;server_ip&gt; &lt;room&gt; &lt;nickname&gt;\n</code></pre> <p>Options: - <code>--video-port &lt;port&gt;</code>: Video port (default: 9000) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: 9001) - <code>--text-port &lt;port&gt;</code>: Text port (default: 9002) - <code>--no-audio</code>: Disable audio functionality</p> <p>Example: <pre><code>kn-sock connect-video-chat 127.0.0.1 myroom alice\nkn-sock connect-video-chat 192.168.1.10 conference john --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre></p>"},{"location":"cli/#interactive-mode","title":"Interactive Mode","text":""},{"location":"cli/#start-interactive-cli","title":"Start Interactive CLI","text":"<pre><code>kn-sock interactive\n</code></pre>"},{"location":"cli/#interactive-commands","title":"Interactive Commands","text":"<p>Once in interactive mode, you can use these commands:</p>"},{"location":"cli/#connection-management","title":"Connection Management","text":"<pre><code># Connect to a server\nconnect &lt;name&gt; &lt;host&gt; &lt;port&gt;\n\n# List all connections\nlist\n\n# Select default connection\nselect &lt;name&gt;\n\n# Disconnect a connection\ndisconnect &lt;name&gt;\n</code></pre>"},{"location":"cli/#communication","title":"Communication","text":"<pre><code># Send a message\nsend &lt;message&gt;\n\n# Receive a message\nreceive\n\n# Toggle background receive mode\nbg_receive\n\n# Show message history\nhistory\n</code></pre>"},{"location":"cli/#utility","title":"Utility","text":"<pre><code># Show help\nhelp\n\n# Exit the CLI\nquit\nexit\n</code></pre>"},{"location":"cli/#interactive-session-example","title":"Interactive Session Example","text":"<pre><code>$ kn-sock interactive\nkn-sock&gt; connect server1 localhost 8080\nConnected to localhost:8080 as 'server1'\nkn-sock&gt; send Hello, server!\nMessage sent\nkn-sock&gt; receive\nReceived: Message received!\nkn-sock&gt; bg_receive\nBackground receive mode enabled\nkn-sock&gt; send Another message\nMessage sent\nReceived: Message received!\nkn-sock&gt; history\nLast 10 messages:\n1. [SENT] Hello, server!\n2. [RECV] Message received!\n3. [SENT] Another message\n4. [RECV] Message received!\nkn-sock&gt; disconnect server1\nDisconnected from server1\nkn-sock&gt; quit\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--help</code>, <code>-h</code>: Show help message</li> <li><code>--version</code>, <code>-v</code>: Show version information</li> <li><code>--verbose</code>: Enable verbose output</li> <li><code>--quiet</code>: Suppress output (except errors)</li> </ul>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#complete-workflow-examples","title":"Complete Workflow Examples","text":""},{"location":"cli/#tcp-echo-server-and-client","title":"TCP Echo Server and Client","text":"<pre><code># Terminal 1: Start server\nkn-sock run-tcp-server 8080\n\n# Terminal 2: Send message\nkn-sock send-tcp localhost 8080 \"Hello, World!\"\n</code></pre>"},{"location":"cli/#file-transfer","title":"File Transfer","text":"<pre><code># Terminal 1: Start file server\nkn-sock run-file-server 8080 /tmp/received\n\n# Terminal 2: Send file\nkn-sock send-file localhost 8080 /path/to/document.pdf\n</code></pre>"},{"location":"cli/#secure-communication","title":"Secure Communication","text":"<pre><code># Terminal 1: Start secure server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key\n\n# Terminal 2: Send secure message\nkn-sock send-ssl-tcp localhost 8443 \"Secret message\"\n</code></pre>"},{"location":"cli/#live-streaming","title":"Live Streaming","text":"<pre><code># Terminal 1: Start live stream server\nkn-sock run-live-server 9000 movie.mp4\n\n# Terminal 2: Connect as client\nkn-sock connect-live-server 192.168.1.10 9000\n</code></pre>"},{"location":"cli/#video-chat","title":"Video Chat","text":"<pre><code># Terminal 1: Start video chat server\nkn-sock run-video-chat-server\n\n# Terminal 2: Connect as client\nkn-sock connect-video-chat 127.0.0.1 meeting alice\n\n# Terminal 3: Connect another client\nkn-sock connect-video-chat 127.0.0.1 meeting bob\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Port already in use <pre><code># Use a different port\nkn-sock run-tcp-server 8081\n</code></pre></p> </li> <li> <p>Permission denied <pre><code># Use a higher port number\nkn-sock run-tcp-server 8080\n</code></pre></p> </li> <li> <p>Connection refused <pre><code># Make sure server is running first\nkn-sock run-tcp-server 8080 &amp;\nkn-sock send-tcp localhost 8080 \"test\"\n</code></pre></p> </li> <li> <p>SSL certificate issues <pre><code># For testing, disable verification\nkn-sock send-ssl-tcp localhost 8443 \"test\" --no-verify\n</code></pre></p> </li> </ol>"},{"location":"cli/#debug-mode","title":"Debug Mode","text":"<p>Enable verbose output for debugging:</p> <pre><code>kn-sock --verbose run-tcp-server 8080\nkn-sock --verbose send-tcp localhost 8080 \"test\"\n</code></pre>"},{"location":"cli/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic usage examples</li> <li>Interactive CLI - For detailed interactive mode documentation</li> <li>API Reference - For programmatic usage </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Configuration options for customizing kn-sock behavior.</p>"},{"location":"configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"configuration/#yaml-configuration","title":"YAML Configuration","text":"<p>Create <code>config.yaml</code>:</p> <pre><code>network:\n  host: \"0.0.0.0\"\n  port: 8080\n  timeout: 30\n\nssl:\n  cert_file: \"server.crt\"\n  key_file: \"server.key\"\n  ca_file: \"ca.crt\"\n\nlogging:\n  level: \"INFO\"\n</code></pre>"},{"location":"configuration/#json-configuration","title":"JSON Configuration","text":"<p>Create <code>config.json</code>:</p> <pre><code>{\n  \"network\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8080,\n    \"timeout\": 30\n  },\n  \"ssl\": {\n    \"cert_file\": \"server.crt\", \n    \"key_file\": \"server.key\"\n  }\n}\n</code></pre>"},{"location":"configuration/#using-configuration","title":"Using Configuration","text":"<pre><code>from kn_sock.config import load_config, get_config\n\n# Load configuration file\nload_config(\"config.yaml\")\n\n# Get configuration values\nhost = get_config(\"network.host\", \"localhost\")\nport = get_config(\"network.port\", 8080)\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Override configuration with environment variables:</p> <pre><code>export KN_SOCK_HOST=\"127.0.0.1\"\nexport KN_SOCK_PORT=\"9000\"\nexport KN_SOCK_SSL_VERIFY=\"false\"\n</code></pre>"},{"location":"configuration/#common-settings","title":"Common Settings","text":"Setting Description Default <code>host</code> Server bind address \"0.0.0.0\" <code>port</code> Server port 8080 <code>timeout</code> Connection timeout 30 seconds <code>buffer_size</code> Socket buffer size 4096 bytes <code>ssl.verify</code> SSL certificate verification True"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Settings are applied in order: 1. Built-in defaults 2. Configuration file 3. Environment variables 4. Runtime parameters</p>"},{"location":"decorators/","title":"Decorators","text":"<p>kn-sock provides a collection of useful decorators to enhance your socket programming workflow. These decorators help with error handling, performance monitoring, retry logic, and data validation.</p>"},{"location":"decorators/#overview","title":"Overview","text":"<p>The decorators module includes: - Exception logging - Automatic logging of exceptions with optional re-raising - Retry logic - Automatic retry with configurable delays and exception types - Performance monitoring - Execution time measurement and logging - JSON validation - Ensure handler functions receive valid JSON data</p>"},{"location":"decorators/#exception-logging","title":"Exception Logging","text":""},{"location":"decorators/#log_exceptions","title":"<code>@log_exceptions</code>","text":"<p>Automatically logs exceptions that occur in decorated functions, with optional re-raising.</p> <pre><code>from kn_sock.decorators import log_exceptions\n\n@log_exceptions(raise_error=True)\ndef handle_client_message(data, addr, socket):\n    \"\"\"Handler that logs exceptions automatically\"\"\"\n    # Process message - any exceptions will be logged\n    result = process_message(data)\n    socket.sendall(result.encode())\n\n# Usage with TCP server\nfrom kn_sock import start_tcp_server\nstart_tcp_server(8080, handle_client_message)\n</code></pre>"},{"location":"decorators/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>raise_error</code> bool <code>True</code> Whether to re-raise the exception after logging"},{"location":"decorators/#behavior","title":"Behavior","text":"<ul> <li>With <code>raise_error=True</code>: Logs the exception and re-raises it</li> <li>With <code>raise_error=False</code>: Logs the exception and continues execution</li> </ul> <pre><code>@log_exceptions(raise_error=False)\ndef tolerant_handler(data, addr, socket):\n    \"\"\"Handler that continues despite errors\"\"\"\n    # Errors are logged but don't crash the server\n    pass\n\n@log_exceptions(raise_error=True)  # Default behavior\ndef strict_handler(data, addr, socket):\n    \"\"\"Handler that stops on errors\"\"\"\n    # Errors are logged and re-raised\n    pass\n</code></pre>"},{"location":"decorators/#retry-logic","title":"Retry Logic","text":""},{"location":"decorators/#retry","title":"<code>@retry</code>","text":"<p>Automatically retries functions that fail, with configurable retry count, delay, and exception types.</p> <pre><code>from kn_sock.decorators import retry\nimport requests\n\n@retry(retries=3, delay=1.0, exceptions=(ConnectionError, TimeoutError))\ndef send_to_external_api(data):\n    \"\"\"Function that retries on network errors\"\"\"\n    response = requests.post('https://api.example.com/data', json=data)\n    return response.json()\n\n# Usage in handler\ndef handle_message(data, addr, socket):\n    try:\n        result = send_to_external_api(data)\n        socket.sendall(json.dumps(result).encode())\n    except Exception as e:\n        socket.sendall(f\"Failed after retries: {e}\".encode())\n</code></pre>"},{"location":"decorators/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>retries</code> int <code>3</code> Maximum number of retry attempts <code>delay</code> float <code>1.0</code> Delay in seconds between retries <code>exceptions</code> tuple <code>(Exception,)</code> Tuple of exception types to catch and retry"},{"location":"decorators/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Retry only specific exceptions\n@retry(retries=5, delay=2.0, exceptions=(ConnectionError, socket.timeout))\ndef network_operation():\n    # Only retries on connection errors and timeouts\n    pass\n\n# Quick retries with no delay\n@retry(retries=3, delay=0)\ndef fast_retry_operation():\n    pass\n\n# Retry all exceptions (default)\n@retry(retries=2)\ndef retry_everything():\n    pass\n</code></pre>"},{"location":"decorators/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"decorators/#measure_time","title":"<code>@measure_time</code>","text":"<p>Measures and logs the execution time of decorated functions.</p> <pre><code>from kn_sock.decorators import measure_time\n\n@measure_time\ndef process_large_dataset(data):\n    \"\"\"Function with performance monitoring\"\"\"\n    # Complex processing...\n    result = expensive_computation(data)\n    return result\n\n# Usage in server handler\n@measure_time\ndef handle_file_upload(data, addr, socket):\n    \"\"\"Handler with timing\"\"\"\n    processed_data = process_large_dataset(data)\n    socket.sendall(processed_data)\n</code></pre>"},{"location":"decorators/#output","title":"Output","text":"<p>The decorator logs execution time using the standard Python logging system:</p> <pre><code>INFO:kn_sock.decorators:[TIMER] process_large_dataset executed in 2.3456 seconds\nINFO:kn_sock.decorators:[TIMER] handle_file_upload executed in 0.1234 seconds\n</code></pre>"},{"location":"decorators/#configuration","title":"Configuration","text":"<p>Configure logging level to control timer output:</p> <pre><code>import logging\nlogging.getLogger('kn_sock.decorators').setLevel(logging.INFO)\n</code></pre>"},{"location":"decorators/#json-validation","title":"JSON Validation","text":""},{"location":"decorators/#ensure_json_input","title":"<code>@ensure_json_input</code>","text":"<p>Validates that the first argument to a function is valid JSON data (dict or JSON string).</p> <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, socket):\n    \"\"\"Handler that expects JSON input\"\"\"\n    # data is guaranteed to be a dict at this point\n    message_type = data.get('type')\n    payload = data.get('payload')\n\n    response = {\"status\": \"received\", \"type\": message_type}\n    socket.sendall(json.dumps(response).encode())\n\n# Usage with JSON server\nfrom kn_sock import start_json_server\nstart_json_server(8080, handle_json_message)\n</code></pre>"},{"location":"decorators/#behavior_1","title":"Behavior","text":"<ul> <li>Dict input: Passes through unchanged</li> <li>Valid JSON string: Automatically parsed to dict</li> <li>Invalid JSON string: Raises <code>InvalidJSONError</code></li> <li>Other types: Raises <code>InvalidJSONError</code></li> </ul>"},{"location":"decorators/#error-handling","title":"Error Handling","text":"<pre><code>from kn_sock.errors import InvalidJSONError\n\n@ensure_json_input\ndef safe_json_handler(data, addr, socket):\n    try:\n        # Process validated JSON data\n        result = process_json_data(data)\n        socket.sendall(json.dumps(result).encode())\n    except InvalidJSONError as e:\n        error_response = {\"error\": \"invalid_json\", \"message\": str(e)}\n        socket.sendall(json.dumps(error_response).encode())\n</code></pre>"},{"location":"decorators/#combining-decorators","title":"Combining Decorators","text":"<p>Decorators can be stacked for comprehensive error handling and monitoring:</p> <pre><code>from kn_sock.decorators import log_exceptions, retry, measure_time, ensure_json_input\n\n@log_exceptions(raise_error=False)  # Log but don't crash\n@retry(retries=2, delay=0.5)        # Retry on failures\n@measure_time                       # Monitor performance\n@ensure_json_input                  # Validate JSON input\ndef robust_handler(data, addr, socket):\n    \"\"\"Fully decorated handler with all features\"\"\"\n\n    # Process the validated JSON data\n    message_type = data.get('type')\n\n    if message_type == 'ping':\n        response = {\"type\": \"pong\", \"timestamp\": time.time()}\n    else:\n        response = {\"error\": \"unknown_message_type\"}\n\n    socket.sendall(json.dumps(response).encode())\n\n# Usage\nfrom kn_sock import start_json_server\nstart_json_server(8080, robust_handler)\n</code></pre>"},{"location":"decorators/#real-world-examples","title":"Real-World Examples","text":""},{"location":"decorators/#resilient-api-handler","title":"Resilient API Handler","text":"<pre><code>import time\nimport json\nfrom kn_sock.decorators import log_exceptions, retry, measure_time, ensure_json_input\n\n@log_exceptions(raise_error=False)\n@retry(retries=3, delay=1.0, exceptions=(ConnectionError, TimeoutError))\n@measure_time\n@ensure_json_input\ndef api_handler(data, addr, socket):\n    \"\"\"Production-ready API handler\"\"\"\n\n    endpoint = data.get('endpoint')\n    params = data.get('params', {})\n\n    if endpoint == 'get_user':\n        user = fetch_user_from_db(params.get('user_id'))\n        response = {\"status\": \"success\", \"data\": user}\n\n    elif endpoint == 'process_data':\n        result = process_data_with_external_service(params)\n        response = {\"status\": \"success\", \"result\": result}\n\n    else:\n        response = {\"status\": \"error\", \"message\": \"Unknown endpoint\"}\n\n    socket.sendall(json.dumps(response).encode())\n</code></pre>"},{"location":"decorators/#file-processing-handler","title":"File Processing Handler","text":"<pre><code>@log_exceptions()\n@measure_time\ndef file_processor_handler(data, addr, socket):\n    \"\"\"Handler for file processing operations\"\"\"\n\n    try:\n        # Process uploaded file data\n        processed_file = process_file_data(data)\n\n        # Save to storage\n        file_id = save_to_storage(processed_file)\n\n        response = {\n            \"status\": \"success\", \n            \"file_id\": file_id,\n            \"size\": len(processed_file)\n        }\n\n    except Exception as e:\n        response = {\"status\": \"error\", \"message\": str(e)}\n\n    socket.sendall(json.dumps(response).encode())\n</code></pre>"},{"location":"decorators/#chat-server-handler","title":"Chat Server Handler","text":"<pre><code>@log_exceptions(raise_error=False)  # Keep server running\n@ensure_json_input\ndef chat_handler(data, addr, socket):\n    \"\"\"Chat server message handler\"\"\"\n\n    message_type = data.get('type')\n    username = data.get('username')\n    content = data.get('content')\n\n    if message_type == 'join':\n        add_user_to_chat(username, socket)\n        broadcast_message(f\"{username} joined the chat\")\n\n    elif message_type == 'message':\n        broadcast_message(f\"{username}: {content}\")\n\n    elif message_type == 'leave':\n        remove_user_from_chat(username)\n        broadcast_message(f\"{username} left the chat\")\n</code></pre>"},{"location":"decorators/#best-practices","title":"Best Practices","text":""},{"location":"decorators/#1-decorator-order","title":"1. Decorator Order","text":"<p>When stacking decorators, consider the order:</p> <pre><code># Recommended order (bottom to top):\n@log_exceptions()      # Outermost - catches all errors\n@retry()              # Retry logic\n@measure_time         # Performance monitoring\n@ensure_json_input    # Input validation (innermost)\ndef handler(data, addr, socket):\n    pass\n</code></pre>"},{"location":"decorators/#2-exception-handling-strategy","title":"2. Exception Handling Strategy","text":"<pre><code># For critical services - fail fast\n@log_exceptions(raise_error=True)\n@retry(retries=1)  # Minimal retries\ndef critical_handler(data, addr, socket):\n    pass\n\n# For resilient services - keep running\n@log_exceptions(raise_error=False)\n@retry(retries=5, delay=2.0)\ndef resilient_handler(data, addr, socket):\n    pass\n</code></pre>"},{"location":"decorators/#3-performance-monitoring","title":"3. Performance Monitoring","text":"<p>Use <code>@measure_time</code> selectively on operations you want to monitor:</p> <pre><code>@measure_time\ndef expensive_operation(data):\n    # Only monitor time-critical functions\n    pass\n\ndef simple_operation(data):\n    # Don't monitor simple operations\n    pass\n</code></pre>"},{"location":"decorators/#4-logging-configuration","title":"4. Logging Configuration","text":"<p>Configure logging appropriately for your environment:</p> <pre><code>import logging\n\n# Development - see all decorator logs\nlogging.getLogger('kn_sock.decorators').setLevel(logging.DEBUG)\n\n# Production - only errors and warnings\nlogging.getLogger('kn_sock.decorators').setLevel(logging.WARNING)\n</code></pre>"},{"location":"decorators/#error-types","title":"Error Types","text":"<p>The decorators module uses these error types:</p> <ul> <li><code>InvalidJSONError</code>: Raised by <code>@ensure_json_input</code> for invalid JSON data</li> <li>Standard Python exceptions: Handled by <code>@retry</code> and <code>@log_exceptions</code></li> </ul>"},{"location":"decorators/#related-topics","title":"Related Topics","text":"<ul> <li>Error Handling - Complete error handling reference</li> <li>TCP Protocol - Using decorators with TCP servers</li> <li>JSON Communication - JSON validation with decorators</li> <li>Configuration - Logging configuration options</li> </ul>"},{"location":"docker/","title":"Docker Guide","text":"<p>This guide covers how to use kn-sock with Docker for development, testing, and deployment.</p>"},{"location":"docker/#overview","title":"Overview","text":"<p>kn-sock provides Docker support through: - Pre-built Docker images for running CLI commands - Docker Compose configuration for easy development - Containerized test environment - Production-ready deployment options</p>"},{"location":"docker/#quick-start","title":"Quick Start","text":""},{"location":"docker/#using-docker-compose","title":"Using Docker Compose","text":"<p>The easiest way to get started with kn-sock in Docker:</p> <pre><code># Show CLI help\ndocker-compose run knsock --help\n\n# Start a TCP server\ndocker-compose run knsock tcp-server --port 8080\n\n# Send a message from another terminal\ndocker-compose run knsock tcp-client --host localhost --port 8080 --message \"Hello Docker!\"\n</code></pre>"},{"location":"docker/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\ndocker-compose run test\n\n# Run specific test files\ndocker-compose run test pytest test/test_tcp_udp_msg.py -v\n\n# Run tests with coverage\ndocker-compose run test pytest --cov=kn_sock test/\n</code></pre>"},{"location":"docker/#see-also","title":"See Also","text":"<ul> <li>CLI Guide - Complete CLI reference</li> <li>Getting Started - Basic setup without Docker</li> <li>Troubleshooting - Common issues and solutions</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page showcases real-world examples and complete applications built with kn-sock.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#auto-detect-network-and-scan","title":"Auto-Detect Network and Scan","text":"<pre><code>from kn_sock.network import arp_scan\nfrom kn_sock.network.arp import get_local_network_info\n\ndef smart_network_scan():\n    \"\"\"Automatically detect and scan local network.\"\"\"\n    # Get local network information\n    info = get_local_network_info()\n    print(f\"Local IP: {info['local_ip']}\")\n    print(f\"Interface: {info['interface']}\")\n    print(f\"Gateway: {info['gateway']}\")\n\n    # Auto-generate network range\n    local_ip = info['local_ip']\n    if local_ip != \"Unknown\" and '.' in local_ip:\n        ip_parts = local_ip.split('.')\n        network_range = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n        print(f\"\\nScanning network: {network_range}\")\n        devices = arp_scan(network_range, verbose=True)\n\n        if devices:\n            print(f\"\\n\u2705 Found {len(devices)} devices:\")\n            print(\"-\" * 50)\n            for i, device in enumerate(devices, 1):\n                print(f\"{i:2d}. IP: {device['ip']:15s} MAC: {device['mac']}\")\n        else:\n            print(\"No devices found on this network.\")\n    else:\n        print(\"Could not auto-detect network. Please specify manually.\")\n\nif __name__ == \"__main__\":\n    smart_network_scan()\n</code></pre>"},{"location":"examples/#simple-network-inventory","title":"Simple Network Inventory","text":"<pre><code>from kn_sock.network import arp_scan\n\ndef network_inventory(network_range=\"192.168.1.0/24\"):\n    \"\"\"Create a simple network inventory.\"\"\"\n    try:\n        devices = arp_scan(network_range, verbose=True)\n\n        print(f\"Network Inventory - Found {len(devices)} devices:\")\n        print(\"-\" * 50)\n\n        for i, device in enumerate(devices, 1):\n            print(f\"{i:2d}. IP: {device['ip']:15s} MAC: {device['mac']}\")\n\n    except RuntimeError as e:\n        if \"Operation not permitted\" in str(e):\n            print(\"\u274c ARP scan requires root privileges. Run with sudo:\")\n            print(\"sudo python your_script.py\")\n        else:\n            print(f\"\u274c Scan failed: {e}\")\n\nif __name__ == \"__main__\":\n    network_inventory()\n</code></pre>"},{"location":"examples/#continuous-network-monitoring","title":"Continuous Network Monitoring","text":"<pre><code>import time\nfrom kn_sock.network import arp_scan\nfrom kn_sock.network.arp import get_local_network_info\n\ndef monitor_network():\n    \"\"\"Monitor network for device changes.\"\"\"\n    # Auto-detect network range\n    info = get_local_network_info()\n    local_ip = info['local_ip']\n\n    if local_ip == \"Unknown\":\n        print(\"\u274c Could not detect local network. Please specify manually.\")\n        return\n\n    ip_parts = local_ip.split('.')\n    network_range = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n    print(f\"Monitoring network: {network_range}\")\n    print(\"Press Ctrl+C to stop monitoring\\n\")\n\n    known_devices = set()\n    scan_count = 0\n\n    try:\n        while True:\n            scan_count += 1\n            print(f\"[Scan #{scan_count}] Checking network...\")\n\n            try:\n                current_devices = arp_scan(network_range)\n                current_ips = {device['ip'] for device in current_devices}\n\n                # Find new devices\n                new_devices = current_ips - known_devices\n                if new_devices:\n                    print(f\"\ud83d\udd0d New devices detected: {new_devices}\")\n\n                # Find disconnected devices\n                disconnected = known_devices - current_ips\n                if disconnected:\n                    print(f\"\ud83d\udce4 Devices disconnected: {disconnected}\")\n\n                known_devices = current_ips\n                print(f\"\u2705 Currently active: {len(current_ips)} devices\")\n\n            except Exception as e:\n                print(f\"\u274c Scan failed: {e}\")\n\n            time.sleep(30)  # Check every 30 seconds\n\n    except KeyboardInterrupt:\n        print(f\"\\nMonitoring stopped after {scan_count} scans.\")\n\nif __name__ == \"__main__\":\n    monitor_network()\n</code></pre>"},{"location":"examples/#integration-with-mac-lookup","title":"Integration with MAC Lookup","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\nfrom kn_sock.network.arp import get_local_network_info\n\ndef detailed_network_scan():\n    \"\"\"Scan network and identify device vendors.\"\"\"\n    # Auto-detect network\n    info = get_local_network_info()\n    local_ip = info['local_ip']\n\n    if local_ip == \"Unknown\":\n        network_range = \"192.168.1.0/24\"  # Fallback\n        print(f\"Using fallback network range: {network_range}\")\n    else:\n        ip_parts = local_ip.split('.')\n        network_range = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n        print(f\"Scanning detected network: {network_range}\")\n\n    try:\n        devices = arp_scan(network_range)\n\n        if not devices:\n            print(\"No devices found on network.\")\n            return\n\n        print(f\"\\nDetailed Network Analysis - {len(devices)} devices found:\")\n        print(\"=\" * 70)\n\n        for i, device in enumerate(devices, 1):\n            print(f\"\\n[Device #{i}]\")\n            print(f\"IP Address: {device['ip']}\")\n            print(f\"MAC Address: {device['mac']}\")\n\n            # Lookup vendor information\n            try:\n                vendor_info = mac_lookup(device['mac'], use_api=False)  # Use offline first\n                print(f\"Vendor: {vendor_info['vendor']}\")\n                print(f\"OUI: {vendor_info['oui']}\")\n            except Exception as e:\n                print(f\"Vendor lookup failed: {e}\")\n\n            print(\"-\" * 40)\n\n    except Exception as e:\n        if \"Operation not permitted\" in str(e):\n            print(\"\u274c Root privileges required. Run with: sudo python script.py\")\n        else:\n            print(f\"\u274c Scan failed: {e}\")\n\nif __name__ == \"__main__\":\n    detailed_network_scan()\n</code></pre>"},{"location":"examples/#network-device-inventory","title":"Network Device Inventory","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\nfrom kn_sock.network.arp import get_local_network_info\n\ndef device_inventory():\n    \"\"\"Create detailed device inventory with vendor information.\"\"\"\n    # Auto-detect network or use fallback\n    info = get_local_network_info()\n    local_ip = info['local_ip']\n\n    if local_ip != \"Unknown\" and '.' in local_ip:\n        ip_parts = local_ip.split('.')\n        network_range = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n    else:\n        network_range = \"192.168.1.0/24\"  # Fallback\n\n    print(f\"Scanning network: {network_range}\")\n\n    try:\n        # Scan network for devices\n        devices = arp_scan(network_range)\n\n        if not devices:\n            print(\"No devices found on network.\")\n            return\n\n        print(\"\\nNetwork Device Inventory\")\n        print(\"=\" * 60)\n\n        for i, device in enumerate(devices, 1):\n            # Lookup vendor information\n            try:\n                vendor_info = mac_lookup(device['mac'], use_api=False)\n                print(f\"\\n[Device #{i}]\")\n                print(f\"IP Address: {device['ip']}\")\n                print(f\"MAC Address: {device['mac']}\")\n                print(f\"Vendor: {vendor_info['vendor']}\")\n                print(f\"OUI: {vendor_info['oui']}\")\n                print(\"-\" * 40)\n            except Exception as e:\n                print(f\"Vendor lookup failed for {device['mac']}: {e}\")\n\n    except Exception as e:\n        if \"Operation not permitted\" in str(e):\n            print(\"\u274c Root privileges required. Run with: sudo python script.py\")\n        else:\n            print(f\"\u274c Network scan failed: {e}\")\n\nif __name__ == \"__main__\":\n    device_inventory()\n</code></pre>"},{"location":"examples/#virtual-machine-detection","title":"Virtual Machine Detection","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\nfrom kn_sock.network.arp import get_local_network_info\n\ndef detect_virtual_machines():\n    \"\"\"Identify virtual machines on the network.\"\"\"\n    # Auto-detect network\n    info = get_local_network_info()\n    local_ip = info['local_ip']\n\n    if local_ip != \"Unknown\" and '.' in local_ip:\n        ip_parts = local_ip.split('.')\n        network_range = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n    else:\n        network_range = \"192.168.1.0/24\"\n\n    vm_keywords = [\"vmware\", \"virtualbox\", \"qemu\", \"microsoft\", \"xen\", \"oracle\"]\n\n    try:\n        devices = arp_scan(network_range)\n\n        if not devices:\n            print(\"No devices found on network.\")\n            return\n\n        print(\"Virtual Machine Detection\")\n        print(\"=\" * 40)\n\n        vms_found = 0\n        for device in devices:\n            try:\n                vendor_info = mac_lookup(device['mac'], use_api=False)\n                vendor_lower = vendor_info['vendor'].lower()\n\n                is_vm = any(keyword in vendor_lower for keyword in vm_keywords)\n\n                if is_vm:\n                    print(f\"\ud83d\udda5\ufe0f  VM Detected: {device['ip']} ({vendor_info['vendor']})\")\n                    vms_found += 1\n                else:\n                    print(f\"\ud83d\udcbb Physical Device: {device['ip']} ({vendor_info['vendor']})\")\n\n            except Exception as e:\n                print(f\"\u274c Could not analyze {device['ip']}: {e}\")\n\n        print(f\"\\nSummary: Found {vms_found} virtual machines out of {len(devices)} devices.\")\n\n    except Exception as e:\n        if \"Operation not permitted\" in str(e):\n            print(\"\u274c Root privileges required. Run with: sudo python script.py\")\n        else:\n            print(f\"\u274c Scan failed: {e}\")\n\nif __name__ == \"__main__\":\n    detect_virtual_machines()\n</code></pre>"},{"location":"examples/#mac-address-validation-tool","title":"MAC Address Validation Tool","text":"<pre><code>from kn_sock.network.mac_lookup import validate_mac, mac_lookup\n\ndef validate_and_lookup():\n    \"\"\"Validate MAC addresses and lookup vendor information.\"\"\"\n    test_macs = [\n        \"00:1A:2B:3C:4D:5E\",     # Valid colon format\n        \"00-50-56-C0-00-08\",     # Valid hyphen format  \n        \"001A2B3C4D5E\",          # Valid compact format\n        \"00:50:56:c0:00:08\",     # Valid mixed case\n        \"00:1A:2B:3C:4D\",        # Invalid - too short\n        \"invalid-mac-address\"     # Invalid format\n    ]\n\n    print(\"MAC Address Validation and Lookup\")\n    print(\"=\" * 50)\n\n    for mac in test_macs:\n        print(f\"\\nTesting: {mac}\")\n\n        if validate_mac(mac):\n            try:\n                result = mac_lookup(mac, use_api=False)\n                print(f\"  \u2705 Status: Valid\")\n                print(f\"  \ud83c\udfe2 Vendor: {result['vendor']}\")\n                print(f\"  \ud83d\udd16 OUI: {result['oui']}\")\n                print(f\"  \ud83d\udccd Normalized: {result['mac']}\")\n            except Exception as e:\n                print(f\"  \u2705 Status: Valid format\")\n                print(f\"  \u274c Lookup failed: {e}\")\n        else:\n            print(f\"  \u274c Status: Invalid MAC address format\")\n\n        print(\"-\" * 30)\n\nif __name__ == \"__main__\":\n    validate_and_lookup()\n</code></pre>"},{"location":"examples/#batch-processing-with-error-handling","title":"Batch Processing with Error Handling","text":"<pre><code>from kn_sock.network.mac_lookup import batch_mac_lookup\n\ndef batch_lookup_with_errors():\n    \"\"\"Process multiple MAC addresses with error handling.\"\"\"\n    macs = [\n        \"00:1A:2B:3C:4D:5E\",  # Valid\n        \"08:00:27:12:34:56\",  # Valid\n        \"invalid-mac\",        # Invalid\n        \"52:54:00:AB:CD:EF\"   # Valid\n    ]\n\n    results = batch_mac_lookup(macs, use_api=False)\n\n    print(\"Batch MAC Lookup Results\")\n    print(\"=\" * 50)\n\n    for i, result in enumerate(results):\n        mac = macs[i]\n        print(f\"MAC: {mac}\")\n\n        if \"Error\" in result['vendor']:\n            print(f\"  Status: Error - {result['vendor']}\")\n        else:\n            print(f\"  Status: Success\")\n            print(f\"  Vendor: {result['vendor']}\")\n            print(f\"  OUI: {result['oui']}\")\n\n        print(\"-\" * 30)\n\nif __name__ == \"__main__\":\n    batch_lookup_with_errors()\n</code></pre>"},{"location":"examples/#echo-server-and-client","title":"Echo Server and Client","text":"<p>Server: <pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, client_socket):\n    message = data.decode('utf-8')\n    print(f\"Received from {addr}: {message}\")\n    response = f\"Echo: {message}\"\n    client_socket.sendall(response.encode('utf-8'))\n\nstart_tcp_server(8080, echo_handler)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_tcp_message\n\nmessages = [\"Hello\", \"How are you?\", \"Goodbye\"]\nfor message in messages:\n    send_tcp_message(\"localhost\", 8080, message)\n</code></pre></p>"},{"location":"examples/#file-transfer","title":"File Transfer","text":"<p>Server: <pre><code>from kn_sock import start_file_server\nimport os\n\ndef file_received_handler(filename, filepath, addr):\n    file_size = os.path.getsize(filepath)\n    print(f\"File '{filename}' ({file_size} bytes) received from {addr}\")\n\nstart_file_server(8080, \"/tmp/received\", handler=file_received_handler)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_file\n\nsend_file(\"localhost\", 8080, \"/path/to/file.txt\", show_progress=True)\n</code></pre></p>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#chat-application","title":"Chat Application","text":"<p>Server: <pre><code>from kn_sock import start_websocket_server\nimport json\n\nclass ChatServer:\n    def __init__(self):\n        self.rooms = {}  # room_name -&gt; set of clients\n        self.clients = {}  # client_id -&gt; (ws, room, nickname)\n\n    def handle_client(self, ws):\n        client_id = id(ws)\n        try:\n            while ws.open:\n                message = ws.recv()\n                if not message:\n                    break\n\n                data = json.loads(message)\n                self.process_message(client_id, ws, data)\n        finally:\n            self.remove_client(client_id)\n\n    def process_message(self, client_id, ws, data):\n        msg_type = data.get('type')\n\n        if msg_type == 'join':\n            self.join_room(client_id, ws, data.get('room'), data.get('nickname'))\n        elif msg_type == 'message':\n            self.broadcast_message(client_id, data.get('message'))\n\n    def join_room(self, client_id, ws, room, nickname):\n        if room not in self.rooms:\n            self.rooms[room] = set()\n\n        self.rooms[room].add(client_id)\n        self.clients[client_id] = (ws, room, nickname)\n\n        # Notify others\n        self.broadcast_to_room(room, {\n            'type': 'user_joined',\n            'nickname': nickname\n        }, exclude_client=client_id)\n\n    def broadcast_message(self, client_id, message):\n        if client_id not in self.clients:\n            return\n\n        ws, room, nickname = self.clients[client_id]\n        self.broadcast_to_room(room, {\n            'type': 'message',\n            'nickname': nickname,\n            'message': message\n        })\n\n    def broadcast_to_room(self, room, data, exclude_client=None):\n        if room not in self.rooms:\n            return\n\n        message = json.dumps(data)\n        for client_id in self.rooms[room]:\n            if client_id != exclude_client and client_id in self.clients:\n                ws, _, _ = self.clients[client_id]\n                try:\n                    ws.send(message)\n                except:\n                    pass\n\n    def remove_client(self, client_id):\n        if client_id in self.clients:\n            ws, room, nickname = self.clients[client_id]\n\n            if room in self.rooms:\n                self.rooms[room].discard(client_id)\n\n            del self.clients[client_id]\n\n            self.broadcast_to_room(room, {\n                'type': 'user_left',\n                'nickname': nickname\n            })\n\nserver = ChatServer()\nstart_websocket_server(\"127.0.0.1\", 8765, server.handle_client)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import connect_websocket\nimport json\nimport threading\n\nclass ChatClient:\n    def __init__(self, host, port, room, nickname):\n        self.host = host\n        self.port = port\n        self.room = room\n        self.nickname = nickname\n        self.ws = None\n        self.running = False\n\n    def connect(self):\n        self.ws = connect_websocket(self.host, self.port)\n\n        join_message = {\n            'type': 'join',\n            'room': self.room,\n            'nickname': self.nickname\n        }\n        self.ws.send(json.dumps(join_message))\n\n    def start(self):\n        self.connect()\n        self.running = True\n\n        # Start receive thread\n        receive_thread = threading.Thread(target=self.receive_messages, daemon=True)\n        receive_thread.start()\n\n        # Main input loop\n        try:\n            while self.running:\n                message = input()\n                if message.lower() == 'quit':\n                    break\n                self.send_message(message)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.stop()\n\n    def send_message(self, message):\n        if self.ws and self.ws.open:\n            data = {'type': 'message', 'message': message}\n            self.ws.send(json.dumps(data))\n\n    def receive_messages(self):\n        while self.running and self.ws and self.ws.open:\n            try:\n                message = self.ws.recv()\n                if not message:\n                    break\n\n                data = json.loads(message)\n                self.handle_message(data)\n            except Exception as e:\n                print(f\"Error receiving message: {e}\")\n                break\n\n    def handle_message(self, data):\n        msg_type = data.get('type')\n\n        if msg_type == 'message':\n            nickname = data.get('nickname')\n            message = data.get('message')\n            print(f\"[{nickname}]: {message}\")\n        elif msg_type == 'user_joined':\n            nickname = data.get('nickname')\n            print(f\"*** {nickname} joined the room ***\")\n        elif msg_type == 'user_left':\n            nickname = data.get('nickname')\n            print(f\"*** {nickname} left the room ***\")\n\n    def stop(self):\n        self.running = False\n        if self.ws:\n            self.ws.close()\n\n# Usage\nclient = ChatClient(\"localhost\", 8765, \"general\", \"alice\")\nclient.start()\n</code></pre></p>"},{"location":"examples/#iot-device-simulator","title":"IoT Device Simulator","text":"<p>Device: <pre><code>from kn_sock import send_json\nimport random\nimport time\n\nclass IoTDevice:\n    def __init__(self, device_id, server_host, server_port):\n        self.device_id = device_id\n        self.server_host = server_host\n        self.server_port = server_port\n\n    def generate_sensor_data(self):\n        return {\n            'device_id': self.device_id,\n            'timestamp': time.time(),\n            'temperature': random.uniform(20, 30),\n            'humidity': random.uniform(40, 80),\n            'pressure': random.uniform(1000, 1020)\n        }\n\n    def start(self, interval=5):\n        print(f\"IoT Device {self.device_id} started\")\n\n        try:\n            while True:\n                data = self.generate_sensor_data()\n                try:\n                    send_json(self.server_host, self.server_port, data)\n                    print(f\"\u2713 Data sent: {data['temperature']:.1f}\u00b0C\")\n                except Exception as e:\n                    print(f\"\u2717 Failed to send data: {e}\")\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"Device stopped\")\n\n# Usage\ndevice = IoTDevice(\"sensor001\", \"localhost\", 8080)\ndevice.start()\n</code></pre></p> <p>Server: <pre><code>from kn_sock import start_json_server\nimport json\nimport time\n\nclass IoTServer:\n    def __init__(self):\n        self.devices = {}\n\n    def handle_device_data(self, data, addr, client_socket):\n        device_id = data.get('device_id')\n        self.devices[device_id] = {\n            'data': data,\n            'last_seen': time.time(),\n            'address': addr\n        }\n\n        # Check for alerts\n        alerts = self.check_alerts(data)\n\n        response = {\n            'status': 'received',\n            'device_id': device_id,\n            'alerts': alerts\n        }\n        client_socket.sendall(json.dumps(response).encode('utf-8'))\n\n        print(f\"\ud83d\udcca Data from {device_id}: {data['temperature']:.1f}\u00b0C\")\n\n    def check_alerts(self, data):\n        alerts = []\n\n        if data['temperature'] &gt; 28:\n            alerts.append(f\"High temperature: {data['temperature']:.1f}\u00b0C\")\n        elif data['temperature'] &lt; 22:\n            alerts.append(f\"Low temperature: {data['temperature']:.1f}\u00b0C\")\n\n        return alerts\n\nserver = IoTServer()\nstart_json_server(8080, server.handle_device_data)\n</code></pre></p>"},{"location":"examples/#secure-file-transfer","title":"Secure File Transfer","text":"<p>Server: <pre><code>from kn_sock import start_ssl_tcp_server\nimport os\n\ndef handle_secure_file_transfer(data, addr, client_socket):\n    filename = data.decode().strip()\n\n    try:\n        with open(filename, 'rb') as f:\n            file_data = f.read()\n\n        # Send file size first\n        size_msg = f\"SIZE:{len(file_data)}\".encode()\n        client_socket.sendall(size_msg)\n\n        # Send file data\n        client_socket.sendall(file_data)\n\n    except FileNotFoundError:\n        error_msg = \"ERROR:File not found\".encode()\n        client_socket.sendall(error_msg)\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure_file_transfer,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_ssl_tcp_message\nimport os\n\ndef request_file(host, port, filename):\n    try:\n        # Request file\n        send_ssl_tcp_message(host, port, filename)\n        print(f\"Requested file: {filename}\")\n    except Exception as e:\n        print(f\"Error requesting file: {e}\")\n\n# Usage\nrequest_file(\"localhost\", 8443, \"document.pdf\")\n</code></pre></p>"},{"location":"examples/#publishsubscribe-messaging-system","title":"Publish/Subscribe Messaging System","text":"<p>This example demonstrates a complete PubSub system with server, publishers, and subscribers.</p> <p>PubSub Server: <pre><code>from kn_sock import start_pubsub_server\nimport threading\n\ndef message_handler(data, client_sock, server):\n    \"\"\"Custom handler to log all PubSub activities.\"\"\"\n    action = data.get(\"action\")\n    topic = data.get(\"topic\", \"unknown\")\n\n    if action == \"subscribe\":\n        print(f\"\ud83d\udcdd Client subscribed to: {topic}\")\n    elif action == \"unsubscribe\":\n        print(f\"\ud83d\udce4 Client unsubscribed from: {topic}\")\n    elif action == \"publish\":\n        message = data.get(\"message\", \"\")\n        print(f\"\ud83d\udce2 Message on '{topic}': {message}\")\n\n# Start PubSub server\nprint(\"\ud83d\ude80 Starting PubSub server on port 8080...\")\nstart_pubsub_server(\n    port=8080,\n    host='0.0.0.0',\n    handler_func=message_handler\n)\n</code></pre></p> <p>Publisher Client: <pre><code>from kn_sock import PubSubClient\nimport json\nimport time\n\ndef publish_news():\n    \"\"\"Publish news messages to different topics.\"\"\"\n    try:\n        client = PubSubClient(\"localhost\", 8080)\n        print(\"\u2705 Publisher connected!\")\n\n        # Publish different types of news\n        news_items = [\n            (\"news/tech\", \"AI breakthrough: New language model released\"),\n            (\"news/sports\", \"Championship finals tonight at 8 PM\"),\n            (\"alerts/system\", \"Server maintenance scheduled for midnight\"),\n            (\"data/sensors\", json.dumps({\n                \"sensor_id\": \"temp_01\", \n                \"temperature\": 23.5, \n                \"unit\": \"celsius\"\n            }))\n        ]\n\n        for topic, message in news_items:\n            print(f\"\ud83d\udce4 Publishing to '{topic}': {message}\")\n            client.publish(topic, message)\n            time.sleep(0.5)  # Small delay between messages\n\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    publish_news()\n</code></pre></p> <p>Subscriber Client: <pre><code>from kn_sock import PubSubClient\nimport threading\nimport time\nimport json\n\ndef create_subscriber(name, topics):\n    \"\"\"Create a subscriber for specific topics.\"\"\"\n\n    def message_listener(client):\n        \"\"\"Listen for messages in a separate thread.\"\"\"\n        while True:\n            try:\n                message = client.recv(timeout=1.0)\n                if message:\n                    topic = message.get(\"topic\")\n                    content = message.get(\"message\")\n                    print(f\"[{name}] \ud83d\udce8 Received on '{topic}': {content}\")\n\n                    # Try to parse JSON data\n                    try:\n                        parsed = json.loads(content)\n                        if isinstance(parsed, dict):\n                            print(f\"[{name}] \ud83d\udcca Data: {parsed}\")\n                    except:\n                        pass  # Not JSON, that's fine\n            except Exception as e:\n                print(f\"[{name}] \u26a0\ufe0f  Error: {e}\")\n                break\n\n    try:\n        # Connect to server\n        client = PubSubClient(\"localhost\", 8080)\n        print(f\"[{name}] \u2705 Connected to PubSub server\")\n\n        # Subscribe to topics\n        for topic in topics:\n            client.subscribe(topic)\n            print(f\"[{name}] \ud83d\udce1 Subscribed to: {topic}\")\n\n        # Start message listener\n        listener_thread = threading.Thread(\n            target=message_listener, \n            args=(client,), \n            daemon=True\n        )\n        listener_thread.start()\n\n        # Keep subscriber running\n        time.sleep(10)  # Run for 10 seconds in demo\n\n        # Unsubscribe\n        for topic in topics:\n            client.unsubscribe(topic)\n\n        client.close()\n        print(f\"[{name}] \ud83d\udd12 Disconnected\")\n\n    except Exception as e:\n        print(f\"[{name}] \u274c Error: {e}\")\n\ndef main():\n    \"\"\"Run multiple subscribers for demo.\"\"\"\n    # Create different subscribers for different topic categories\n    news_subscriber = threading.Thread(\n        target=create_subscriber, \n        args=(\"NEWS_SUB\", [\"news/tech\", \"news/sports\"]),\n        daemon=True\n    )\n\n    system_subscriber = threading.Thread(\n        target=create_subscriber,\n        args=(\"SYS_SUB\", [\"alerts/system\", \"data/sensors\"]),\n        daemon=True\n    )\n\n    # Start subscribers\n    news_subscriber.start()\n    system_subscriber.start()\n\n    # Wait for them to finish\n    news_subscriber.join()\n    system_subscriber.join()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>Complete Working Example:</p> <p>For a complete, ready-to-run example, see: <code>docs/examples/pubsub_example.py</code></p> <pre><code># Run the complete example\npython docs/examples/pubsub_example.py\n</code></pre> <p>This example includes: - PubSub server with custom message handler - Multiple publisher and subscriber clients - JSON message parsing - Proper error handling and cleanup - Detailed logging of all activities</p>"},{"location":"examples/#remote-procedure-call-rpc-system","title":"Remote Procedure Call (RPC) System","text":"<p>This example demonstrates a complete RPC system with server and client.</p> <p>RPC Server: <pre><code>from kn_sock import start_rpc_server\n\nclass MathService:\n    \"\"\"Example RPC service with mathematical operations.\"\"\"\n\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b\n\n    def multiply(self, a, b):\n        return a * b\n\n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return a / b\n\ndef start_math_rpc_server():\n    \"\"\"Start a basic RPC server.\"\"\"\n\n    # Create service instance\n    math_service = MathService()\n\n    # Define additional functions\n    def hello(name):\n        return f\"Hello, {name}!\"\n\n    def get_server_time():\n        import datetime\n        return datetime.datetime.now().isoformat()\n\n    # Register all functions in a flat dictionary\n    register_funcs = {\n        # Math service methods\n        'add': math_service.add,\n        'subtract': math_service.subtract,\n        'multiply': math_service.multiply,\n        'divide': math_service.divide,\n\n        # Standalone functions  \n        'hello': hello,\n        'get_time': get_server_time\n    }\n\n    print(\"\ud83d\ude80 Starting RPC Server on localhost:8080\")\n    print(\"\ud83d\udccb Available RPC methods:\")\n    for method_name in register_funcs.keys():\n        print(f\"  - {method_name}\")\n\n    # Start the RPC server\n    start_rpc_server(\n        port=8080,\n        register_funcs=register_funcs,\n        host='0.0.0.0'\n    )\n\nif __name__ == \"__main__\":\n    start_math_rpc_server()\n</code></pre></p> <p>RPC Client: <pre><code>from kn_sock import RPCClient\n\ndef test_rpc_client():\n    \"\"\"Example RPC client.\"\"\"\n\n    client = None\n    try:\n        # Connect to RPC server\n        client = RPCClient('localhost', 8080)\n        print(\"\u2705 Connected to RPC server\")\n\n        # Call individual functions\n        greeting = client.call('hello', 'Alice')\n        print(f\"Greeting: {greeting}\")\n\n        server_time = client.call('get_time')\n        print(f\"Server time: {server_time}\")\n\n        # Call math functions\n        result = client.call('add', 10, 20)\n        print(f\"10 + 20 = {result}\")\n\n        result = client.call('multiply', 7, 8)\n        print(f\"7 * 8 = {result}\")\n\n        # Handle errors\n        try:\n            result = client.call('divide', 10, 0)\n            print(f\"10 / 0 = {result}\")\n        except Exception as e:\n            print(f\"Division by zero error: {e}\")\n\n        # Call non-existent method\n        try:\n            result = client.call('non_existent_method')\n        except Exception as e:\n            print(f\"Method not found error: {e}\")\n\n    except ConnectionRefusedError:\n        print(\"\u274c Could not connect to RPC server. Is it running?\")\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n    finally:\n        if client is not None:\n            client.close()\n            print(\"\ud83d\udd12 Client connection closed\")\n\nif __name__ == \"__main__\":\n    test_rpc_client()\n</code></pre></p> <p>Complete Working Example:</p> <p>For a complete, ready-to-run example, see: <code>docs/examples/rpc_example.py</code></p> <pre><code># Run the complete example\npython docs/examples/rpc_example.py\n</code></pre> <p>This example includes: - RPC server with multiple services (math, utility functions) - RPC client with comprehensive testing - JSON-RPC protocol over TCP - Error handling for division by zero and method not found - Proper connection management and cleanup</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install kn-sock\n# For video/audio examples:\npip install opencv-python pyaudio numpy\n</code></pre>"},{"location":"examples/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Echo Server: <pre><code># Terminal 1\npython echo_server.py\n\n# Terminal 2\npython echo_client.py\n</code></pre></p> </li> <li> <p>Chat Application: <pre><code># Terminal 1\npython chat_server.py\n\n# Terminal 2\npython chat_client.py localhost general alice\n\n# Terminal 3\npython chat_client.py localhost general bob\n</code></pre></p> </li> <li> <p>IoT System: <pre><code># Terminal 1\npython iot_server.py\n\n# Terminal 2\npython iot_device.py\n</code></pre></p> </li> </ol>"},{"location":"examples/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic setup and usage</li> <li>API Reference - For detailed function documentation</li> <li>CLI Guide - For command-line examples </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to kn-sock! This guide will help you get up and running with the library quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting-started/#install-kn-sock","title":"Install kn-sock","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Check the API Reference for detailed function documentation</li> <li>Look at the examples for working code samples</li> <li>Visit the GitHub repository for issues and discussions </li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide provides solutions to common issues you may encounter while using kn-sock.</p>"},{"location":"troubleshooting/#general-issues","title":"General Issues","text":""},{"location":"troubleshooting/#port-conflicts","title":"Port Conflicts","text":"<p>Error: <code>OSError: [Errno 98] Address already in use</code></p> <p>Cause: The port is already used by another process.</p> <p>Solutions: 1. Use a different port number:    <pre><code>start_tcp_server(8081, handler)  # Instead of 8080\n</code></pre></p> <ol> <li> <p>Find and stop the process using the port:    <pre><code># Find the process\nlsof -i :8080\n# or\nnetstat -tuln | grep 8080\n\n# Kill the process (replace PID with actual process ID)\nsudo kill &lt;PID&gt;\n</code></pre></p> </li> <li> <p>Wait for the port to be released (usually takes a few seconds after stopping a server).</p> </li> </ol>"},{"location":"troubleshooting/#permission-issues","title":"Permission Issues","text":"<p>Error: <code>PermissionError: [Errno 13] Permission denied</code></p> <p>Cause: Insufficient permissions to bind to the port.</p> <p>Solutions: 1. Use a port number above 1024 (ports below 1024 require root privileges):    <pre><code>start_tcp_server(8080, handler)  # Instead of 80\n</code></pre></p> <ol> <li>Run with appropriate permissions (not recommended for production):    <pre><code>sudo python your_script.py\n</code></pre></li> </ol>"},{"location":"troubleshooting/#network-connectivity","title":"Network Connectivity","text":"<p>Error: <code>ConnectionRefusedError</code> or <code>TimeoutError</code></p> <p>Cause: Server not running, wrong address/port, or network issues.</p> <p>Solutions: 1. Verify server is running:    <pre><code># Check if server is actually listening\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nresult = sock.connect_ex(('localhost', 8080))\nif result == 0:\n    print(\"Port is open\")\nelse:\n    print(\"Port is closed\")\nsock.close()\n</code></pre></p> <ol> <li> <p>Check firewall settings:    <pre><code># Temporarily disable firewall for testing\nsudo ufw disable  # Ubuntu/Debian\nsudo systemctl stop firewalld  # CentOS/RHEL\n</code></pre></p> </li> <li> <p>Use correct host/port:    <pre><code># Make sure host and port match between client and server\nsend_tcp_message(\"localhost\", 8080, \"Hello\")  # Not 127.0.0.1:8081\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#tcpudp-issues","title":"TCP/UDP Issues","text":""},{"location":"troubleshooting/#connection-timeout","title":"Connection Timeout","text":"<p>Error: <code>ConnectionTimeoutError</code></p> <p>Cause: Network latency or server overload.</p> <p>Solutions: 1. Increase timeout:    <pre><code>import socket\nsocket.setdefaulttimeout(30)  # 30 seconds\n</code></pre></p> <ol> <li>Implement retry logic:    <pre><code>from kn_sock.decorators import retry\n\n@retry(retries=3, delay=1.0)\ndef send_with_retry(host, port, message):\n    send_tcp_message(host, port, message)\n</code></pre></li> </ol>"},{"location":"troubleshooting/#data-corruption","title":"Data Corruption","text":"<p>Error: Unexpected data received</p> <p>Cause: Network issues or encoding problems.</p> <p>Solutions: 1. Use proper encoding:    <pre><code># Server\ndef handler(data, addr, client_socket):\n    message = data.decode('utf-8')  # Specify encoding\n    print(f\"Received: {message}\")\n\n# Client\nsend_tcp_message(\"localhost\", 8080, \"Hello\".encode('utf-8'))\n</code></pre></p> <ol> <li>Implement data validation:    <pre><code>def validate_data(data):\n    try:\n        decoded = data.decode('utf-8')\n        return decoded\n    except UnicodeDecodeError:\n        print(\"Invalid data received\")\n        return None\n</code></pre></li> </ol>"},{"location":"troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":""},{"location":"troubleshooting/#certificate-verification-failed","title":"Certificate Verification Failed","text":"<p>Error: <code>ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]</code></p> <p>Cause: Invalid, missing, or self-signed certificates.</p> <p>Solutions: 1. For testing, disable verification:    <pre><code>send_ssl_tcp_message(\"localhost\", 8443, \"Hello\", verify=False)\n</code></pre></p> <ol> <li> <p>Provide correct certificates:    <pre><code>send_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello\",\n    cafile=\"ca.crt\",\n    certfile=\"client.crt\",\n    keyfile=\"client.key\"\n)\n</code></pre></p> </li> <li> <p>Generate proper certificates:    <pre><code># Generate self-signed certificate for testing\nopenssl req -new -x509 -keyout server.key -out server.crt -days 365 -nodes\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#certificate-file-not-found","title":"Certificate File Not Found","text":"<p>Error: <code>FileNotFoundError: [Errno 2] No such file or directory</code></p> <p>Cause: Certificate files don't exist or wrong path.</p> <p>Solutions: 1. Check file paths:    <pre><code>import os\ncertfile = \"server.crt\"\nif not os.path.exists(certfile):\n    print(f\"Certificate file {certfile} not found\")\n</code></pre></p> <ol> <li>Use absolute paths:    <pre><code>certfile = \"/path/to/server.crt\"\nkeyfile = \"/path/to/server.key\"\n</code></pre></li> </ol>"},{"location":"troubleshooting/#file-transfer-issues","title":"File Transfer Issues","text":""},{"location":"troubleshooting/#file-not-found","title":"File Not Found","text":"<p>Error: <code>FileNotFoundError: [Errno 2] No such file or directory</code></p> <p>Cause: File doesn't exist or wrong path.</p> <p>Solutions: 1. Check file existence:    <pre><code>import os\nif os.path.exists(filepath):\n    send_file(\"localhost\", 8080, filepath)\nelse:\n    print(f\"File {filepath} not found\")\n</code></pre></p> <ol> <li>Use absolute paths:    <pre><code>filepath = os.path.abspath(\"file.txt\")\nsend_file(\"localhost\", 8080, filepath)\n</code></pre></li> </ol>"},{"location":"troubleshooting/#incomplete-file-transfer","title":"Incomplete File Transfer","text":"<p>Error: File received but corrupted or incomplete</p> <p>Cause: Network interruption or insufficient disk space.</p> <p>Solutions: 1. Check disk space:    <pre><code>import shutil\ntotal, used, free = shutil.disk_usage(\"/path/to/save/directory\")\nprint(f\"Free space: {free // (1024**3)} GB\")\n</code></pre></p> <ol> <li> <p>Implement retry logic:    <pre><code>@retry(retries=3, delay=2.0)\ndef send_file_with_retry(host, port, filepath):\n    send_file(host, port, filepath)\n</code></pre></p> </li> <li> <p>Verify file integrity:    <pre><code>import hashlib\n\ndef get_file_hash(filepath):\n    with open(filepath, 'rb') as f:\n        return hashlib.md5(f.read()).hexdigest()\n\n# Before sending\noriginal_hash = get_file_hash(filepath)\n\n# After receiving, verify hash matches\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#videoaudio-issues","title":"Video/Audio Issues","text":""},{"location":"troubleshooting/#pyaudio-errors","title":"PyAudio Errors","text":"<p>Error: <code>OSError: [Errno -9996] Invalid input device</code></p> <p>Cause: Audio device not available or misconfigured.</p> <p>Solutions: 1. Install audio drivers:    <pre><code># Ubuntu/Debian\nsudo apt-get install portaudio19-dev\n\n# Arch Linux\nsudo pacman -S pulseaudio pulseaudio-alsa\n\n# macOS\nbrew install portaudio\n</code></pre></p> <ol> <li> <p>Set audio environment variables:    <pre><code>export PULSE_SERVER=unix:/tmp/pulse-socket\nexport ALSA_PCM_CARD=0\n</code></pre></p> </li> <li> <p>Use audio-only client:    <pre><code>python examples/video_chat_client_no_audio.py 127.0.0.1 myroom alice\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#opencv-camera-issues","title":"OpenCV Camera Issues","text":"<p>Error: <code>cv2.error: OpenCV(4.x.x) /path/to/cap.cpp: error: (-215:Assertion failed)</code></p> <p>Cause: Camera not available or in use.</p> <p>Solutions: 1. Check camera permissions:    <pre><code># Linux\nls -l /dev/video*\nsudo usermod -a -G video $USER\n</code></pre></p> <ol> <li> <p>Test camera separately:    <pre><code>import cv2\ncap = cv2.VideoCapture(0)\nif cap.isOpened():\n    print(\"Camera is working\")\n    cap.release()\nelse:\n    print(\"Camera not available\")\n</code></pre></p> </li> <li> <p>Try different camera indices:    <pre><code># Try different camera numbers\nfor i in range(5):\n    cap = cv2.VideoCapture(i)\n    if cap.isOpened():\n        print(f\"Camera {i} is available\")\n        cap.release()\n        break\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#display-issues","title":"Display Issues","text":"<p>Error: <code>cv2.error: OpenCV(4.x.x) /path/to/window.cpp: error: (-215:Assertion failed)</code></p> <p>Cause: Display backend issues.</p> <p>Solutions: 1. Set display backend:    <pre><code>export QT_QPA_PLATFORM=xcb\nexport DISPLAY=:0\n</code></pre></p> <ol> <li>Use headless mode:    <pre><code>import os\nos.environ['OPENCV_VIDEOIO_PRIORITY_MSMF'] = '0'\n</code></pre></li> </ol>"},{"location":"troubleshooting/#json-communication-issues","title":"JSON Communication Issues","text":""},{"location":"troubleshooting/#invalid-json","title":"Invalid JSON","text":"<p>Error: <code>InvalidJSONError</code> or <code>json.JSONDecodeError</code></p> <p>Cause: Malformed JSON data.</p> <p>Solutions: 1. Validate JSON before sending:    <pre><code>import json\n\ndef send_valid_json(host, port, data):\n    try:\n        json.dumps(data)  # Validate JSON\n        send_json(host, port, data)\n    except TypeError as e:\n        print(f\"Invalid JSON data: {e}\")\n</code></pre></p> <ol> <li>Use JSON decorator:    <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, client_socket):\n    # data is guaranteed to be valid JSON\n    pass\n</code></pre></li> </ol>"},{"location":"troubleshooting/#encoding-issues","title":"Encoding Issues","text":"<p>Error: Unicode encoding/decoding errors</p> <p>Cause: Character encoding mismatches.</p> <p>Solutions: 1. Use UTF-8 encoding:    <pre><code># Server\ndef handler(data, addr, client_socket):\n    try:\n        message = data.decode('utf-8')\n        json_data = json.loads(message)\n    except UnicodeDecodeError:\n        print(\"Invalid encoding\")\n</code></pre></p> <ol> <li>Handle encoding explicitly:    <pre><code># Client\njson_str = json.dumps(data, ensure_ascii=False)\nsend_tcp_message(host, port, json_str.encode('utf-8'))\n</code></pre></li> </ol>"},{"location":"troubleshooting/#websocket-issues","title":"WebSocket Issues","text":""},{"location":"troubleshooting/#connection-failed","title":"Connection Failed","text":"<p>Error: <code>WebSocket connection failed</code></p> <p>Cause: Server not running or protocol mismatch.</p> <p>Solutions: 1. Verify server is running:    <pre><code># Test basic connectivity first\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nresult = sock.connect_ex(('localhost', 8765))\nsock.close()\n</code></pre></p> <ol> <li>Check WebSocket handshake:    <pre><code># Use proper WebSocket client\nws = connect_websocket(\"localhost\", 8765)\nif ws.open:\n    print(\"WebSocket connected successfully\")\n</code></pre></li> </ol>"},{"location":"troubleshooting/#message-format-issues","title":"Message Format Issues","text":"<p>Error: WebSocket messages not received</p> <p>Cause: Incorrect message format or protocol.</p> <p>Solutions: 1. Use proper WebSocket methods:    <pre><code># Send text message\nws.send(\"Hello WebSocket\")\n\n# Receive message\nmessage = ws.recv()\n</code></pre></p> <ol> <li>Handle connection state:    <pre><code>if ws.open:\n    ws.send(message)\nelse:\n    print(\"WebSocket not connected\")\n</code></pre></li> </ol>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Cause: Large buffers or memory leaks.</p> <p>Solutions: 1. Use smaller buffers:    <pre><code># For file transfer\nsend_file(host, port, filepath, chunk_size=1024)\n</code></pre></p> <ol> <li>Implement streaming:    <pre><code>from kn_sock.utils import chunked_file_reader\n\nfor chunk in chunked_file_reader(filepath, chunk_size=4096):\n    # Process chunk\n    pass\n</code></pre></li> </ol>"},{"location":"troubleshooting/#slow-performance","title":"Slow Performance","text":"<p>Cause: Network latency or inefficient code.</p> <p>Solutions: 1. Use connection pooling:    <pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool('localhost', 8080, max_size=5)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello\")\n</code></pre></p> <ol> <li>Use async operations:    <pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello\"))\n</code></pre></li> </ol>"},{"location":"troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Or use kn-sock CLI with verbose flag\n# kn-sock --verbose run-tcp-server 8080\n</code></pre>"},{"location":"troubleshooting/#test-network-connectivity","title":"Test Network Connectivity","text":"<pre><code>def test_connectivity(host, port):\n    import socket\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(5)\n        result = sock.connect_ex((host, port))\n        sock.close()\n        return result == 0\n    except Exception as e:\n        print(f\"Connection test failed: {e}\")\n        return False\n</code></pre>"},{"location":"troubleshooting/#monitor-system-resources","title":"Monitor System Resources","text":"<pre><code># Monitor network connections\nnetstat -tuln\n\n# Monitor process resources\ntop -p $(pgrep -f \"python.*kn-sock\")\n\n# Monitor disk usage\ndf -h\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#check-documentation","title":"Check Documentation","text":"<ul> <li>Review the API Reference for function details</li> <li>Check Getting Started for basic usage</li> <li>Look at examples for working code samples</li> </ul>"},{"location":"troubleshooting/#report-issues","title":"Report Issues","text":"<p>When reporting issues, include:</p> <ol> <li>Environment details:</li> <li>Operating system and version</li> <li>Python version</li> <li> <p>kn-sock version</p> </li> <li> <p>Error details:</p> </li> <li>Complete error message and traceback</li> <li>Steps to reproduce the issue</li> <li> <p>Expected vs actual behavior</p> </li> <li> <p>Code example:</p> </li> <li>Minimal code that reproduces the issue</li> <li> <p>Any relevant configuration</p> </li> <li> <p>System information:</p> </li> <li>Network configuration</li> <li>Firewall settings</li> <li>Available ports</li> </ol>"},{"location":"troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Likely Cause Solution <code>Address already in use</code> Port conflict Use different port or kill existing process <code>Connection refused</code> Server not running Start server first <code>Permission denied</code> Insufficient privileges Use port &gt; 1024 or run with sudo <code>Timeout</code> Network issues Increase timeout or check connectivity <code>Invalid JSON</code> Malformed data Validate JSON before sending <code>SSL certificate failed</code> Certificate issues Use correct certs or disable verification <code>File not found</code> Wrong path Check file existence and path <code>Camera not available</code> Hardware/permission issues Check camera permissions and availability"},{"location":"troubleshooting/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic setup and usage</li> <li>API Reference - For detailed function documentation</li> <li>CLI Guide - For command-line troubleshooting </li> </ul>"},{"location":"advanced/http/","title":"HTTP/HTTPS","text":"<p>kn-sock provides simple HTTP and HTTPS client helpers and a basic HTTP server for serving static files and handling API routes.</p>"},{"location":"advanced/http/#http-client","title":"HTTP Client","text":""},{"location":"advanced/http/#basic-http-get","title":"Basic HTTP GET","text":"<pre><code>from kn_sock import http_get\n\n# Simple GET request\nresponse = http_get(\"example.com\", 80, \"/\")\nprint(response)\n\n# GET with custom headers\nheaders = {\n    \"User-Agent\": \"kn-sock/1.0\",\n    \"Accept\": \"application/json\"\n}\nresponse = http_get(\"api.example.com\", 80, \"/users\", headers=headers)\nprint(response)\n</code></pre>"},{"location":"advanced/http/#http-post","title":"HTTP POST","text":"<pre><code>from kn_sock import http_post\n\n# POST with form data\ndata = \"name=John&amp;email=john@example.com\"\nresponse = http_post(\"api.example.com\", 80, \"/users\", data=data)\n\n# POST with JSON data\nimport json\njson_data = json.dumps({\"name\": \"John\", \"email\": \"john@example.com\"})\nheaders = {\"Content-Type\": \"application/json\"}\nresponse = http_post(\"api.example.com\", 80, \"/users\", data=json_data, headers=headers)\n</code></pre>"},{"location":"advanced/http/#https-client","title":"HTTPS Client","text":""},{"location":"advanced/http/#https-get","title":"HTTPS GET","text":"<pre><code>from kn_sock import https_get\n\n# Simple HTTPS GET\nresponse = https_get(\"example.com\", 443, \"/\")\nprint(response)\n\n# HTTPS GET with certificate verification\nresponse = https_get(\"api.example.com\", 443, \"/secure\", cafile=\"ca.crt\")\n</code></pre>"},{"location":"advanced/http/#https-post","title":"HTTPS POST","text":"<pre><code>from kn_sock import https_post\n\n# HTTPS POST with JSON\nimport json\ndata = json.dumps({\"action\": \"login\", \"username\": \"user\", \"password\": \"pass\"})\nheaders = {\"Content-Type\": \"application/json\"}\n\nresponse = https_post(\"api.example.com\", 443, \"/auth\", data=data, headers=headers)\nprint(response)\n</code></pre>"},{"location":"advanced/http/#http-server","title":"HTTP Server","text":""},{"location":"advanced/http/#basic-http-server","title":"Basic HTTP Server","text":"<pre><code>from kn_sock import start_http_server\n\n# Start server serving static files\nstart_http_server(\"127.0.0.1\", 8080, static_dir=\"/path/to/static/files\")\n</code></pre>"},{"location":"advanced/http/#http-server-with-custom-routes","title":"HTTP Server with Custom Routes","text":"<pre><code>from kn_sock import start_http_server\nimport json\n\ndef hello_handler(request, client_socket):\n    \"\"\"Handle /hello route\"\"\"\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nHello\"\n    client_socket.sendall(response.encode())\n\ndef api_handler(request, client_socket):\n    \"\"\"Handle /api route\"\"\"\n    data = {\"message\": \"Hello from API\", \"status\": \"success\"}\n    response_json = json.dumps(data)\n\n    response = f\"\"\"HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: {len(response_json)}\n\n{response_json}\"\"\"\n    client_socket.sendall(response.encode())\n\ndef echo_handler(request, client_socket):\n    \"\"\"Handle POST /echo route\"\"\"\n    # Extract body from request\n    body = request['raw'].decode('utf-8').split('\\r\\n\\r\\n', 1)[-1]\n\n    response = f\"\"\"HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: {len(body)}\n\n{body}\"\"\"\n    client_socket.sendall(response.encode())\n\n# Define routes\nroutes = {\n    (\"GET\", \"/hello\"): hello_handler,\n    (\"GET\", \"/api\"): api_handler,\n    (\"POST\", \"/echo\"): echo_handler,\n}\n\n# Start server with routes\nstart_http_server(\"127.0.0.1\", 8080, static_dir=\"static\", routes=routes)\n</code></pre>"},{"location":"advanced/http/#limitations","title":"Limitations","text":""},{"location":"advanced/http/#current-limitations","title":"Current Limitations","text":"<ul> <li>No support for redirects</li> <li>No support for chunked encoding</li> <li>No support for cookies</li> <li>No support for HTTP/2</li> <li>Limited header parsing</li> <li>No support for streaming responses</li> </ul>"},{"location":"advanced/http/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For underlying transport</li> <li>Secure TCP - For HTTPS functionality</li> <li>API Reference - For complete function documentation </li> </ul>"},{"location":"advanced/live-streaming/","title":"Live Streaming","text":"<p>kn-sock provides advanced live video and audio streaming capabilities with multi-video support, adaptive bitrate, and smooth playback.</p>"},{"location":"advanced/live-streaming/#overview","title":"Overview","text":"<p>Live streaming features in kn-sock: - Multi-Video Support: Server can offer multiple videos; clients select which to play - Adaptive Bitrate: Server adjusts video quality per client based on buffer feedback - Jitter Buffer: Client-side buffering for smooth video/audio playback - Robust Audio Protocol: Audio stream uses magic numbers and timestamps for resynchronization - Real-time Feedback: Client sends buffer status to server for quality adjustment</p>"},{"location":"advanced/live-streaming/#basic-live-streaming","title":"Basic Live Streaming","text":""},{"location":"advanced/live-streaming/#live-stream-server","title":"Live Stream Server","text":"<pre><code>from kn_sock import start_live_stream\n\n# Start a live stream server with multiple videos\nstart_live_stream(9000, [\"video1.mp4\", \"video2.mp4\", \"video3.mp4\"])\n\n# Or with a single video\nstart_live_stream(9000, [\"video.mp4\"])\n</code></pre>"},{"location":"advanced/live-streaming/#live-stream-client","title":"Live Stream Client","text":"<pre><code>from kn_sock import connect_to_live_server\n\n# Connect to a live stream server\nconnect_to_live_server(\"192.168.1.10\", 9000)\n</code></pre>"},{"location":"advanced/live-streaming/#advanced-usage","title":"Advanced Usage","text":""},{"location":"advanced/live-streaming/#custom-server-configuration","title":"Custom Server Configuration","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer\n\n# Server with custom configuration\nserver = LiveStreamServer(\n    video_paths=[\"video1.mp4\", \"video2.mp4\"],\n    host='0.0.0.0',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010\n)\nserver.start()\n</code></pre>"},{"location":"advanced/live-streaming/#custom-client-configuration","title":"Custom Client Configuration","text":"<pre><code>from kn_sock.live_stream import LiveStreamClient\n\n# Client with custom buffer settings\nclient = LiveStreamClient(\n    host='127.0.0.1',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010,\n    video_buffer_ms=200,  # 200ms video buffer\n    audio_buffer_ms=100,  # 100ms audio buffer\n    video_fps=30\n)\nclient.start()\n</code></pre>"},{"location":"advanced/live-streaming/#configuration-options","title":"Configuration Options","text":""},{"location":"advanced/live-streaming/#server-configuration","title":"Server Configuration","text":"Parameter Description Default <code>video_paths</code> List of video file paths Required <code>host</code> Host to bind '0.0.0.0' <code>video_port</code> Port for video stream 8000 <code>audio_port</code> Port for audio stream 8001 <code>control_port</code> Port for control messages video_port + 10"},{"location":"advanced/live-streaming/#client-configuration","title":"Client Configuration","text":"Parameter Description Default <code>host</code> Server host '127.0.0.1' <code>video_port</code> Video stream port 8000 <code>audio_port</code> Audio stream port 8001 <code>control_port</code> Control port video_port + 10 <code>video_buffer_ms</code> Video buffer size (ms) 200 <code>audio_buffer_ms</code> Audio buffer size (ms) 200 <code>video_fps</code> Target video FPS 30"},{"location":"advanced/live-streaming/#related-topics","title":"Related Topics","text":"<ul> <li>Video Chat - For real-time video communication</li> <li>TCP Protocol - For underlying transport</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"advanced/pubsub/","title":"Publish/Subscribe Messaging","text":"<p>kn-sock provides a simple and efficient publish/subscribe (pub/sub) messaging system for decoupled communication between applications.</p>"},{"location":"advanced/pubsub/#overview","title":"Overview","text":"<p>Pub/Sub features in kn-sock: - Topic-based messaging: Organize messages by topics - Multiple subscribers: Many clients can subscribe to the same topic - Threading support: Multi-threaded server for concurrent connections - Custom message handlers: Process messages with custom logic - JSON-based protocol: Simple JSON message format - TCP-based: Reliable TCP connections for message delivery</p>"},{"location":"advanced/pubsub/#basic-pubsub-usage","title":"Basic Pub/Sub Usage","text":""},{"location":"advanced/pubsub/#starting-a-pubsub-server","title":"Starting a PubSub Server","text":"<pre><code>from kn_sock import start_pubsub_server\nimport threading\n\ndef custom_handler(data, client_sock, server):\n    \"\"\"\n    Custom handler for pubsub messages.\n\n    Args:\n        data (dict): The parsed message data from client\n        client_sock (socket.socket): The client socket\n        server (PubSubServer): The pubsub server instance\n    \"\"\"\n    action = data.get(\"action\")\n    topic = data.get(\"topic\", \"unknown\")\n\n    if action == \"subscribe\":\n        print(f\"\ud83d\udcdd Client subscribed to topic: {topic}\")\n    elif action == \"unsubscribe\":\n        print(f\"\ud83d\udce4 Client unsubscribed from topic: {topic}\")\n    elif action == \"publish\":\n        message = data.get(\"message\", \"\")\n        print(f\"\ud83d\udce2 Message published to '{topic}': {message}\")\n\n# Start the PubSub server\ndef start_server():\n    print(\"\ud83d\ude80 Starting PubSub server on port 8080...\")\n    start_pubsub_server(\n        port=8080,\n        host='0.0.0.0',\n        handler_func=custom_handler  # Optional custom handler\n    )\n\n# Start server in background thread (optional)\nserver_thread = threading.Thread(target=start_server, daemon=True)\nserver_thread.start()\n\nprint(\"\u2705 PubSub server started!\")\nprint(\"\ud83d\udd04 Server is running...\")\n</code></pre>"},{"location":"advanced/pubsub/#publishing-messages","title":"Publishing Messages","text":"<pre><code>from kn_sock import PubSubClient\n\ndef publisher_example():\n    \"\"\"Example of publishing messages to topics.\"\"\"\n\n    try:\n        # Connect to the PubSub server\n        client = PubSubClient(\"localhost\", 8080)\n        print(\"\u2705 Connected to PubSub server\")\n\n        # Publish messages to different topics\n        client.publish(\"news/technology\", \"New AI breakthrough announced!\")\n        client.publish(\"news/sports\", \"Championship game tonight\")\n        client.publish(\"alerts/system\", \"Server maintenance scheduled\")\n\n        # Publish JSON data\n        import json\n        data = {\n            \"event\": \"order_created\",\n            \"order_id\": \"ORD-789\",\n            \"amount\": 99.99,\n            \"customer\": \"john@example.com\"\n        }\n        client.publish(\"orders/created\", json.dumps(data))\n\n        print(\"\ud83d\udce4 All messages published successfully!\")\n\n    except Exception as e:\n        print(f\"\u274c Error publishing messages: {e}\")\n    finally:\n        client.close()\n\n# Run the publisher\npublisher_example()\n</code></pre>"},{"location":"advanced/pubsub/#subscribing-to-messages","title":"Subscribing to Messages","text":"<pre><code>from kn_sock import PubSubClient\nimport threading\nimport time\n\ndef subscriber_example():\n    \"\"\"Example of subscribing to topics and receiving messages.\"\"\"\n\n    def handle_messages(client):\n        \"\"\"Handle incoming messages in a separate thread.\"\"\"\n        try:\n            while True:\n                message = client.recv(timeout=1.0)\n                if message:\n                    topic = message.get(\"topic\")\n                    content = message.get(\"message\")\n                    print(f\"\ud83d\udce8 Received on '{topic}': {content}\")\n        except Exception as e:\n            print(f\"Message handler error: {e}\")\n\n    try:\n        # Connect to the PubSub server\n        client = PubSubClient(\"localhost\", 8080)\n        print(\"\u2705 Connected to PubSub server\")\n\n        # Subscribe to topics\n        client.subscribe(\"news/technology\")\n        client.subscribe(\"news/sports\") \n        client.subscribe(\"alerts/system\")\n        client.subscribe(\"orders/created\")\n\n        print(\"\ud83d\udce1 Subscribed to topics, listening for messages...\")\n\n        # Start message handler in background thread\n        listener_thread = threading.Thread(target=handle_messages, args=(client,), daemon=True)\n        listener_thread.start()\n\n        # Keep the subscriber running\n        try:\n            while True:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            print(\"\\n\ud83d\uded1 Shutting down subscriber...\")\n\n    except Exception as e:\n        print(f\"\u274c Subscriber error: {e}\")\n    finally:\n        client.close()\n\n# Run the subscriber\nsubscriber_example()\n</code></pre>"},{"location":"advanced/pubsub/#see-also","title":"See Also","text":"<ul> <li>TCP Protocol - For reliable message transport</li> <li>JSON Communication - For structured message data  </li> <li>WebSocket Protocol - For real-time communication</li> <li>RPC - For remote procedure calls</li> <li>Examples - Complete PubSub application examples</li> </ul>"},{"location":"advanced/rpc/","title":"Remote Procedure Calls (RPC)","text":"<p>kn-sock provides a simple and efficient JSON-RPC system that allows you to call functions on remote servers as if they were local.</p>"},{"location":"advanced/rpc/#overview","title":"Overview","text":"<p>RPC features in kn-sock: - JSON-RPC protocol: Standard JSON-RPC over TCP - Synchronous calls: Simple request-response pattern - Error handling: Automatic exception propagation across network - Multi-threaded server: Handles multiple clients concurrently - Simple API: Easy-to-use function-based interface</p>"},{"location":"advanced/rpc/#basic-rpc-usage","title":"Basic RPC Usage","text":""},{"location":"advanced/rpc/#rpc-server","title":"RPC Server","text":"<pre><code>from kn_sock import start_rpc_server\n\nclass MathService:\n    \"\"\"Example RPC service with mathematical operations.\"\"\"\n\n    def add(self, a, b):\n        \"\"\"Add two numbers.\"\"\"\n        return a + b\n\n    def subtract(self, a, b):\n        \"\"\"Subtract two numbers.\"\"\"\n        return a - b\n\n    def multiply(self, a, b):\n        \"\"\"Multiply two numbers.\"\"\"\n        return a * b\n\n    def divide(self, a, b):\n        \"\"\"Divide two numbers.\"\"\"\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return a / b\n\n    def factorial(self, n):\n        \"\"\"Calculate factorial of a number.\"\"\"\n        if n &lt; 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        if n == 0 or n == 1:\n            return 1\n\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\ndef start_math_rpc_server():\n    \"\"\"Start a basic RPC server.\"\"\"\n\n    # Create service instance\n    math_service = MathService()\n\n    # Define additional functions\n    def hello(name):\n        return f\"Hello, {name}!\"\n\n    def get_server_time():\n        import datetime\n        return datetime.datetime.now().isoformat()\n\n    # Register all functions in a flat dictionary\n    register_funcs = {\n        # Math service methods\n        'add': math_service.add,\n        'subtract': math_service.subtract,\n        'multiply': math_service.multiply,\n        'divide': math_service.divide,\n        'factorial': math_service.factorial,\n\n        # Standalone functions  \n        'hello': hello,\n        'get_time': get_server_time\n    }\n\n    print(\"\ud83d\ude80 Starting RPC Server on localhost:8080\")\n    print(\"\ud83d\udccb Available RPC methods:\")\n    for method_name in register_funcs.keys():\n        print(f\"  - {method_name}\")\n\n    # Start the RPC server\n    start_rpc_server(\n        port=8080,\n        register_funcs=register_funcs,\n        host='0.0.0.0'\n    )\n\nif __name__ == \"__main__\":\n    start_math_rpc_server()\n</code></pre>"},{"location":"advanced/rpc/#rpc-client","title":"RPC Client","text":"<pre><code>from kn_sock import RPCClient\n\ndef test_rpc_client():\n    \"\"\"Example RPC client.\"\"\"\n\n    client = None\n    try:\n        # Connect to RPC server\n        client = RPCClient('localhost', 8080)\n        print(\"\u2705 Connected to RPC server\")\n\n        # Call individual functions\n        greeting = client.call('hello', 'Alice')\n        print(f\"Greeting: {greeting}\")\n\n        server_time = client.call('get_time')\n        print(f\"Server time: {server_time}\")\n\n        # Call math functions\n        result = client.call('add', 10, 20)\n        print(f\"10 + 20 = {result}\")\n\n        result = client.call('multiply', 7, 8)\n        print(f\"7 * 8 = {result}\")\n\n        result = client.call('factorial', 5)\n        print(f\"5! = {result}\")\n\n        # Handle errors\n        try:\n            result = client.call('divide', 10, 0)\n            print(f\"10 / 0 = {result}\")\n        except Exception as e:\n            print(f\"Division by zero error: {e}\")\n\n        # Call non-existent method\n        try:\n            result = client.call('non_existent_method')\n        except Exception as e:\n            print(f\"Method not found error: {e}\")\n\n    except ConnectionRefusedError:\n        print(\"\u274c Could not connect to RPC server. Is it running?\")\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n    finally:\n        if client is not None:\n            client.close()\n            print(\"\ud83d\udd12 Client connection closed\")\n\nif __name__ == \"__main__\":\n    test_rpc_client()\n</code></pre>"},{"location":"advanced/rpc/#multi-service-rpc-example","title":"Multi-Service RPC Example","text":"<p>kn-sock RPC supports registering multiple services and utility functions on a single server. Here's a comprehensive example:</p>"},{"location":"advanced/rpc/#complete-rpc-server-with-multiple-services","title":"Complete RPC Server with Multiple Services","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete RPC Example - Server and Client\n\"\"\"\n\nfrom kn_sock import start_rpc_server, RPCClient\nimport threading\nimport time\n\n# Service classes\nclass CalculatorService:\n    \"\"\"Calculator service with basic math operations.\"\"\"\n\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b\n\n    def multiply(self, a, b):\n        return a * b\n\n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return a / b\n\nclass UserService:\n    \"\"\"User service with user management operations.\"\"\"\n\n    def __init__(self):\n        self.users = {}\n        self.next_id = 1\n\n    def create_user(self, name, email):\n        user_id = self.next_id\n        self.next_id += 1\n        self.users[user_id] = {\n            'id': user_id,\n            'name': name,\n            'email': email,\n            'created_at': time.time()\n        }\n        return self.users[user_id]\n\n    def get_user(self, user_id):\n        return self.users.get(user_id)\n\n    def list_users(self):\n        return list(self.users.values())\n\n    def delete_user(self, user_id):\n        return self.users.pop(user_id, None)\n\ndef start_demo_rpc_server():\n    \"\"\"Start RPC server with multiple services.\"\"\"\n\n    # Create service instances\n    calc = CalculatorService()\n    user_service = UserService()\n\n    # Utility functions\n    def ping():\n        return \"pong\"\n\n    def get_server_info():\n        import platform\n        return {\n            \"server\": \"kn-sock RPC Demo\",\n            \"python_version\": platform.python_version(),\n            \"platform\": platform.system(),\n            \"timestamp\": time.time()\n        }\n\n    # Register all functions\n    register_funcs = {\n        # Calculator service\n        'calc_add': calc.add,\n        'calc_subtract': calc.subtract,\n        'calc_multiply': calc.multiply,\n        'calc_divide': calc.divide,\n\n        # User service\n        'user_create': user_service.create_user,\n        'user_get': user_service.get_user,\n        'user_list': user_service.list_users,\n        'user_delete': user_service.delete_user,\n\n        # Utility functions\n        'ping': ping,\n        'server_info': get_server_info\n    }\n\n    print(\"\ud83d\ude80 Starting RPC Demo Server on port 8080\")\n    print(\"\ud83d\udccb Available RPC methods:\")\n    for method in sorted(register_funcs.keys()):\n        print(f\"  - {method}\")\n    print()\n\n    # Start server\n    start_rpc_server(\n        port=8080,\n        register_funcs=register_funcs,\n        host='0.0.0.0'\n    )\n\ndef demo_rpc_client():\n    \"\"\"Demo RPC client showing various operations.\"\"\"\n\n    client = None\n    try:\n        client = RPCClient(\"localhost\", 8080)\n        print(\"\u2705 Connected to RPC server\\n\")\n\n        # Test basic functions\n        print(\"\ud83c\udfd3 Testing ping:\")\n        response = client.call(\"ping\")\n        print(f\"  ping() = {response}\\n\")\n\n        # Test server info\n        print(\"\u2139\ufe0f  Getting server info:\")\n        info = client.call(\"server_info\")\n        for key, value in info.items():\n            print(f\"  {key}: {value}\")\n        print()\n\n        # Test calculator\n        print(\"\ud83e\uddee Testing Calculator Service:\")\n        print(f\"  calc_add(15, 7) = {client.call('calc_add', 15, 7)}\")\n        print(f\"  calc_multiply(8, 9) = {client.call('calc_multiply', 8, 9)}\")\n        print(f\"  calc_divide(100, 4) = {client.call('calc_divide', 100, 4)}\")\n        print()\n\n        # Test user service\n        print(\"\ud83d\udc65 Testing User Service:\")\n\n        # Create users\n        user1 = client.call(\"user_create\", \"Alice Smith\", \"alice@example.com\")\n        user2 = client.call(\"user_create\", \"Bob Johnson\", \"bob@example.com\")\n        print(f\"  Created user: {user1}\")\n        print(f\"  Created user: {user2}\")\n\n        # Get user\n        retrieved_user = client.call(\"user_get\", user1['id'])\n        print(f\"  Retrieved user {user1['id']}: {retrieved_user}\")\n\n        # List users\n        all_users = client.call(\"user_list\")\n        print(f\"  All users: {len(all_users)} users\")\n\n        # Delete user\n        deleted_user = client.call(\"user_delete\", user2['id'])\n        print(f\"  Deleted user: {deleted_user}\")\n        print()\n\n        # Test error handling\n        print(\"\u274c Testing Error Handling:\")\n        try:\n            result = client.call(\"calc_divide\", 10, 0)\n        except Exception as e:\n            print(f\"  Division by zero: {e}\")\n\n        try:\n            result = client.call(\"non_existent_method\")\n        except Exception as e:\n            print(f\"  Non-existent method: {e}\")\n\n        print(\"\\n\u2705 All RPC demo operations completed!\")\n\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n    finally:\n        if client is not None:\n            client.close()\n            print(\"\ud83d\udd12 Client disconnected\")\n\ndef main():\n    \"\"\"Run the complete RPC demo.\"\"\"\n    print(\"=\" * 60)\n    print(\"kn-sock RPC Complete Demo\")\n    print(\"=\" * 60)\n\n    # Start server in background\n    server_thread = threading.Thread(target=start_demo_rpc_server, daemon=True)\n    server_thread.start()\n\n    # Wait for server to start\n    time.sleep(2)\n\n    # Run client demo\n    demo_rpc_client()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"advanced/rpc/#message-protocol","title":"Message Protocol","text":"<p>RPC uses JSON-RPC over TCP with newline-delimited messages:</p>"},{"location":"advanced/rpc/#request-format","title":"Request Format","text":"<pre><code>{\n  \"method\": \"function_name\",\n  \"params\": [arg1, arg2, ...],\n  \"kwargs\": {\"key\": \"value\"}\n}\n</code></pre>"},{"location":"advanced/rpc/#response-format-success","title":"Response Format (Success)","text":"<pre><code>{\n  \"result\": \"return_value\"\n}\n</code></pre>"},{"location":"advanced/rpc/#response-format-error","title":"Response Format (Error)","text":"<pre><code>{\n  \"error\": \"error_message\"\n}\n</code></pre>"},{"location":"advanced/rpc/#see-also","title":"See Also","text":"<ul> <li>TCP Protocol - For reliable RPC transport</li> <li>JSON Communication - For structured RPC data</li> <li>PubSub Messaging - For event-driven communication</li> <li>WebSocket Protocol - For real-time RPC</li> <li>Examples - More RPC application examples</li> </ul>"},{"location":"advanced/video-chat/","title":"Video Chat","text":"<p>kn-sock provides real-time multi-client video chat with voice, allowing multiple users to join rooms and communicate with both video and audio in real time.</p>"},{"location":"advanced/video-chat/#overview","title":"Overview","text":"<p>Video chat features in kn-sock: - Multi-client support: Multiple users can join the same room and see/hear each other - Rooms/Channels: Users can join named rooms; only users in the same room see/hear each other - User Nicknames: Each client can set a nickname, which is shared with the server and other clients - Text Chat: Real-time text messaging with chat overlay on video window - Mute/Unmute: Toggle audio on/off with keyboard shortcut - Video On/Off: Toggle video camera on/off with keyboard shortcut - Real-time video and audio: Uses OpenCV for video and PyAudio for audio - Simple API: Easy to start a server or connect as a client</p>"},{"location":"advanced/video-chat/#basic-video-chat","title":"Basic Video Chat","text":""},{"location":"advanced/video-chat/#video-chat-server","title":"Video Chat Server","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\n\nserver = VideoChatServer(host='0.0.0.0', video_port=9000, audio_port=9001, text_port=9002)\nserver.start()\nprint('Video chat server started on ports 9000 (video), 9001 (audio), and 9002 (text).')\n\n# Keep the server running\ntry:\n    while True:\n        pass\nexcept KeyboardInterrupt:\n    print('Server stopped.')\n</code></pre>"},{"location":"advanced/video-chat/#video-chat-client","title":"Video Chat Client","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclient = VideoChatClient(\n    server_ip='127.0.0.1', \n    video_port=9000, \n    audio_port=9001, \n    text_port=9002, \n    room='myroom', \n    nickname='alice'\n)\nclient.start()\nprint('Connected to video chat server in room \"myroom\" as \"alice\".')\n\n# Keep the client running\ntry:\n    while client.running:\n        pass\nexcept KeyboardInterrupt:\n    print('Client stopped.')\n</code></pre>"},{"location":"advanced/video-chat/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"advanced/video-chat/#custom-server-configuration","title":"Custom Server Configuration","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\n\n# Server supports only basic configuration parameters\nserver = VideoChatServer(\n    host='0.0.0.0',\n    video_port=9000,\n    audio_port=9001,\n    text_port=9002\n)\nserver.start()\n\nprint(\"Video chat server started:\")\nprint(f\"  - Video port: {server.video_port}\")  \nprint(f\"  - Audio port: {server.audio_port}\")\nprint(f\"  - Text chat port: {server.text_port}\")\nprint(\"  - Supports multiple rooms\")\nprint(\"  - Users can join with custom nicknames\")\n</code></pre>"},{"location":"advanced/video-chat/#custom-client-configuration","title":"Custom Client Configuration","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\n# Client configuration with available parameters\nclient = VideoChatClient(\n    server_ip='192.168.1.10',\n    video_port=9000,\n    audio_port=9001,\n    text_port=9002,\n    room='conference',\n    nickname='john',\n    enable_audio=True  # Enable/disable audio functionality\n)\nclient.start()\n</code></pre>"},{"location":"advanced/video-chat/#multi-room-setup","title":"Multi-Room Setup","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\nimport threading\n\n# Start multiple servers for different rooms\ndef start_server_for_room(room_name, port_base):\n    server = VideoChatServer(\n        host='0.0.0.0',\n        video_port=port_base,\n        audio_port=port_base + 1, \n        text_port=port_base + 2\n    )\n\n    print(f\"Room '{room_name}' starting on ports {port_base}-{port_base+2}\")\n    server.start()\n\n# Configure different rooms\nrooms = [\n    (\"lobby\", 9000),\n    (\"meeting1\", 9100), \n    (\"meeting2\", 9200)\n]\n\nfor room_name, port_base in rooms:\n    thread = threading.Thread(\n        target=start_server_for_room,\n        args=(room_name, port_base),\n        daemon=True\n    )\n    thread.start()\n</code></pre>"},{"location":"advanced/video-chat/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/video-chat/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"advanced/video-chat/#audio-issues-most-common","title":"Audio Issues (Most Common)","text":"<p>If you encounter PyAudio assertion errors or audio crashes:</p> <ol> <li> <p>Disable audio temporarily: <pre><code>python examples/video_chat_client.py 127.0.0.1 myroom alice --no-audio\n</code></pre></p> </li> <li> <p>Use the no-audio client: <pre><code>python examples/video_chat_client_no_audio.py 127.0.0.1 myroom alice\n</code></pre></p> </li> <li> <p>Test audio separately: <pre><code>python examples/test_audio_only.py\n</code></pre></p> </li> <li> <p>Install audio drivers (Arch Linux): <pre><code>sudo pacman -S pulseaudio pulseaudio-alsa\n</code></pre></p> </li> <li> <p>Set audio environment variables: <pre><code>export PULSE_SERVER=unix:/tmp/pulse-socket\nexport ALSA_PCM_CARD=0\n</code></pre></p> </li> </ol>"},{"location":"advanced/video-chat/#display-issues","title":"Display Issues","text":"<pre><code># Set display backend for OpenCV\nexport QT_QPA_PLATFORM=xcb\n</code></pre>"},{"location":"advanced/video-chat/#camera-issues","title":"Camera Issues","text":"<ul> <li>Make sure your camera is not in use by another application</li> <li>Check camera permissions</li> <li>Try different camera device numbers if you have multiple cameras</li> </ul>"},{"location":"advanced/video-chat/#dependencies","title":"Dependencies","text":"<pre><code># Install required packages\npip install opencv-python pyaudio numpy\n</code></pre> <p>Note: The video chat feature works perfectly without audio. If you have persistent audio issues, you can still use video and text chat functionality.</p>"},{"location":"advanced/video-chat/#requirements","title":"Requirements","text":""},{"location":"advanced/video-chat/#python-dependencies","title":"Python Dependencies","text":"<pre><code>pip install opencv-python pyaudio numpy\n</code></pre>"},{"location":"advanced/video-chat/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Webcam: For video functionality</li> <li>Microphone: For audio functionality</li> <li>Speakers/Headphones: For audio output</li> </ul>"},{"location":"advanced/video-chat/#network-requirements","title":"Network Requirements","text":"<ul> <li>TCP ports for video, audio, and text streams (default: 9000, 9001, and 9002)</li> <li>Sufficient bandwidth for video streaming</li> <li>Low latency for real-time communication</li> </ul>"},{"location":"advanced/video-chat/#related-topics","title":"Related Topics","text":"<ul> <li>Live Streaming - For one-to-many video streaming</li> <li>TCP Protocol - For underlying transport</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"network/arp/","title":"ARP Scanning","text":"<p>ARP (Address Resolution Protocol) scanning allows you to discover active devices on your local network by sending ARP requests and analyzing responses.</p> <p>\u26a0\ufe0f ETHICAL WARNING: ARP scanning is intended for use in authorized networks only. This tool should only be used in controlled IT environments, schools, or labs with proper authorization. Unauthorized network scanning may be illegal and unethical.</p>"},{"location":"network/arp/#features","title":"Features","text":"<ul> <li>Network Discovery: Find all active devices on a subnet</li> <li>MAC Address Resolution: Get MAC addresses for discovered devices</li> <li>Interface Auto-Detection: Automatically detect the best network interface</li> <li>Customizable Timeouts: Adjust scan speed and reliability</li> <li>Verbose Logging: Detailed output for troubleshooting</li> </ul>"},{"location":"network/arp/#installation","title":"Installation","text":"<p>ARP scanning requires the <code>scapy</code> library:</p> <pre><code>pip install scapy\n</code></pre> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/arp/#basic-usage","title":"Basic Usage","text":""},{"location":"network/arp/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import arp_scan\nfrom kn_sock.network.arp import get_local_network_info\n\n# Auto-detect and scan your actual network\ninfo = get_local_network_info()\nif info['local_ip'] != 'Unknown':\n    ip_parts = info['local_ip'].split('.')\n    network = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n    devices = arp_scan(network)\n    for device in devices:\n        print(f\"IP: {device['ip']}, MAC: {device['mac']}\")\nelse:\n    print(\"Could not auto-detect network. Please specify manually:\")\n    # devices = arp_scan(\"YOUR_NETWORK_HERE/24\")  # e.g., 192.168.1.0/24\n</code></pre>"},{"location":"network/arp/#command-line","title":"Command Line","text":"<pre><code># Basic scan\nkn-sock scan 192.168.1.0/24\n\n# Verbose output\nkn-sock scan 192.168.1.0/24 --verbose\n\n# Custom interface and timeout\nkn-sock scan 192.168.1.0/24 --interface eth0 --timeout 5\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/arp/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/arp/#custom-interface-selection","title":"Custom Interface Selection","text":"<pre><code>from kn_sock.network import arp_scan\nfrom kn_sock.network.arp import get_local_network_info\n\n# Auto-detect network first\ninfo = get_local_network_info()\nif info['local_ip'] != 'Unknown':\n    ip_parts = info['local_ip'].split('.')\n    network = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n    # Use detected interface or specify your own\n    devices = arp_scan(network, interface=info['interface'])\n    # or specify manually: devices = arp_scan(network, interface=\"eth0\")\n</code></pre>"},{"location":"network/arp/#verbose-logging","title":"Verbose Logging","text":"<pre><code>from kn_sock.network import arp_scan\nfrom kn_sock.network.arp import get_local_network_info\n\n# Auto-detect network and enable detailed logging\ninfo = get_local_network_info()\nif info['local_ip'] != 'Unknown':\n    ip_parts = info['local_ip'].split('.')\n    network = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n    devices = arp_scan(network, verbose=True)\n</code></pre>"},{"location":"network/arp/#simple-ipmac-pairs","title":"Simple IP/MAC Pairs","text":"<pre><code>from kn_sock.network.arp import arp_scan_simple, get_local_network_info\n\n# Auto-detect network and get simple tuples\ninfo = get_local_network_info()\nif info['local_ip'] != 'Unknown':\n    ip_parts = info['local_ip'].split('.')\n    network = f\"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24\"\n\n    device_pairs = arp_scan_simple(network)\n    for ip, mac in device_pairs:\n        print(f\"{ip} -&gt; {mac}\")\n</code></pre>"},{"location":"network/arp/#network-information","title":"Network Information","text":"<pre><code>from kn_sock.network.arp import get_local_network_info\n\n# Get local network details\ninfo = get_local_network_info()\nprint(f\"Local IP: {info['local_ip']}\")\nprint(f\"Interface: {info['interface']}\")\nprint(f\"Gateway: {info['gateway']}\")\n</code></pre>"},{"location":"network/arp/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/arp/#common-network-ranges","title":"Common Network Ranges","text":"Range Description Example <code>/24</code> 256 addresses 192.168.1.0/24 <code>/16</code> 65,536 addresses 192.168.0.0/16 <code>/8</code> 16,777,216 addresses 10.0.0.0/8"},{"location":"network/arp/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/arp/#permission-issues","title":"Permission Issues","text":"<p>ARP scanning requires network access. On Linux/macOS, you may need to run with elevated privileges:</p> <pre><code>sudo kn-sock scan 192.168.1.0/24\n</code></pre>"},{"location":"network/arp/#no-devices-found","title":"No Devices Found","text":"<ol> <li>Check Network Range: Ensure you're scanning the correct subnet</li> <li>Verify Interface: Use <code>--interface</code> to specify the correct network interface</li> <li>Firewall: Some devices may not respond to ARP requests due to firewall settings</li> <li>Network Isolation: Ensure you're on the same network segment</li> </ol>"},{"location":"network/arp/#interface-detection","title":"Interface Detection","text":"<p>List available interfaces:</p> <pre><code>from kn_sock.network.monitor import get_network_interfaces\n\ninterfaces = get_network_interfaces()\nfor iface in interfaces:\n    print(f\"{iface['name']}: {iface['ip']}\")\n</code></pre>"},{"location":"network/arp/#timeout-issues","title":"Timeout Issues","text":"<p>Increase timeout for slower networks:</p> <pre><code>devices = arp_scan(\"192.168.1.0/24\", timeout=5)\n</code></pre>"},{"location":"network/arp/#security-considerations","title":"Security Considerations","text":"<ol> <li>Authorization: Only scan networks you own or have permission to monitor</li> <li>Legal Compliance: Ensure compliance with local network monitoring laws</li> <li>Network Impact: ARP scanning generates network traffic - use responsibly</li> <li>Detection: Some network monitoring tools may detect ARP scans</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"network/maclookup/","title":"MAC Address Lookup","text":"<p>MAC address lookup allows you to identify device vendors and manufacturers by analyzing the Organizationally Unique Identifier (OUI) in MAC addresses.</p> <p>\u26a0\ufe0f ETHICAL WARNING: MAC address lookup is intended for legitimate network management purposes only. This tool should only be used in authorized networks for device identification and network administration.</p>"},{"location":"network/maclookup/#features","title":"Features","text":"<ul> <li>Vendor Identification: Identify device manufacturers from MAC addresses</li> <li>Online API Integration: Use macvendors.co API for comprehensive database</li> <li>Offline Mode: Built-in OUI database for offline operation</li> <li>Batch Processing: Lookup multiple MAC addresses efficiently</li> <li>Format Validation: Validate MAC address formats</li> <li>API Key Support: Use API keys for higher rate limits</li> </ul>"},{"location":"network/maclookup/#installation","title":"Installation","text":"<p>MAC lookup requires the <code>requests</code> library for online lookups:</p> <pre><code>pip install requests\n</code></pre> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/maclookup/#basic-usage","title":"Basic Usage","text":""},{"location":"network/maclookup/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import mac_lookup\n\n# Example with a real MAC address (VMware)\nresult = mac_lookup(\"00:50:56:C0:00:08\")\nprint(f\"MAC: {result['mac']}\")\nprint(f\"Vendor: {result['vendor']}\")\nprint(f\"OUI: {result['oui']}\")\n\n# Offline lookup only (faster, uses local database)\nresult = mac_lookup(\"00:50:56:C0:00:08\", use_api=False)\nprint(f\"Vendor: {result['vendor']}\")\n</code></pre>"},{"location":"network/maclookup/#command-line","title":"Command Line","text":"<pre><code># Basic lookup\nkn-sock mac-lookup 00:1A:2B:3C:4D:5E\n\n# Offline mode only\nkn-sock mac-lookup 00:1A:2B:3C:4D:5E --offline\n\n# With API key\nkn-sock mac-lookup 00:1A:2B:3C:4D:5E --api-key YOUR_API_KEY\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/maclookup/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/maclookup/#online-vs-offline-lookup","title":"Online vs Offline Lookup","text":"<pre><code>from kn_sock.network import mac_lookup\n\n# Try online first, fallback to offline\nmac = \"00:50:56:C0:00:08\"  # VMware MAC example\n\n# Online lookup (with automatic fallback to offline)\nresult = mac_lookup(mac, use_api=True)\nprint(f\"Online result: {result['vendor']} (Source: {result['source']})\")\n\n# Offline only (faster, uses local database)\nresult = mac_lookup(mac, use_api=False)\nprint(f\"Offline result: {result['vendor']} (Source: {result['source']})\")\n</code></pre>"},{"location":"network/maclookup/#batch-processing","title":"Batch Processing","text":"<pre><code>from kn_sock.network.mac_lookup import batch_mac_lookup\n\n# Example MAC addresses from different vendors\nmacs = [\n    \"00:50:56:C0:00:08\",  # VMware\n    \"08:00:27:12:34:56\",  # VirtualBox  \n    \"52:54:00:AB:CD:EF\"   # QEMU\n]\n\nresults = batch_mac_lookup(macs, use_api=False)  # Use offline for speed\nfor result in results:\n    print(f\"{result['mac']}: {result['vendor']}\")\n</code></pre>"},{"location":"network/maclookup/#mac-address-validation","title":"MAC Address Validation","text":"<pre><code>from kn_sock.network.mac_lookup import validate_mac\n\n# Test different MAC address formats\ntest_macs = [\n    \"00:50:56:C0:00:08\",     # Valid colon format\n    \"00-50-56-C0-00-08\",     # Valid hyphen format\n    \"005056C00008\",          # Valid compact format\n    \"00:50:56:c0:00:08\",     # Valid mixed case\n    \"00:1A:2B:3C:4D\",        # Invalid (too short)\n    \"invalid-mac\"          # Invalid\n]\n\nfor mac in macs:\n    is_valid = validate_mac(mac)\n    print(f\"{mac}: {'Valid' if is_valid else 'Invalid'}\")\n</code></pre>"},{"location":"network/maclookup/#api-key-usage","title":"API Key Usage","text":"<pre><code>from kn_sock.network.mac_lookup import mac_lookup_api\n\n# Use API key for higher rate limits\nresult = mac_lookup_api(\"00:1A:2B:3C:4D:5E\", api_key=\"YOUR_API_KEY\")\n</code></pre>"},{"location":"network/maclookup/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/maclookup/#mac-address-formats","title":"MAC Address Formats","text":"<p>The lookup functions accept various MAC address formats:</p> Format Example Description Colon-separated <code>00:1A:2B:3C:4D:5E</code> Standard format Hyphen-separated <code>00-1A-2B-3C-4D-5E</code> Alternative format No separators <code>001A2B3C4D5E</code> Compact format Mixed case <code>00:1a:2b:3c:4d:5e</code> Case insensitive"},{"location":"network/maclookup/#common-oui-examples","title":"Common OUI Examples","text":"OUI Vendor Description <code>00:50:56</code> VMware, Inc. Virtual machines <code>08:00:27</code> Oracle VirtualBox Virtual machines <code>52:54:00</code> QEMU Virtual machines <code>00:15:5D</code> Microsoft Corporation Hyper-V <code>00:16:3E</code> Xen Virtual machines <code>AC:DE:48</code> Private Locally administered"},{"location":"network/maclookup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/maclookup/#api-rate-limits","title":"API Rate Limits","text":"<p>If you encounter rate limiting:</p> <ol> <li>Use API Key: Get a free API key from macvendors.co</li> <li>Switch to Offline Mode: Use built-in database</li> <li>Batch Processing: Process multiple MACs in one request</li> </ol> <pre><code># Use API key\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", api_key=\"YOUR_API_KEY\")\n\n# Or use offline mode\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=False)\n</code></pre>"},{"location":"network/maclookup/#network-connectivity","title":"Network Connectivity","text":"<p>For online lookups, ensure internet connectivity:</p> <pre><code>import requests\n\ntry:\n    response = requests.get(\"https://api.macvendors.com/00:1A:2B\", timeout=5)\n    print(\"API is accessible\")\nexcept requests.RequestException:\n    print(\"API not accessible, using offline mode\")\n    result = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=False)\n</code></pre>"},{"location":"network/maclookup/#invalid-mac-addresses","title":"Invalid MAC Addresses","text":"<p>Validate MAC addresses before lookup:</p> <pre><code>from kn_sock.network.mac_lookup import validate_mac\n\nmac = \"00:1A:2B:3C:4D:5E\"\nif validate_mac(mac):\n    result = mac_lookup(mac)\nelse:\n    print(\"Invalid MAC address format\")\n</code></pre>"},{"location":"network/maclookup/#security-considerations","title":"Security Considerations","text":"<ol> <li>Privacy: MAC addresses can reveal device information</li> <li>Network Security: Use for legitimate network administration only</li> <li>Data Protection: Be mindful of collected MAC address data</li> <li>API Keys: Keep API keys secure and don't share them</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"network/monitor/","title":"DNS Monitoring","text":"<p>DNS monitoring allows you to capture and analyze DNS requests on your network, providing insights into network activity and device behavior.</p> <p>\u26a0\ufe0f ETHICAL WARNING: DNS monitoring is intended for use in authorized networks only. This tool should only be used in controlled IT environments, schools, or labs with proper authorization. Monitoring user traffic without consent may be illegal and unethical.</p>"},{"location":"network/monitor/#features","title":"Features","text":"<ul> <li>Real-time DNS Capture: Monitor DNS requests as they happen</li> <li>Detailed Query Information: Capture source IP, domain, and query type</li> <li>JSON Logging: Save captured data for analysis</li> <li>Statistical Analysis: Analyze DNS patterns and trends</li> <li>Asynchronous Monitoring: Run monitoring in background threads</li> <li>Interface Selection: Choose specific network interfaces to monitor</li> </ul>"},{"location":"network/monitor/#installation","title":"Installation","text":"<p>DNS monitoring requires the <code>scapy</code> library:</p> <pre><code>pip install scapy\n</code></pre> <p>Note: DNS monitoring requires root/administrator privileges for packet sniffing.</p> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/monitor/#basic-usage","title":"Basic Usage","text":""},{"location":"network/monitor/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import monitor_dns\n\n# Monitor DNS for 30 seconds\n# Note: Requires root privileges (run with sudo)\ntry:\n    results = monitor_dns(duration=30)\n    for result in results:\n        print(f\"{result['source_ip']} -&gt; {result['domain']}\")\nexcept ImportError:\n    print(\"scapy required: pip install scapy\")\nexcept PermissionError:\n    print(\"Root privileges required: sudo python script.py\")\n</code></pre>"},{"location":"network/monitor/#command-line","title":"Command Line","text":"<pre><code># Basic monitoring (requires sudo)\nsudo kn-sock monitor\n\n# Monitor for 2 minutes with logging\nsudo kn-sock monitor --duration 120 --log dns_log.json\n\n# Verbose output\nsudo kn-sock monitor --duration 60 --verbose\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/monitor/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/monitor/#logging-to-file","title":"Logging to File","text":"<pre><code>from kn_sock.network import monitor_dns\n\n# Save results to JSON file\nresults = monitor_dns(\n    duration=60, \n    log_file=\"dns_log.json\",\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#asynchronous-monitoring","title":"Asynchronous Monitoring","text":"<pre><code>from kn_sock.network.monitor import monitor_dns_async\nimport time\n\n# Start monitoring in background\nmonitor_thread = monitor_dns_async(\n    duration=120,\n    log_file=\"background_dns.json\"\n)\n\n# Do other work while monitoring\nprint(\"Monitoring started in background...\")\ntime.sleep(5)\n\n# Wait for monitoring to complete\nmonitor_thread.join()\nprint(\"Monitoring completed!\")\n</code></pre>"},{"location":"network/monitor/#custom-callback-function","title":"Custom Callback Function","text":"<pre><code>from kn_sock.network import monitor_dns\n\ndef dns_callback(result):\n    \"\"\"Process each DNS request in real-time.\"\"\"\n    print(f\"DNS Query: {result['source_ip']} -&gt; {result['domain']} ({result['query_type']})\")\n\n# Monitor with custom callback\nresults = monitor_dns(\n    duration=60,\n    callback=dns_callback,\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#interface-selection","title":"Interface Selection","text":"<pre><code>from kn_sock.network.monitor import get_network_interfaces, monitor_dns\n\n# Get available interfaces\ninterfaces = get_network_interfaces()\nfor iface in interfaces:\n    print(f\"Interface: {iface['name']}, IP: {iface['ip']}\")\n\n# Monitor specific interface\nresults = monitor_dns(\n    duration=60,\n    interface=\"eth0\",\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#log-analysis","title":"Log Analysis","text":""},{"location":"network/monitor/#basic-analysis","title":"Basic Analysis","text":"<pre><code>from kn_sock.network.monitor import analyze_dns_logs\n\n# Analyze captured DNS logs\nanalysis = analyze_dns_logs(\"dns_log.json\")\n\nprint(f\"Total requests: {analysis['total_requests']}\")\nprint(f\"Unique domains: {analysis['unique_domains']}\")\nprint(f\"Unique sources: {analysis['unique_sources']}\")\n\n# Top domains\nprint(\"\\nTop domains:\")\nfor domain, count in analysis['top_domains'][:5]:\n    print(f\"  {domain}: {count} requests\")\n</code></pre>"},{"location":"network/monitor/#advanced-analysis","title":"Advanced Analysis","text":"<pre><code>import json\nfrom kn_sock.network.monitor import analyze_dns_logs\n\ndef detailed_analysis(log_file):\n    \"\"\"Perform detailed DNS log analysis.\"\"\"\n    analysis = analyze_dns_logs(log_file)\n\n    print(\"DNS Analysis Report\")\n    print(\"=\" * 50)\n    print(f\"Analysis Time: {analysis['analysis_timestamp']}\")\n    print(f\"Total Requests: {analysis['total_requests']}\")\n    print(f\"Unique Domains: {analysis['unique_domains']}\")\n    print(f\"Unique Sources: {analysis['unique_sources']}\")\n\n    print(\"\\nTop 10 Domains:\")\n    for i, (domain, count) in enumerate(analysis['top_domains'][:10], 1):\n        print(f\"  {i:2d}. {domain:30s} {count:4d} requests\")\n\n    print(\"\\nTop 10 Sources:\")\n    for i, (source, count) in enumerate(analysis['top_sources'][:10], 1):\n        print(f\"  {i:2d}. {source:15s} {count:4d} requests\")\n\n    print(\"\\nQuery Type Distribution:\")\n    for qtype, count in analysis['query_type_distribution'].items():\n        print(f\"  {qtype:6s}: {count:4d} requests\")\n\nif __name__ == \"__main__\":\n    detailed_analysis(\"dns_log.json\")\n</code></pre>"},{"location":"network/monitor/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/monitor/#dns-query-types","title":"DNS Query Types","text":"Type Name Description 1 A IPv4 address 2 NS Name server 5 CNAME Canonical name 6 SOA Start of authority 12 PTR Pointer (reverse DNS) 15 MX Mail exchange 16 TXT Text record 28 AAAA IPv6 address 33 SRV Service record"},{"location":"network/monitor/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/monitor/#permission-issues","title":"Permission Issues","text":"<p>DNS monitoring requires root privileges for packet sniffing:</p> <pre><code># Linux/macOS\nsudo kn-sock monitor --duration 60\n\n# Or in Python\nsudo python -c \"from kn_sock.network import monitor_dns; monitor_dns(60)\"\n</code></pre>"},{"location":"network/monitor/#no-dns-requests-captured","title":"No DNS Requests Captured","text":"<ol> <li>Check Interface: Ensure you're monitoring the correct network interface</li> <li>Network Activity: Generate some DNS requests (browse web, ping hosts)</li> <li>Firewall: Some systems may block packet capture</li> <li>Virtual Environment: Ensure you're not in a restricted container</li> </ol>"},{"location":"network/monitor/#scapy-installation-issues","title":"Scapy Installation Issues","text":"<pre><code># Install scapy\npip install scapy\n\n# Or with system package manager\nsudo apt-get install python3-scapy  # Ubuntu/Debian\nsudo yum install python3-scapy      # CentOS/RHEL\n</code></pre>"},{"location":"network/monitor/#interface-detection","title":"Interface Detection","text":"<pre><code>from kn_sock.network.monitor import get_network_interfaces\n\ninterfaces = get_network_interfaces()\nprint(\"Available interfaces:\")\nfor iface in interfaces:\n    print(f\"  {iface['name']}: {iface['ip']}\")\n</code></pre>"},{"location":"network/monitor/#security-considerations","title":"Security Considerations","text":"<ol> <li>Authorization: Only monitor networks you own or have permission to monitor</li> <li>Legal Compliance: Ensure compliance with local privacy and surveillance laws</li> <li>Data Privacy: Be mindful of sensitive information in DNS queries</li> <li>Privilege Requirements: Requires elevated privileges for packet capture</li> <li>Network Impact: Minimal impact on network performance</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"protocols/file-transfer/","title":"File Transfer","text":"<p>kn-sock provides robust file transfer capabilities over TCP, supporting both synchronous and asynchronous operations with progress tracking.</p>"},{"location":"protocols/file-transfer/#overview","title":"Overview","text":"<p>File transfer features in kn-sock: - Reliable file transmission over TCP - Progress tracking with visual progress bars - Support for large files - Both synchronous and asynchronous operations - Automatic file metadata handling - Error handling and recovery</p>"},{"location":"protocols/file-transfer/#basic-file-transfer","title":"Basic File Transfer","text":""},{"location":"protocols/file-transfer/#file-server","title":"File Server","text":"<pre><code>from kn_sock import start_file_server\n\n# Start a file server that saves received files to /path/to/save/directory\nstart_file_server(8080, \"/path/to/save/directory\")\n</code></pre>"},{"location":"protocols/file-transfer/#file-client","title":"File Client","text":"<pre><code>from kn_sock import send_file\n\n# Send a file to the server\nsend_file(\"localhost\", 8080, \"path/to/your/file.txt\")\n</code></pre>"},{"location":"protocols/file-transfer/#file-server-with-custom-handler","title":"File Server with Custom Handler","text":"<pre><code>from kn_sock import start_file_server\n\ndef file_received_handler(filename, filepath, addr):\n    \"\"\"Called when a file is successfully received\"\"\"\n    print(f\"File '{filename}' received from {addr} and saved to {filepath}\")\n\nstart_file_server(8080, \"/path/to/save/directory\", handler=file_received_handler)\n</code></pre>"},{"location":"protocols/file-transfer/#asynchronous-file-transfer","title":"Asynchronous File Transfer","text":""},{"location":"protocols/file-transfer/#async-file-server","title":"Async File Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_file_server_async\n\nasync def main():\n    await start_file_server_async(8080, \"/path/to/save/directory\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/file-transfer/#async-file-client","title":"Async File Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_file_async\n\nasync def main():\n    await send_file_async(\"localhost\", 8080, \"path/to/your/file.txt\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/file-transfer/#progress-tracking","title":"Progress Tracking","text":"<p>All file transfer functions support progress bars using tqdm:</p>"},{"location":"protocols/file-transfer/#enable-progress-bar","title":"Enable Progress Bar","text":"<pre><code>from kn_sock import send_file\n\n# Show progress bar (default if tqdm is installed)\nsend_file('localhost', 8080, 'file.txt', show_progress=True)\n</code></pre>"},{"location":"protocols/file-transfer/#disable-progress-bar","title":"Disable Progress Bar","text":"<pre><code>from kn_sock import send_file\n\n# Disable progress bar\nsend_file('localhost', 8080, 'file.txt', show_progress=False)\n</code></pre>"},{"location":"protocols/file-transfer/#custom-progress-callback","title":"Custom Progress Callback","text":"<pre><code>from kn_sock import send_file\n\ndef progress_callback(bytes_sent, total_bytes, filename):\n    percentage = (bytes_sent / total_bytes) * 100\n    print(f\"Sending {filename}: {percentage:.1f}% complete\")\n\nsend_file('localhost', 8080, 'file.txt', progress_callback=progress_callback)\n</code></pre>"},{"location":"protocols/file-transfer/#advanced-file-transfer","title":"Advanced File Transfer","text":""},{"location":"protocols/file-transfer/#multiple-file-transfer","title":"Multiple File Transfer","text":"<pre><code>import os\nfrom kn_sock import send_file\n\ndef send_directory(host, port, directory_path):\n    \"\"\"Send all files in a directory\"\"\"\n    for filename in os.listdir(directory_path):\n        filepath = os.path.join(directory_path, filename)\n        if os.path.isfile(filepath):\n            print(f\"Sending {filename}...\")\n            send_file(host, port, filepath)\n\n# Send all files in a directory\nsend_directory(\"localhost\", 8080, \"/path/to/directory\")\n</code></pre>"},{"location":"protocols/file-transfer/#selective-file-transfer","title":"Selective File Transfer","text":"<pre><code>import os\nfrom kn_sock import send_file\n\ndef send_files_by_extension(host, port, directory_path, extensions):\n    \"\"\"Send files with specific extensions\"\"\"\n    for filename in os.listdir(directory_path):\n        if any(filename.endswith(ext) for ext in extensions):\n            filepath = os.path.join(directory_path, filename)\n            if os.path.isfile(filepath):\n                print(f\"Sending {filename}...\")\n                send_file(host, port, filepath)\n\n# Send only image files\nsend_files_by_extension(\"localhost\", 8080, \"/path/to/directory\", ['.jpg', '.png', '.gif'])\n</code></pre>"},{"location":"protocols/file-transfer/#file-transfer-with-metadata","title":"File Transfer with Metadata","text":"<pre><code>import os\nimport json\nfrom kn_sock import send_json, send_file\n\ndef send_file_with_metadata(host, port, filepath):\n    \"\"\"Send file metadata first, then the file\"\"\"\n    filename = os.path.basename(filepath)\n    file_size = os.path.getsize(filepath)\n    file_modified = os.path.getmtime(filepath)\n\n    # Send metadata\n    metadata = {\n        \"filename\": filename,\n        \"size\": file_size,\n        \"modified\": file_modified,\n        \"type\": \"file_transfer\"\n    }\n    send_json(host, port, metadata)\n\n    # Send the actual file\n    send_file(host, port, filepath)\n\nsend_file_with_metadata(\"localhost\", 8080, \"document.pdf\")\n</code></pre>"},{"location":"protocols/file-transfer/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/json/","title":"JSON Communication","text":"<p>kn-sock provides built-in support for JSON communication, making it easy to send and receive structured data over sockets.</p>"},{"location":"protocols/json/#overview","title":"Overview","text":"<p>JSON communication in kn-sock: - Automatically serializes Python objects to JSON - Handles encoding/decoding transparently - Supports both synchronous and asynchronous operations - Provides error handling for invalid JSON - Works over both TCP and UDP</p>"},{"location":"protocols/json/#basic-json-communication","title":"Basic JSON Communication","text":""},{"location":"protocols/json/#json-server","title":"JSON Server","text":"<pre><code>from kn_sock import start_json_server\n\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n\n    # Process the JSON data\n    message_type = data.get('type')\n    payload = data.get('payload')\n\n    # Send a JSON response\n    response = {\n        \"status\": \"received\",\n        \"message_type\": message_type,\n        \"timestamp\": time.time()\n    }\n    client_socket.sendall(json.dumps(response).encode('utf-8'))\n\nstart_json_server(8080, handle_json_message)\n</code></pre>"},{"location":"protocols/json/#json-client","title":"JSON Client","text":"<pre><code>from kn_sock import send_json\n\n# Send a simple JSON object\nmessage = {\"message\": \"Hello, World!\"}\nsend_json(\"localhost\", 8080, message)\n\n# Send a complex JSON object\ndata = {\n    \"type\": \"user_data\",\n    \"payload\": {\n        \"user_id\": 123,\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    },\n    \"timestamp\": time.time()\n}\nsend_json(\"localhost\", 8080, data)\n</code></pre>"},{"location":"protocols/json/#asynchronous-json-communication","title":"Asynchronous JSON Communication","text":""},{"location":"protocols/json/#async-json-server","title":"Async JSON Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_json_server_async\n\nasync def handle_json_message(data, addr, writer):\n    \"\"\"\n    Handle incoming JSON messages asynchronously.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n\n    response = {\"status\": \"received\", \"data\": data}\n    writer.write(json.dumps(response).encode('utf-8'))\n    await writer.drain()\n\nasyncio.run(start_json_server_async(8080, handle_json_message))\n</code></pre>"},{"location":"protocols/json/#async-json-client","title":"Async JSON Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_json_async\n\nasync def main():\n    data = {\"message\": \"Hello, async JSON!\"}\n    await send_json_async(\"localhost\", 8080, data)\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/json/#best-practices","title":"Best Practices","text":"<ol> <li>Use consistent message structure: Define a standard format for your JSON messages</li> <li>Include timestamps: Add timestamps for debugging and logging</li> <li>Handle errors gracefully: Always provide meaningful error responses</li> <li>Validate input: Use decorators or manual validation for critical data</li> <li>Use correlation IDs: For request-response patterns, include correlation IDs</li> <li>Consider compression: For large JSON objects, use compression</li> <li>Document your API: Clearly document the expected JSON structure</li> </ol>"},{"location":"protocols/json/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/secure-tcp/","title":"Secure TCP (SSL/TLS)","text":"<p>kn-sock provides comprehensive SSL/TLS support for secure, encrypted communication over TCP connections.</p>"},{"location":"protocols/secure-tcp/#overview","title":"Overview","text":"<p>Secure TCP features in kn-sock: - Full SSL/TLS encryption support - Both synchronous and asynchronous operations - Client and server certificate validation - Mutual TLS (mTLS) support - Configurable security parameters - Integration with connection pooling</p>"},{"location":"protocols/secure-tcp/#basic-ssltls-setup","title":"Basic SSL/TLS Setup","text":""},{"location":"protocols/secure-tcp/#synchronous-secure-tcp-server","title":"Synchronous Secure TCP Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    port=8443,\n    handler_func=handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # Optional, for client cert verification\n    require_client_cert=True,  # Optional, for mutual TLS\n    host=\"0.0.0.0\"  # Optional, defaults to \"0.0.0.0\"\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#synchronous-secure-tcp-client","title":"Synchronous Secure TCP Client","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    host=\"localhost\",\n    port=8443,\n    message=\"Hello Secure\",\n    cafile=\"ca.crt\",  # Optional, for server verification\n    certfile=\"client.crt\",  # Optional, for mutual TLS\n    keyfile=\"client.key\",   # Optional, for mutual TLS\n    verify=True  # Optional, defaults to True\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#asynchronous-ssltls","title":"Asynchronous SSL/TLS","text":""},{"location":"protocols/secure-tcp/#async-secure-tcp-server","title":"Async Secure TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_ssl_tcp_server\n\nasync def handle_secure(data, addr, writer):\n    print(f\"Received from {addr}: {data.decode()}\")\n    writer.write(b\"Secure response\")\n    await writer.drain()\n\nasyncio.run(start_async_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n))\n</code></pre>"},{"location":"protocols/secure-tcp/#async-secure-tcp-client","title":"Async Secure TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_ssl_tcp_message_async\n\nasyncio.run(send_ssl_tcp_message_async(\n    \"localhost\", 8443, \"Hello Secure\"\n))\n</code></pre>"},{"location":"protocols/secure-tcp/#certificate-management","title":"Certificate Management","text":""},{"location":"protocols/secure-tcp/#generating-self-signed-certificates","title":"Generating Self-Signed Certificates","text":"<p>For testing and development:</p> <pre><code># Generate private key\nopenssl genrsa -out server.key 2048\n\n# Generate certificate signing request\nopenssl req -new -key server.key -out server.csr\n\n# Generate self-signed certificate\nopenssl x509 -req -in server.csr -signkey server.key -out server.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#generating-ca-signed-certificates","title":"Generating CA-Signed Certificates","text":"<p>For production use:</p> <pre><code># Generate CA private key\nopenssl genrsa -out ca.key 2048\n\n# Generate CA certificate\nopenssl req -new -x509 -key ca.key -out ca.crt -days 3650\n\n# Generate server private key\nopenssl genrsa -out server.key 2048\n\n# Generate server certificate signing request\nopenssl req -new -key server.key -out server.csr\n\n# Sign server certificate with CA\nopenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -out server.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#client-certificates-mtls","title":"Client Certificates (mTLS)","text":"<p>For mutual TLS authentication:</p> <pre><code># Generate client private key\nopenssl genrsa -out client.key 2048\n\n# Generate client certificate signing request\nopenssl req -new -key client.key -out client.csr\n\n# Sign client certificate with CA\nopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -out client.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#advanced-ssltls-configuration","title":"Advanced SSL/TLS Configuration","text":""},{"location":"protocols/secure-tcp/#server-with-ca-verification","title":"Server with CA Verification","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # CA certificate for client verification\n    require_client_cert=True  # Require client certificates\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#client-with-certificate-authentication","title":"Client with Certificate Authentication","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\",\n    cafile=\"ca.crt\",  # CA certificate for server verification\n    certfile=\"client.crt\",  # Client certificate\n    keyfile=\"client.key\",  # Client private key\n    verify=True  # Verify server certificate\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#custom-ssl-context","title":"Custom SSL Context","text":"<pre><code>import ssl\nfrom kn_sock import start_ssl_tcp_server\n\ndef create_ssl_context():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile=\"server.crt\", keyfile=\"server.key\")\n    context.load_verify_locations(cafile=\"ca.crt\")\n    context.verify_mode = ssl.CERT_REQUIRED\n    context.check_hostname = False\n    return context\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    ssl_context=create_ssl_context()\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/tcp/","title":"TCP Protocol","text":"<p>TCP (Transmission Control Protocol) provides reliable, ordered, and error-checked delivery of data between applications. kn-sock makes TCP communication simple and efficient.</p>"},{"location":"protocols/tcp/#overview","title":"Overview","text":"<p>TCP is connection-oriented, meaning: - A connection must be established before data can be sent - Data is delivered in the same order it was sent - Lost packets are automatically retransmitted - Connections are explicitly closed</p>"},{"location":"protocols/tcp/#synchronous-tcp","title":"Synchronous TCP","text":""},{"location":"protocols/tcp/#basic-tcp-server","title":"Basic TCP Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming TCP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"protocols/tcp/#basic-tcp-client","title":"Basic TCP Client","text":"<pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"protocols/tcp/#threaded-tcp-server","title":"Threaded TCP Server","text":"<p>For handling multiple clients concurrently:</p> <pre><code>from kn_sock import start_threaded_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_threaded_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"protocols/tcp/#sending-raw-bytes","title":"Sending Raw Bytes","text":"<pre><code>from kn_sock import send_tcp_bytes\n\n# Send raw bytes instead of strings\ndata = b'\\x01\\x02\\x03\\x04'\nsend_tcp_bytes(\"localhost\", 8080, data)\n</code></pre>"},{"location":"protocols/tcp/#asynchronous-tcp","title":"Asynchronous TCP","text":""},{"location":"protocols/tcp/#async-tcp-server","title":"Async TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_tcp_server\n\nasync def handle_tcp_message(data, addr, writer):\n    \"\"\"\n    Handle incoming TCP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    writer.write(b\"Message received\")\n    await writer.drain()\n\nasyncio.run(start_async_tcp_server(8080, handle_tcp_message))\n</code></pre>"},{"location":"protocols/tcp/#async-tcp-client","title":"Async TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"protocols/tcp/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>All TCP server functions support graceful shutdown using shutdown events:</p> <pre><code>import threading\nfrom kn_sock import start_tcp_server\n\nshutdown_event = threading.Event()\n\ndef handler(data, addr, client_socket):\n    # Check if shutdown was requested\n    if shutdown_event.is_set():\n        return\n    # Process message...\n    pass\n\n# Start server\nserver_thread = threading.Thread(\n    target=start_tcp_server,\n    args=(8080, handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n\n# Later, to shutdown gracefully:\nshutdown_event.set()\n</code></pre>"},{"location":"protocols/tcp/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/udp/","title":"UDP Protocol","text":"<p>UDP (User Datagram Protocol) provides connectionless, unreliable communication between applications. kn-sock makes UDP messaging simple and efficient.</p>"},{"location":"protocols/udp/#overview","title":"Overview","text":"<p>UDP is connectionless, meaning: - No connection establishment required - No guarantee of delivery order - No automatic retransmission of lost packets - Lower overhead than TCP - Ideal for real-time applications</p>"},{"location":"protocols/udp/#synchronous-udp","title":"Synchronous UDP","text":""},{"location":"protocols/udp/#basic-udp-server","title":"Basic UDP Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    \"\"\"\n    Handle incoming UDP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        server_socket (socket.socket): The server socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"protocols/udp/#basic-udp-client","title":"Basic UDP Client","text":"<pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"protocols/udp/#udp-server-with-response","title":"UDP Server with Response","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    message = data.decode('utf-8')\n    print(f\"Received from {addr}: {message}\")\n\n    # Send a response back to the client\n    response = f\"Echo: {message}\"\n    server_socket.sendto(response.encode('utf-8'), addr)\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"protocols/udp/#asynchronous-udp","title":"Asynchronous UDP","text":""},{"location":"protocols/udp/#async-udp-server","title":"Async UDP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def handle_udp_message(data, addr, transport):\n    \"\"\"\n    Handle incoming UDP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        transport (asyncio.DatagramTransport): The transport object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nasyncio.run(start_udp_server_async(8080, handle_udp_message))\n</code></pre>"},{"location":"protocols/udp/#async-udp-client","title":"Async UDP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasyncio.run(send_udp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"protocols/udp/#udp-multicast","title":"UDP Multicast","text":"<p>UDP multicast allows sending messages to multiple recipients simultaneously.</p>"},{"location":"protocols/udp/#multicast-server","title":"Multicast Server","text":"<pre><code>from kn_sock import start_udp_multicast_server\n\ndef handle_multicast_message(data, addr, server_socket):\n    print(f\"Received multicast from {addr}: {data.decode('utf-8')}\")\n\n# Listen on multicast group 224.0.0.1\nstart_udp_multicast_server(\n    group=\"224.0.0.1\",\n    port=8080,\n    handler_func=handle_multicast_message,\n    listen_ip=\"0.0.0.0\",  # Optional, defaults to \"0.0.0.0\"\n    shutdown_event=None   # Optional, for graceful shutdown\n)\n</code></pre>"},{"location":"protocols/udp/#multicast-client","title":"Multicast Client","text":"<pre><code>from kn_sock import send_udp_multicast\n\n# Send to multicast group 224.0.0.1\nsend_udp_multicast(\n    group=\"224.0.0.1\",\n    port=8080,\n    message=\"Hello, multicast world!\",\n    ttl=1  # Optional, defaults to 1\n)\n</code></pre>"},{"location":"protocols/udp/#multicast-configuration","title":"Multicast Configuration","text":"Parameter Description Default Required <code>group</code> Multicast group address (e.g., '224.0.0.1') - Yes <code>port</code> Port number - Yes <code>message</code> Message to send - Yes <code>ttl</code> Time To Live for multicast packets 1 No <code>listen_ip</code> Local IP to bind to (server) \"0.0.0.0\" No <code>shutdown_event</code> Event for graceful shutdown (server) None No <code>ttl</code> Time-to-live for multicast packets 1 <code>listen_ip</code> IP to listen on for multicast '0.0.0.0'"},{"location":"protocols/udp/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable, connection-oriented communication</li> <li>JSON Communication - For structured data over UDP</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/websocket/","title":"WebSocket Protocol","text":"<p>WebSockets provide full-duplex communication over a single TCP connection. kn-sock offers comprehensive WebSocket support for real-time applications.</p>"},{"location":"protocols/websocket/#overview","title":"Overview","text":"<p>WebSocket features in kn-sock: - Full-duplex communication: Send and receive simultaneously - Real-time messaging: Low-latency bidirectional communication - Connection persistence: Long-lived connections with automatic reconnection - Custom protocols: Support for WebSocket subprotocols - Async and sync support: Both synchronous and asynchronous implementations - Built-in ping/pong: Automatic connection health monitoring</p>"},{"location":"protocols/websocket/#basic-websocket-usage","title":"Basic WebSocket Usage","text":""},{"location":"protocols/websocket/#websocket-server","title":"WebSocket Server","text":"<pre><code>from kn_sock import start_websocket_server\nimport threading\n\ndef handle_websocket_client(client_socket, address):\n    \"\"\"\n    Handle WebSocket client connections.\n\n    Args:\n        client_socket: The WebSocket client connection\n        address: Client address tuple (host, port)\n    \"\"\"\n    print(f\"WebSocket client connected from {address}\")\n\n    try:\n        while True:\n            # Receive message from client\n            message = client_socket.recv()\n            if message:\n                print(f\"Received: {message}\")\n\n                # Echo the message back\n                client_socket.send(f\"Echo: {message}\")\n            else:\n                # Client disconnected\n                break\n\n    except Exception as e:\n        print(f\"Error handling client {address}: {e}\")\n    finally:\n        print(f\"Client {address} disconnected\")\n        client_socket.close()\n\n# Start WebSocket server\nshutdown_event = threading.Event()\nstart_websocket_server(\"localhost\", 8765, handle_websocket_client, shutdown_event)\n</code></pre>"},{"location":"protocols/websocket/#websocket-client","title":"WebSocket Client","text":"<pre><code>from kn_sock import connect_websocket\nimport time\n\ndef websocket_client_example():\n    \"\"\"Example WebSocket client.\"\"\"\n\n    # Connect to WebSocket server\n    ws = connect_websocket(\"localhost\", 8765)\n\n    try:\n        # Send messages\n        ws.send(\"Hello WebSocket!\")\n        ws.send(\"How are you?\")\n\n        # Receive responses\n        for _ in range(2):\n            response = ws.recv()\n            print(f\"Server response: {response}\")\n\n        # Send JSON data\n        import json\n        data = {\"type\": \"message\", \"content\": \"JSON message\", \"timestamp\": time.time()}\n        ws.send(json.dumps(data))\n\n        response = ws.recv()\n        print(f\"JSON response: {response}\")\n\n    finally:\n        ws.close()\n\n# Run the client\nwebsocket_client_example()\n</code></pre>"},{"location":"protocols/websocket/#asynchronous-websocket","title":"Asynchronous WebSocket","text":""},{"location":"protocols/websocket/#async-websocket-server","title":"Async WebSocket Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_websocket_server\n\nasync def handle_async_websocket(websocket, path):\n    \"\"\"\n    Handle async WebSocket connections.\n\n    Args:\n        websocket: The WebSocket connection\n        path: The requested path\n    \"\"\"\n    print(f\"Async WebSocket client connected: {path}\")\n\n    try:\n        async for message in websocket:\n            print(f\"Received: {message}\")\n\n            # Process the message\n            if message.startswith(\"ping\"):\n                await websocket.send(\"pong\")\n            elif message.startswith(\"echo\"):\n                await websocket.send(f\"Echo: {message[5:]}\")\n            else:\n                await websocket.send(f\"Processed: {message}\")\n\n    except Exception as e:\n        print(f\"Error in async handler: {e}\")\n\n# Start async WebSocket server\nasync def main():\n    server = await start_async_websocket_server(\n        \"localhost\", 8765, handle_async_websocket\n    )\n    print(\"Async WebSocket server started on ws://localhost:8765\")\n    await server.wait_closed()\n\n# Run the server\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/websocket/#async-websocket-client","title":"Async WebSocket Client","text":"<pre><code>import asyncio\nfrom kn_sock import async_connect_websocket\n\nasync def async_websocket_client():\n    \"\"\"Example async WebSocket client.\"\"\"\n\n    # Connect to async WebSocket server\n    async with async_connect_websocket(\"localhost\", 8765) as websocket:\n\n        # Send multiple messages\n        messages = [\"ping\", \"echo Hello\", \"async message\"]\n\n        for message in messages:\n            await websocket.send(message)\n            response = await websocket.recv()\n            print(f\"Response: {response}\")\n\n            # Small delay between messages\n            await asyncio.sleep(0.5)\n\n# Run the async client\nasyncio.run(async_websocket_client())\n</code></pre>"},{"location":"protocols/websocket/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"utilities/error-handling/","title":"Error Handling","text":"<p>kn-sock provides custom exception classes for better error handling in socket applications.</p>"},{"location":"utilities/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All kn-sock exceptions inherit from <code>EasySocketError</code>:</p> <pre><code>from kn_sock.errors import EasySocketError, ConnectionTimeoutError, PortInUseError\n\ntry:\n    # Socket operations\n    pass\nexcept EasySocketError as e:\n    # Catches all kn-sock errors\n    print(f\"Socket error: {e}\")\n</code></pre>"},{"location":"utilities/error-handling/#available-exceptions","title":"Available Exceptions","text":""},{"location":"utilities/error-handling/#easysocketerror","title":"<code>EasySocketError</code>","text":"<p>Base exception for all kn-sock errors.</p>"},{"location":"utilities/error-handling/#connectiontimeouterrormessageconnection-timed-out","title":"<code>ConnectionTimeoutError(message=\"Connection timed out.\")</code>","text":"<p>Raised when connection or I/O operations time out.</p>"},{"location":"utilities/error-handling/#portinuseerrorport-messagenone","title":"<code>PortInUseError(port, message=None)</code>","text":"<p>Raised when a specified port is already in use.</p> <p>Parameters: - <code>port</code> (int): The port number that's in use - <code>message</code> (str, optional): Custom error message</p>"},{"location":"utilities/error-handling/#invalidjsonerrormessagereceived-invalid-json-data","title":"<code>InvalidJSONError(message=\"Received invalid JSON data.\")</code>","text":"<p>Raised when JSON message cannot be decoded.</p>"},{"location":"utilities/error-handling/#unsupportedprotocolerrorprotocol-messagenone","title":"<code>UnsupportedProtocolError(protocol, message=None)</code>","text":"<p>Raised when a requested protocol is not supported.</p> <p>Parameters: - <code>protocol</code> (str): The unsupported protocol name - <code>message</code> (str, optional): Custom error message</p>"},{"location":"utilities/error-handling/#filetransfererrormessagefile-transfer-failed","title":"<code>FileTransferError(message=\"File transfer failed.\")</code>","text":"<p>Raised when file transfer operations fail.</p>"},{"location":"utilities/error-handling/#usage-examples","title":"Usage Examples","text":"<pre><code>from kn_sock import start_tcp_server\nfrom kn_sock.errors import PortInUseError, ConnectionTimeoutError\n\n# Handle port conflicts\ntry:\n    start_tcp_server(8080, handler)\nexcept PortInUseError as e:\n    print(f\"Port conflict: {e}\")\n\n# Handle timeouts\ntry:\n    send_tcp_message(\"localhost\", 8080, \"Hello\")\nexcept ConnectionTimeoutError:\n    print(\"Server is not responding\")\n</code></pre>"},{"location":"utilities/load-balancing/","title":"Load Balancing","text":"<p>Load balancing algorithms for distributing connections across multiple servers.</p>"},{"location":"utilities/load-balancing/#classes","title":"Classes","text":""},{"location":"utilities/load-balancing/#roundrobinloadbalancer","title":"<code>RoundRobinLoadBalancer</code>","text":"<p>Distributes requests in round-robin order.</p> <p>Methods: - <code>add_server(server)</code> - Add a server - <code>remove_server(server)</code> - Remove a server - <code>get_server()</code> - Get next server in rotation</p> <p>Example: <pre><code>from kn_sock.load_balancer import RoundRobinLoadBalancer\n\nlb = RoundRobinLoadBalancer()\nlb.add_server('127.0.0.1:9000')\nlb.add_server('127.0.0.1:9001')\nlb.add_server('127.0.0.1:9002')\n\n# Get servers in rotation\nserver1 = lb.get_server()  # Returns '127.0.0.1:9000'\nserver2 = lb.get_server()  # Returns '127.0.0.1:9001'\nserver3 = lb.get_server()  # Returns '127.0.0.1:9002'\nserver4 = lb.get_server()  # Returns '127.0.0.1:9000' (cycles)\n</code></pre></p>"},{"location":"utilities/load-balancing/#leastconnectionsloadbalancer","title":"<code>LeastConnectionsLoadBalancer</code>","text":"<p>Routes to server with fewest active connections.</p> <p>Methods: - <code>add_server(server)</code> - Add a server - <code>remove_server(server)</code> - Remove a server - <code>update_connections(server, count)</code> - Update connection count - <code>get_server()</code> - Get server with fewest connections</p> <p>Example: <pre><code>from kn_sock.load_balancer import LeastConnectionsLoadBalancer\n\nlb = LeastConnectionsLoadBalancer()\nlb.add_server('127.0.0.1:9000')\nlb.add_server('127.0.0.1:9001')\n\n# Update connection counts\nlb.update_connections('127.0.0.1:9000', 5)\nlb.update_connections('127.0.0.1:9001', 2)\n\nserver = lb.get_server()  # Returns '127.0.0.1:9001' (fewer connections)\n</code></pre></p>"},{"location":"utilities/load-balancing/#usage-with-tcp-servers","title":"Usage with TCP Servers","text":"<pre><code>from kn_sock.load_balancer import RoundRobinLoadBalancer\nimport socket\n\nlb = RoundRobinLoadBalancer()\nlb.add_server('backend1:8080')\nlb.add_server('backend2:8080')\n\ndef forward_request(data, addr, client_socket):\n    # Get next backend server\n    backend = lb.get_server()\n    host, port = backend.split(':')\n\n    # Forward to backend\n    with socket.socket() as backend_sock:\n        backend_sock.connect((host, int(port)))\n        backend_sock.send(data)\n        response = backend_sock.recv(1024)\n        client_socket.send(response)\n</code></pre>"},{"location":"utilities/message-queues/","title":"Message Queues","text":"<p>Thread-safe message queues for buffering and processing messages.</p>"},{"location":"utilities/message-queues/#classes","title":"Classes","text":""},{"location":"utilities/message-queues/#inmemoryqueue","title":"<code>InMemoryQueue</code>","text":"<p>Thread-safe in-memory FIFO queue.</p> <p>Methods: - <code>put(item)</code> - Add item to queue - <code>get(block=True, timeout=None)</code> - Get item from queue - <code>task_done()</code> - Mark task as complete - <code>join()</code> - Wait until all tasks are done - <code>qsize()</code> - Return queue size - <code>empty()</code> - Return True if queue is empty</p> <p>Example: <pre><code>from kn_sock.queue import InMemoryQueue\nimport threading\n\nqueue = InMemoryQueue()\n\n# Producer thread\ndef producer():\n    for i in range(5):\n        queue.put(f\"message-{i}\")\n\n# Consumer thread  \ndef consumer():\n    while True:\n        item = queue.get()\n        print(f\"Processing: {item}\")\n        queue.task_done()\n\nthreading.Thread(target=producer).start()\nthreading.Thread(target=consumer, daemon=True).start()\nqueue.join()  # Wait for all tasks to complete\n</code></pre></p>"},{"location":"utilities/message-queues/#filequeuepath","title":"<code>FileQueue(path)</code>","text":"<p>Persistent file-based queue that survives restarts.</p> <p>Parameters: - <code>path</code> (str): File path for queue storage</p> <p>Methods: - <code>put(item)</code> - Add item to queue (saves to disk) - <code>get(block=True, timeout=None)</code> - Get item from queue - <code>task_done()</code> - Mark task as complete - <code>join()</code> - Wait until all tasks are done - <code>close()</code> - Save queue state and close - <code>qsize()</code> - Return queue size - <code>empty()</code> - Return True if queue is empty</p> <p>Example: <pre><code>from kn_sock.queue import FileQueue\n\n# Create persistent queue\nqueue = FileQueue(\"messages.db\")\n\n# Add messages\nqueue.put(\"message 1\")\nqueue.put(\"message 2\")\n\n# Process messages\ntry:\n    while not queue.empty():\n        item = queue.get(timeout=1)\n        print(f\"Processing: {item}\")\n        queue.task_done()\nexcept:\n    pass\n\nqueue.close()  # Save state\n</code></pre></p>"},{"location":"utilities/message-queues/#usage-with-socket-servers","title":"Usage with Socket Servers","text":"<pre><code>from kn_sock import start_tcp_server\nfrom kn_sock.queue import InMemoryQueue\nimport threading\n\nmessage_queue = InMemoryQueue()\n\ndef message_handler(data, addr, socket):\n    # Add incoming messages to queue\n    message_queue.put((data, addr, socket))\n\ndef message_processor():\n    # Process messages from queue\n    while True:\n        data, addr, socket = message_queue.get()\n\n        # Process the message\n        response = f\"Processed: {data.decode()}\"\n        socket.sendall(response.encode())\n\n        message_queue.task_done()\n\n# Start background processor\nthreading.Thread(target=message_processor, daemon=True).start()\n\n# Start server\nstart_tcp_server(8080, message_handler)\n</code></pre>"},{"location":"utilities/protobuf/","title":"Protocol Buffers","text":"<p>Protocol Buffers (protobuf) serialization utilities.</p> <p>Requirement: <code>pip install protobuf</code></p>"},{"location":"utilities/protobuf/#functions","title":"Functions","text":""},{"location":"utilities/protobuf/#serialize_messagemsg","title":"<code>serialize_message(msg)</code>","text":"<p>Serialize a protobuf message to bytes.</p> <p>Parameters: - <code>msg</code> - Protobuf message instance</p> <p>Returns: bytes - Serialized data</p>"},{"location":"utilities/protobuf/#deserialize_messagedata-schema","title":"<code>deserialize_message(data, schema)</code>","text":"<p>Deserialize bytes to a protobuf message.</p> <p>Parameters: - <code>data</code> (bytes): Serialized protobuf data - <code>schema</code> (Type): Protobuf message class</p> <p>Returns: Protobuf message instance</p>"},{"location":"utilities/protobuf/#usage-example","title":"Usage Example","text":"<pre><code># First, create your protobuf definition (example.proto):\n# syntax = \"proto3\";\n# message Person {\n#   string name = 1;\n#   int32 age = 2;\n# }\n\n# Generate Python classes: protoc --python_out=. example.proto\n\nfrom kn_sock.protobuf import serialize_message, deserialize_message\nfrom example_pb2 import Person\n\n# Create and serialize message\nperson = Person(name=\"Alice\", age=30)\ndata = serialize_message(person)\n\n# Send over network\nsend_tcp_message(\"localhost\", 8080, data)\n\n# Deserialize received data\ndef handler(data, addr, socket):\n    person = deserialize_message(data, Person)\n    print(f\"Received: {person.name}, age {person.age}\")\n</code></pre>"},{"location":"utilities/protobuf/#integration-with-kn-sock","title":"Integration with kn-sock","text":"<pre><code>from kn_sock import start_tcp_server, send_tcp_message\nfrom kn_sock.protobuf import serialize_message, deserialize_message\nfrom my_messages_pb2 import RequestMessage, ResponseMessage\n\ndef protobuf_handler(data, addr, socket):\n    # Deserialize request\n    request = deserialize_message(data, RequestMessage)\n\n    # Process request\n    response = ResponseMessage(\n        id=request.id,\n        result=\"Success\"\n    )\n\n    # Send serialized response\n    response_data = serialize_message(response)\n    socket.sendall(response_data)\n\nstart_tcp_server(8080, protobuf_handler)\n</code></pre>"},{"location":"utilities/utilities/","title":"Utilities","text":"<p>Network and file utilities for socket programming.</p>"},{"location":"utilities/utilities/#network-functions","title":"Network Functions","text":""},{"location":"utilities/utilities/#get_free_port","title":"<code>get_free_port()</code>","text":"<p>Find an available TCP port.</p> <p>Returns: int - Available port number</p> <p>Example: <pre><code>from kn_sock.utils import get_free_port\n\nport = get_free_port()\nstart_tcp_server(port, handler)\n</code></pre></p>"},{"location":"utilities/utilities/#get_local_ip","title":"<code>get_local_ip()</code>","text":"<p>Get the local IP address of the machine.</p> <p>Returns: str - Local IP address</p> <p>Example: <pre><code>from kn_sock.utils import get_local_ip\n\nip = get_local_ip()\nprint(f\"Server running on {ip}:8080\")\n</code></pre></p>"},{"location":"utilities/utilities/#file-functions","title":"File Functions","text":""},{"location":"utilities/utilities/#chunked_file_readerfilepath-chunk_size4096","title":"<code>chunked_file_reader(filepath, chunk_size=4096)</code>","text":"<p>Read file data in chunks for streaming.</p> <p>Parameters: - <code>filepath</code> (str): Path to file - <code>chunk_size</code> (int): Chunk size in bytes (default: 4096)</p> <p>Returns: Generator yielding bytes</p> <p>Example: <pre><code>from kn_sock.utils import chunked_file_reader\n\nfor chunk in chunked_file_reader(\"large_file.bin\"):\n    socket.send(chunk)\n</code></pre></p>"},{"location":"utilities/utilities/#recv_allsocket-total_bytes","title":"<code>recv_all(socket, total_bytes)</code>","text":"<p>Receive exactly the specified number of bytes.</p> <p>Parameters: - <code>socket</code> (socket.socket): Socket to read from - <code>total_bytes</code> (int): Number of bytes to receive</p> <p>Returns: bytes - Received data</p> <p>Example: <pre><code>from kn_sock.utils import recv_all\n\n# Receive file size first (4 bytes)\nsize_data = recv_all(socket, 4)\nfile_size = int.from_bytes(size_data, 'big')\n\n# Receive entire file\nfile_data = recv_all(socket, file_size)\n</code></pre></p>"},{"location":"utilities/utilities/#display-functions","title":"Display Functions","text":""},{"location":"utilities/utilities/#print_progressreceived-total","title":"<code>print_progress(received, total)</code>","text":"<p>Print file transfer progress.</p> <p>Parameters: - <code>received</code> (int): Bytes received so far - <code>total</code> (int): Total bytes expected</p> <p>Example: <pre><code>from kn_sock.utils import print_progress\n\ntotal_size = 1000000\nreceived = 0\n\nwhile received &lt; total_size:\n    chunk = socket.recv(4096)\n    received += len(chunk)\n    print_progress(received, total_size)\n</code></pre></p>"},{"location":"utilities/utilities/#json-functions","title":"JSON Functions","text":""},{"location":"utilities/utilities/#is_valid_jsondata","title":"<code>is_valid_json(data)</code>","text":"<p>Check if string is valid JSON.</p> <p>Parameters: - <code>data</code> (str): String to validate</p> <p>Returns: bool - True if valid JSON</p> <p>Example: <pre><code>from kn_sock.utils import is_valid_json\n\nif is_valid_json(received_data):\n    data = json.loads(received_data)\nelse:\n    print(\"Invalid JSON received\")\n</code></pre></p>"}]}