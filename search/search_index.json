{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kn-sock","title":"kn-sock","text":"<p>A simplified socket programming toolkit for Python.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>TCP/UDP Messaging: Supports both synchronous and asynchronous communication.</li> <li>JSON Socket Communication: Easily send and receive JSON data over sockets.</li> <li>File Transfer over TCP: Transfer files between clients and servers.</li> <li>Threaded/Multi-Client Support: Handle multiple clients concurrently.</li> <li>Command-Line Interface: Simple CLI for quick socket operations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#tcp-messaging","title":"TCP Messaging","text":""},{"location":"#synchronous-tcp-server","title":"Synchronous TCP Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming TCP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"#synchronous-tcp-client","title":"Synchronous TCP Client","text":"<pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#asynchronous-tcp-server","title":"Asynchronous TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_tcp_server\n\nasync def handle_tcp_message(data, addr, writer):\n    \"\"\"\n    Handle incoming TCP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    writer.write(b\"Message received\")\n    await writer.drain()\n\nasyncio.run(start_async_tcp_server(8080, handle_tcp_message))\n</code></pre>"},{"location":"#asynchronous-tcp-client","title":"Asynchronous TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"#secure-tcp-ssltls","title":"Secure TCP (SSL/TLS)","text":"<p><code>kn_sock</code> supports secure TCP communication using SSL/TLS, both in code and via the CLI.</p>"},{"location":"#synchronous-secure-tcp-server","title":"Synchronous Secure TCP Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # Optional, for client cert verification\n    require_client_cert=True  # For mutual TLS\n)\n</code></pre>"},{"location":"#synchronous-secure-tcp-client","title":"Synchronous Secure TCP Client","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\",\n    cafile=\"ca.crt\",  # Optional, for server verification\n    certfile=\"client.crt\", keyfile=\"client.key\"  # For mutual TLS\n)\n</code></pre>"},{"location":"#asynchronous-secure-tcp-server","title":"Asynchronous Secure TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_ssl_tcp_server\n\nasync def handle_secure(data, addr, writer):\n    print(f\"Received from {addr}: {data.decode()}\")\n    writer.write(b\"Secure response\")\n    await writer.drain()\n\nasyncio.run(start_async_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n))\n</code></pre>"},{"location":"#asynchronous-secure-tcp-client","title":"Asynchronous Secure TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_ssl_tcp_message_async\n\nasyncio.run(send_ssl_tcp_message_async(\n    \"localhost\", 8443, \"Hello Secure\"\n))\n</code></pre>"},{"location":"#cli-usage","title":"CLI Usage","text":"<pre><code># Start a secure server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key --cafile ca.crt --require-client-cert\n\n# Send a secure message\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\" --cafile ca.crt --certfile client.crt --keyfile client.key\n</code></pre> <p>Note: You must have valid certificate and key files. For testing, you can generate self-signed certificates using OpenSSL.</p>"},{"location":"#tcp-connection-pooling","title":"TCP Connection Pooling","text":"<p><code>kn_sock</code> provides a TCPConnectionPool for efficient client-side connection reuse. This reduces connection overhead for frequent requests.</p>"},{"location":"#basic-usage-plain-tcp","title":"Basic Usage (Plain TCP)","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool('localhost', 8080, max_size=5, idle_timeout=30)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()  # Clean up all connections\n</code></pre>"},{"location":"#secure-usage-ssltls","title":"Secure Usage (SSL/TLS)","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool(\n    'localhost', 8443, max_size=5, idle_timeout=30,\n    ssl=True, cafile=\"ca.crt\", certfile=\"client.crt\", keyfile=\"client.key\", verify=True\n)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello Secure\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()\n</code></pre> <ul> <li><code>max_size</code>: Maximum number of pooled connections.</li> <li><code>idle_timeout</code>: Seconds before idle connections are closed.</li> <li><code>ssl</code>, <code>cafile</code>, <code>certfile</code>, <code>keyfile</code>, <code>verify</code>: SSL/TLS options.</li> </ul>"},{"location":"#udp-messaging","title":"UDP Messaging","text":""},{"location":"#synchronous-udp-server","title":"Synchronous UDP Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    \"\"\"\n    Handle incoming UDP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        server_socket (socket.socket): The server socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"#synchronous-udp-client","title":"Synchronous UDP Client","text":"<pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#asynchronous-udp-server","title":"Asynchronous UDP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def handle_udp_message(data, addr, transport):\n    \"\"\"\n    Handle incoming UDP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        transport (asyncio.DatagramTransport): The transport object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nasyncio.run(start_udp_server_async(8080, handle_udp_message))\n</code></pre>"},{"location":"#asynchronous-udp-client","title":"Asynchronous UDP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasyncio.run(send_udp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"#json-socket-communication","title":"JSON Socket Communication","text":""},{"location":"#json-server","title":"JSON Server","text":"<pre><code>from kn_sock import start_json_server\n\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n    client_socket.sendall(b'{\"status\": \"received\"}')\n\nstart_json_server(8080, handle_json_message)\n</code></pre>"},{"location":"#json-client","title":"JSON Client","text":"<pre><code>from kn_sock import send_json\n\nsend_json(\"localhost\", 8080, {\"message\": \"Hello, World!\"})\n</code></pre>"},{"location":"#file-transfer-over-tcp","title":"File Transfer over TCP","text":""},{"location":"#file-server","title":"File Server","text":"<pre><code>from kn_sock import start_file_server\n\nstart_file_server(8080, \"/path/to/save/directory\")\n</code></pre>"},{"location":"#file-client","title":"File Client","text":"<pre><code>from kn_sock import send_file\n\nsend_file(\"localhost\", 8080, \"path/to/your/file.txt\")\n</code></pre>"},{"location":"#async-file-transfer","title":"Async File Transfer","text":"<pre><code>from kn_sock import start_file_server_async, send_file_async\nimport asyncio\n\n# Async server\nasyncio.run(start_file_server_async(8080, \"/path/to/save/directory\"))\n\n# Async client\nasyncio.run(send_file_async(\"localhost\", 8080, \"path/to/your/file.txt\"))\n</code></pre>"},{"location":"#live-videoaudio-streaming-multi-video-selection","title":"Live Video/Audio Streaming (Multi-Video Selection)","text":"<p>The <code>kn_sock</code> library supports live video and audio streaming from one or more video files to multiple clients, with adaptive bitrate and smooth playback.</p> <p>Note: For best compatibility, use video files encoded as mp4 (H.264). Some formats (e.g., AV1) may not be supported by your OpenCV/FFmpeg installation.</p>"},{"location":"#features_1","title":"Features","text":"<ul> <li>Multi-Video Support: Server can offer multiple videos; clients select which to play</li> <li>Adaptive Bitrate: Server adjusts video quality per client based on buffer feedback</li> <li>Jitter Buffer: Client-side buffering for smooth video/audio playback</li> <li>Robust Audio Protocol: Audio stream uses magic numbers and timestamps for resynchronization</li> <li>Real-time Feedback: Client sends buffer status to server for quality adjustment</li> </ul>"},{"location":"#live-stream-server-python","title":"Live Stream Server (Python)","text":"<pre><code>from kn_sock import start_live_stream\n\n# Start a live stream server with multiple videos\nstart_live_stream(9000, [\"video1.mp4\", \"video2.mp4\", \"video3.mp4\"])\n\n# Or with a single video\nstart_live_stream(9000, [\"video.mp4\"])\n</code></pre>"},{"location":"#live-stream-client-python","title":"Live Stream Client (Python)","text":"<pre><code>from kn_sock import connect_to_live_server\n\n# Connect to a live stream server\nconnect_to_live_server(\"192.168.1.10\", 9000)\n</code></pre>"},{"location":"#advanced-usage-with-livestreamserverlivestreamclient","title":"Advanced Usage with LiveStreamServer/LiveStreamClient","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer, LiveStreamClient\n\n# Server with custom configuration\nserver = LiveStreamServer(\n    video_paths=[\"video1.mp4\", \"video2.mp4\"],\n    host='0.0.0.0',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010\n)\nserver.start()\n\n# Client with custom buffer settings\nclient = LiveStreamClient(\n    host='127.0.0.1',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010,\n    video_buffer_ms=200,  # 200ms video buffer\n    audio_buffer_ms=100,  # 100ms audio buffer\n    video_fps=30\n)\nclient.start()\n</code></pre>"},{"location":"#live-streaming-via-cli","title":"Live Streaming via CLI","text":"<ul> <li>Start a live stream server with multiple videos:</li> </ul> <pre><code>kn-sock run-live-server 9000 video1.mp4 video2.mp4 video3.mp4\n# Optional: --host 0.0.0.0 --audio-port 9001\n</code></pre> <ul> <li>Connect as a live stream client:</li> </ul> <pre><code>kn-sock connect-live-server 192.168.1.10 9000\n# Optional: --audio-port 9001\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>Server Setup: Server extracts audio from video files using FFmpeg</li> <li>Client Connection: Client connects to video, audio, and control ports</li> <li>Video Selection: If multiple videos are available, client is prompted to select one</li> <li>Streaming: Server streams video frames and audio chunks with timestamps</li> <li>Adaptive Quality: Client sends buffer feedback; server adjusts JPEG quality (40-90)</li> <li>Smooth Playback: Client uses jitter buffers to smooth out network irregularities</li> </ol>"},{"location":"#protocol-details","title":"Protocol Details","text":"<ul> <li>Video Protocol: Each frame is sent as <code>[8-byte timestamp][4-byte length][JPEG data]</code></li> <li>Audio Protocol: Each chunk is sent as <code>[4-byte magic][8-byte timestamp][4-byte length][audio data]</code></li> <li>Control Protocol: Client sends JSON feedback: <code>{\"buffer_level\": 0.2}</code></li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python Dependencies: <code>opencv-python</code>, <code>pyaudio</code>, <code>numpy</code></li> <li>System Dependencies: <code>ffmpeg</code> (for audio extraction)</li> <li>Network: TCP ports for video, audio, and control streams</li> </ul>"},{"location":"#websocket-support","title":"WebSocket Support","text":"<p>kn_sock provides a minimal WebSocket server and client for real-time, bidirectional communication (e.g., chat, dashboards, live updates).</p> <ul> <li>Use <code>start_websocket_server(host, port, handler_func, ...)</code> to start a WebSocket server.</li> <li>Use <code>connect_websocket(host, port, ...)</code> to connect as a client.</li> </ul>"},{"location":"#example-websocket-echo-server","title":"Example: WebSocket Echo Server","text":"<pre><code>from kn_sock import start_websocket_server\nimport threading\n\ndef echo_handler(ws):\n    print(f\"[WebSocket][SERVER] Client connected: {ws.addr}\")\n    try:\n        while ws.open:\n            msg = ws.recv()\n            if not msg:\n                break\n            ws.send(f\"Echo: {msg}\")\n    finally:\n        ws.close()\n\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_websocket_server,\n    args=(\"127.0.0.1\", 8765, echo_handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-websocket-client","title":"Example: WebSocket Client","text":"<pre><code>from kn_sock import connect_websocket\nws = connect_websocket(\"127.0.0.1\", 8765)\nws.send(\"Hello WebSocket!\")\nreply = ws.recv()\nprint(f\"Received: {reply}\")\nws.close()\n</code></pre> <p>Note: This implementation supports text frames only (no binary, no extensions, no SSL for browsers yet). Suitable for Python-to-Python or custom client/server use.</p>"},{"location":"#httphttps-client-support","title":"HTTP/HTTPS Client Support","text":"<p>kn_sock provides simple HTTP and HTTPS client helpers for quick requests without external libraries.</p> <ul> <li><code>http_get(host, port=80, path='/', headers=None)</code></li> <li><code>http_post(host, port=80, path='/', data='', headers=None)</code></li> <li><code>https_get(host, port=443, path='/', headers=None, cafile=None)</code></li> <li><code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code></li> </ul>"},{"location":"#example-http-getpost","title":"Example: HTTP GET/POST","text":"<pre><code>from kn_sock import http_get, http_post\n\nbody = http_get(\"example.com\", 80, \"/\")\nprint(body)\n\nbody = http_post(\"httpbin.org\", 80, \"/post\", data=\"foo=bar&amp;baz=qux\")\nprint(body)\n</code></pre>"},{"location":"#example-https-getpost","title":"Example: HTTPS GET/POST","text":"<pre><code>from kn_sock import https_get, https_post\n\nbody = https_get(\"example.com\", 443, \"/\")\nprint(body)\n\nbody = https_post(\"httpbin.org\", 443, \"/post\", data=\"foo=bar&amp;baz=qux\")\nprint(body)\n</code></pre> <p>Note: These helpers do not support redirects, chunked encoding, or cookies. For advanced HTTP features, use a full HTTP library.</p>"},{"location":"#http-server","title":"HTTP Server","text":"<p>kn_sock provides a minimal HTTP server for serving static files and handling simple API routes.</p> <ul> <li>Use <code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code> to start the server.</li> <li><code>static_dir</code>: Directory to serve files from (e.g., index.html).</li> <li><code>routes</code>: Dict mapping (method, path) to handler functions. Handler signature: (request, client_socket).</li> <li><code>shutdown_event</code>: For graceful shutdown.</li> </ul>"},{"location":"#example-static-file-and-route-handlers","title":"Example: Static File and Route Handlers","text":"<pre><code>from kn_sock import start_http_server\nimport threading\nimport os\n\ndef hello_route(request, client_sock):\n    client_sock.sendall(b\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nHello\")\n\ndef echo_post(request, client_sock):\n    body = request['raw'].split(b'\\r\\n\\r\\n', 1)[-1]\n    resp = b\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: \" + str(len(body)).encode() + b\"\\r\\n\\r\\n\" + body\n    client_sock.sendall(resp)\n\nos.makedirs(\"static\", exist_ok=True)\nwith open(\"static/index.html\", \"w\") as f:\n    f.write(\"&lt;h1&gt;Hello from static file!&lt;/h1&gt;\")\nroutes = {\n    (\"GET\", \"/hello\"): hello_route,\n    (\"POST\", \"/echo\"): echo_post,\n}\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_http_server,\n    args=(\"127.0.0.1\", 8080),\n    kwargs={\"static_dir\": \"static\", \"routes\": routes, \"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre> <p>Note: This server is for prototyping and simple use cases. For production, use a full-featured HTTP server.</p>"},{"location":"#publishsubscribe-pubsub","title":"Publish/Subscribe (Pub/Sub)","text":"<p>kn_sock provides a simple TCP-based pub/sub server and client for topic-based messaging.</p> <ul> <li>Use <code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code> to start the server.</li> <li>Use <code>PubSubClient(host, port)</code> for the client. Methods: <code>subscribe(topic)</code>, <code>unsubscribe(topic)</code>, <code>publish(topic, message)</code>, <code>recv(timeout=None)</code>.</li> </ul>"},{"location":"#example-pubsub-server","title":"Example: Pub/Sub Server","text":"<pre><code>from kn_sock import start_pubsub_server\nimport threading\n\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_pubsub_server,\n    args=(9000,),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-pubsub-client","title":"Example: Pub/Sub Client","text":"<pre><code>from kn_sock import PubSubClient\nclient = PubSubClient(\"127.0.0.1\", 9000)\nclient.subscribe(\"news\")\nclient.publish(\"news\", \"Hello, subscribers!\")\nmsg = client.recv(timeout=2)\nprint(msg)\nclient.close()\n</code></pre> <p>Protocol: All messages are JSON lines. Actions: <code>subscribe</code>, <code>unsubscribe</code>, <code>publish</code>. Server broadcasts published messages to all subscribers of a topic.</p> <p>Use cases: Chat rooms, notifications, real-time data updates, event-driven apps.</p>"},{"location":"#remote-procedure-call-rpc","title":"Remote Procedure Call (RPC)","text":"<p>kn_sock provides a simple TCP-based JSON-RPC server and client for remote function calls.</p> <ul> <li>Use <code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code> to start the server.</li> <li>Use <code>RPCClient(host, port)</code> for the client. Method: <code>call(function, *args, **kwargs)</code>.</li> </ul>"},{"location":"#example-rpc-server","title":"Example: RPC Server","text":"<pre><code>from kn_sock import start_rpc_server\nimport threading\n\ndef add(a, b):\n    return a + b\n\ndef echo(msg):\n    return msg\n\nfuncs = {\"add\": add, \"echo\": echo}\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_rpc_server,\n    args=(9001, funcs),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-rpc-client","title":"Example: RPC Client","text":"<pre><code>from kn_sock import RPCClient\nclient = RPCClient(\"127.0.0.1\", 9001)\nprint(client.call(\"add\", 2, 3))\nprint(client.call(\"echo\", msg=\"Hello!\"))\nclient.close()\n</code></pre> <p>Protocol: All requests and responses are JSON lines. Requests: <code>{method, params, kwargs}</code>. Responses: <code>{result}</code> or <code>{error}</code>.</p> <p>Use cases: Distributed computing, remote control, microservices, automation.</p>"},{"location":"#command-line-interface","title":"Command-Line Interface","text":"<p>The <code>kn-sock</code> library comes with a simple CLI for quick socket operations. You can use the following commands:</p> <ul> <li>Send TCP Message:</li> </ul> <pre><code>kn-sock send-tcp localhost 8080 \"Hello, World!\"\n</code></pre> <ul> <li>Start TCP Server:</li> </ul> <pre><code>kn-sock run-tcp-server 8080\n</code></pre> <ul> <li>Send UDP Message:</li> </ul> <pre><code>kn-sock send-udp localhost 8080 \"Hello, World!\"\n</code></pre> <ul> <li>Start UDP Server:</li> </ul> <pre><code>kn-sock run-udp-server 8080\n</code></pre> <ul> <li>Send File:</li> </ul> <pre><code>kn-sock send-file localhost 8080 path/to/your/file.txt\n</code></pre> <ul> <li>Start File Server:</li> </ul> <pre><code>kn-sock run-file-server 8080 /path/to/save/directory\n</code></pre>"},{"location":"#decorators","title":"Decorators","text":"<p>The <code>.decorators</code> module provides useful decorators to enhance your socket handlers.</p>"},{"location":"#log_exceptions","title":"<code>log_exceptions</code>","text":"<p>Logs exceptions and optionally re-raises them.</p> <pre><code>from kn_sock.decorators import log_exceptions\n\n@log_exceptions(raise_error=True)\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with exception logging.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#retry","title":"<code>retry</code>","text":"<p>Retries a function upon failure, with a delay between attempts.</p> <pre><code>from kn_sock.decorators import retry\n\n@retry(retries=3, delay=1.0, exceptions=(Exception,))\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with retry logic.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#measure_time","title":"<code>measure_time</code>","text":"<p>Measures and prints the execution time of the wrapped function.</p> <pre><code>from kn_sock.decorators import measure_time\n\n@measure_time\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with execution time measurement.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#ensure_json_input","title":"<code>ensure_json_input</code>","text":"<p>Validates that the first argument is a valid JSON object (dict or str). Raises <code>InvalidJSONError</code> otherwise.</p> <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages with input validation.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your JSON message handling code here\n    pass\n</code></pre>"},{"location":"#utilities","title":"Utilities","text":"<p>The <code>.utils</code> module provides various utility functions to assist with socket programming.</p>"},{"location":"#network-utilities","title":"Network Utilities","text":""},{"location":"#get_free_port","title":"<code>get_free_port</code>","text":"<p>Finds a free port for TCP binding (useful for tests).</p> <pre><code>from kn_sock.utils import get_free_port\n\nport = get_free_port()\nprint(f\"Free port: {port}\")\n</code></pre>"},{"location":"#get_local_ip","title":"<code>get_local_ip</code>","text":"<p>Returns the local IP address of the current machine.</p> <pre><code>from kn_sock.utils import get_local_ip\n\nip = get_local_ip()\nprint(f\"Local IP: {ip}\")\n</code></pre>"},{"location":"#file-utilities","title":"File Utilities","text":""},{"location":"#chunked_file_reader","title":"<code>chunked_file_reader</code>","text":"<p>Yields file data in chunks for streaming transfer.</p> <pre><code>from kn_sock.utils import chunked_file_reader\n\nfor chunk in chunked_file_reader(\"path/to/your/file.txt\"):\n    # Process each chunk\n    pass\n</code></pre>"},{"location":"#recv_all","title":"<code>recv_all</code>","text":"<p>Receives exactly <code>total_bytes</code> from a socket.</p> <pre><code>from kn_sock.utils import recv_all\n\ndata = recv_all(client_socket, total_bytes)\n</code></pre>"},{"location":"#progress-display","title":"Progress Display","text":""},{"location":"#print_progress","title":"<code>print_progress</code>","text":"<p>Prints file transfer progress in percentage.</p> <pre><code>from kn_sock.utils import print_progress\n\nprint_progress(received_bytes, total_bytes)\n</code></pre>"},{"location":"#json-utility","title":"JSON Utility","text":""},{"location":"#is_valid_json","title":"<code>is_valid_json</code>","text":"<p>Checks whether a string is valid JSON.</p> <pre><code>from kn_sock.utils import is_valid_json\n\nif is_valid_json(json_string):\n    print(\"Valid JSON\")\nelse:\n    print(\"Invalid JSON\")\n</code></pre>"},{"location":"#errors","title":"Errors","text":"<p>The <code>.errors</code> module defines custom exceptions for the <code>kn_sock</code> library.</p>"},{"location":"#easysocketerror","title":"<code>EasySocketError</code>","text":"<p>Base exception for all <code>kn_sock</code> errors.</p> <pre><code>from kn_sock.errors import EasySocketError\n\ntry:\n    # Your code here\n    pass\nexcept EasySocketError as e:\n    print(f\"EasySocketError: {e}\")\n</code></pre>"},{"location":"#connection-related-errors","title":"Connection-related Errors","text":""},{"location":"#connectiontimeouterror","title":"<code>ConnectionTimeoutError</code>","text":"<p>Raised when a connection or read/write operation times out.</p> <pre><code>from kn_sock.errors import ConnectionTimeoutError\n\ntry:\n    # Your code here\n    pass\nexcept ConnectionTimeoutError as e:\n    print(f\"ConnectionTimeoutError: {e}\")\n</code></pre>"},{"location":"#portinuseerror","title":"<code>PortInUseError</code>","text":"<p>Raised when a specified port is already in use.</p> <pre><code>from kn_sock.errors import PortInUseError\n\ntry:\n    # Your code here\n    pass\nexcept PortInUseError as e:\n    print(f\"PortInUseError: {e}\")\n</code></pre>"},{"location":"#data-protocol-errors","title":"Data &amp; Protocol Errors","text":""},{"location":"#invalidjsonerror","title":"<code>InvalidJSONError</code>","text":"<p>Raised when a JSON message cannot be decoded.</p> <pre><code>from kn_sock.errors import InvalidJSONError\n\ntry:\n    # Your code here\n    pass\nexcept InvalidJSONError as e:\n    print(f\"InvalidJSONError: {e}\")\n</code></pre>"},{"location":"#unsupportedprotocolerror","title":"<code>UnsupportedProtocolError</code>","text":"<p>Raised when a requested protocol is not supported.</p> <pre><code>from kn_sock.errors import UnsupportedProtocolError\n\ntry:\n    # Your code here\n    pass\nexcept UnsupportedProtocolError as e:\n    print(f\"UnsupportedProtocolError: {e}\")\n</code></pre>"},{"location":"#file-transfer-errors","title":"File Transfer Errors","text":""},{"location":"#filetransfererror","title":"<code>FileTransferError</code>","text":"<p>Raised when file transfer fails.</p> <pre><code>from kn_sock.errors import FileTransferError\n\ntry:\n    # Your code here\n    pass\nexcept FileTransferError as e:\n    print(f\"FileTransferError: {e}\")\n</code></pre>"},{"location":"#available-functions","title":"Available Functions","text":"<p>Note: All server functions (TCP, UDP, SSL, async/sync) accept a <code>shutdown_event</code> parameter for graceful shutdown. Use <code>threading.Event</code> for sync servers and <code>asyncio.Event</code> for async servers.</p>"},{"location":"#tcp-functions","title":"TCP Functions","text":"<ul> <li><code>start_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>start_threaded_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_tcp_message(host, port, message)</code></li> <li><code>send_tcp_bytes(host, port, data)</code></li> <li><code>start_async_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_tcp_message_async(host, port, message)</code></li> <li><code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code></li> <li><code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code></li> </ul>"},{"location":"#udp-functions","title":"UDP Functions","text":"<ul> <li><code>start_udp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_udp_message(host, port, message)</code></li> <li><code>start_udp_server_async(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_udp_message_async(host, port, message)</code></li> <li><code>send_udp_multicast(group, port, message, ttl=1)</code></li> <li><code>start_udp_multicast_server(group, port, handler_func, listen_ip='0.0.0.0', shutdown_event=None)</code></li> </ul>"},{"location":"#file-transfer-functions","title":"File Transfer Functions","text":"<ul> <li><code>send_file(host, port, filepath)</code></li> <li><code>start_file_server(port, save_dir, host='0.0.0.0')</code></li> <li><code>send_file_async(host, port, filepath)</code></li> <li><code>start_file_server_async(port, save_dir, host='0.0.0.0')</code></li> </ul>"},{"location":"#json-functions","title":"JSON Functions","text":"<ul> <li><code>start_json_server(port, handler_func, host='0.0.0.0')</code></li> <li><code>send_json(host, port, obj, timeout=5)</code></li> <li><code>start_json_server_async(port, handler_func, host='0.0.0.0')</code></li> <li><code>send_json_async(host, port, obj)</code></li> <li><code>send_json_response(sock, data)</code></li> <li><code>send_json_response_async(writer, data)</code></li> </ul>"},{"location":"#websocket-functions","title":"WebSocket Functions","text":"<ul> <li><code>start_websocket_server(host, port, handler, shutdown_event=None)</code></li> <li><code>connect_websocket(host, port, resource='/', headers=None)</code></li> </ul>"},{"location":"#httphttps-functions","title":"HTTP/HTTPS Functions","text":"<ul> <li><code>http_get(host, port=80, path='/', headers=None)</code></li> <li><code>http_post(host, port=80, path='/', data='', headers=None)</code></li> <li><code>https_get(host, port=443, path='/', headers=None, cafile=None)</code></li> <li><code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code></li> <li><code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code></li> </ul>"},{"location":"#pubsub-functions","title":"Pub/Sub Functions","text":"<ul> <li><code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>PubSubClient(host, port)</code></li> </ul>"},{"location":"#rpc-functions","title":"RPC Functions","text":"<ul> <li><code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>RPCClient(host, port)</code></li> </ul>"},{"location":"#live-streaming-functions","title":"Live Streaming Functions","text":"<ul> <li><code>start_live_stream(port, video_paths, host='0.0.0.0', audio_port=None)</code></li> <li><code>connect_to_live_server(ip, port, audio_port=None)</code></li> </ul>"},{"location":"#real-world-examples","title":"Real World Examples","text":"<p>Explore ready-to-run scripts that solve common networking problems using kn-sock:</p> <ul> <li>IoT Protocol: Custom JSON protocol for IoT devices</li> <li>File Transfer: Secure file transfer between machines</li> <li>Chat Application: Real-time chat using WebSockets</li> <li>Microservice RPC: Remote procedure calls between services</li> <li>Remote Control: Remote monitoring and control of applications</li> <li>HTTP API Server: Serve static files and simple APIs</li> <li>Live Streaming: Live video/audio streaming</li> <li>Test Utilities: Network test and utility scripts</li> </ul> <p>See the Real World Examples directory for all scripts and details.</p>"}]}