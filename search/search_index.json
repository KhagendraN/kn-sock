{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kn-sock","title":"kn-sock","text":"<p>A simplified socket programming toolkit for Python that makes network communication easy and efficient.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>TCP/UDP Messaging: Supports both synchronous and asynchronous communication</li> <li>Secure Communication: SSL/TLS support for encrypted connections</li> <li>JSON Socket Communication: Easily send and receive JSON data over sockets</li> <li>File Transfer: Transfer files between clients and servers with progress tracking</li> <li>Live Streaming: Multi-video streaming with adaptive bitrate</li> <li>Video Chat: Real-time multi-client video chat with voice</li> <li>WebSocket Support: Full WebSocket server and client implementation</li> <li>HTTP/HTTPS: Simple HTTP client and server helpers</li> <li>Pub/Sub &amp; RPC: Publish/subscribe messaging and remote procedure calls</li> <li>Message Queuing: Advanced queue management for reliable message delivery</li> <li>Load Balancing: Distribute connections across multiple servers</li> <li>Data Compression: Built-in compression for bandwidth optimization</li> <li>Protocol Buffers: Support for efficient binary serialization</li> <li>Decorators &amp; Utilities: Helper decorators and utility functions</li> <li>Docker Support: Ready-to-use Docker containers and compose files</li> <li>Interactive CLI: Real-time interactive command-line interface</li> <li>Command-Line Interface: Simple CLI for quick socket operations</li> <li>Connection Pooling: Efficient connection reuse for high-performance applications</li> <li>Network Visibility: ARP scanning, MAC lookup, and DNS monitoring tools</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example to get you started:</p> <pre><code># Server\nfrom kn_sock import start_tcp_server\n\ndef handle_message(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received!\")\n\nstart_tcp_server(8080, handle_message)\n</code></pre> <pre><code># Client\nfrom kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#docker-quick-start","title":"Docker Quick Start","text":"<pre><code># Run with Docker Compose\ndocker-compose run knsock --help\n\n# Run tests\ndocker-compose run test\n</code></pre> <p>For detailed Docker usage, see the Docker guide.</p>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li>Getting Started - Learn the basics and set up your first project</li> <li>Docker Setup - Get started with Docker containers and deployment</li> </ul>"},{"location":"#protocol-documentation","title":"Protocol Documentation","text":"<ul> <li>TCP Protocol - Reliable connection-based communication</li> <li>UDP Protocol - Fast connectionless messaging</li> <li>WebSocket Protocol - Real-time bidirectional communication</li> <li>JSON Communication - Structured data exchange</li> <li>File Transfer - Efficient file sharing</li> <li>Secure TCP (SSL/TLS) - Encrypted communication</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>Pub/Sub Messaging - Event-driven messaging patterns</li> <li>Remote Procedure Calls - Call remote functions seamlessly</li> <li>Live Streaming - Multi-video streaming with adaptive bitrate</li> <li>Video Chat - Real-time video conferencing</li> <li>HTTP/HTTPS - Web server and client functionality</li> </ul>"},{"location":"#reference-examples","title":"Reference &amp; Examples","text":"<ul> <li>API Reference - Complete function and class documentation</li> <li>CLI Guide - Command-line interface usage</li> <li>Examples - Real-world usage examples</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#network-visibility-tools","title":"Network Visibility Tools","text":"<p>\u26a0\ufe0f ETHICAL WARNING: These tools are intended for use in authorized networks such as schools, labs, or controlled IT environments. Monitoring user traffic may be illegal without explicit consent. Use responsibly and ethically.</p>"},{"location":"#network-monitoring","title":"Network Monitoring","text":"<ul> <li>ARP Scanning - Discover active devices on your network</li> <li>MAC Address Lookup - Identify device vendors by MAC address</li> <li>DNS Monitoring - Monitor and analyze DNS requests</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Check out our comprehensive examples and real-world applications:</p>"},{"location":"#basic-examples","title":"Basic Examples","text":"<ul> <li>Basic Examples - Simple server/client implementations</li> <li>Protocol Examples - TCP, UDP, WebSocket, and more implementations</li> </ul>"},{"location":"#real-world-applications","title":"Real-world Applications","text":"<ul> <li>Real-world Examples - Complete applications and use cases:</li> <li>Chat applications with multiple protocols</li> <li>File transfer systems with progress tracking</li> <li>IoT device communication networks</li> <li>Microservice architectures with RPC</li> <li>Live streaming platforms with adaptive quality</li> <li>Video conferencing solutions with multi-client support</li> <li>Pub/Sub messaging systems for event processing</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page provides a comprehensive reference for all public functions and classes in kn-sock.</p>"},{"location":"api-reference/#tcp-functions","title":"TCP Functions","text":""},{"location":"api-reference/#server-functions","title":"Server Functions","text":""},{"location":"api-reference/#start_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a synchronous TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each client (data, addr, client_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_threaded_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_threaded_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a threaded TCP server for handling multiple clients concurrently.</p> <p>Parameters: Same as <code>start_tcp_server</code></p> <p>Returns: None</p>"},{"location":"api-reference/#start_async_tcp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_async_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (async callable): Async function called for each client (data, addr, writer). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (asyncio.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions","title":"Client Functions","text":""},{"location":"api-reference/#send_tcp_messagehost-port-message","title":"<code>send_tcp_message(host, port, message)</code>","text":"<p>Send a string message over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_tcp_byteshost-port-data","title":"<code>send_tcp_bytes(host, port, data)</code>","text":"<p>Send raw bytes over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>data</code> (bytes): Data to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_tcp_message_asynchost-port-message","title":"<code>send_tcp_message_async(host, port, message)</code>","text":"<p>Send a string message over TCP asynchronously.</p> <p>Parameters: Same as <code>send_tcp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#secure-tcp-ssltls-functions","title":"Secure TCP (SSL/TLS) Functions","text":""},{"location":"api-reference/#server-functions_1","title":"Server Functions","text":""},{"location":"api-reference/#start_ssl_tcp_serverport-handler_func-certfile-keyfile-cafilenone-require_client_certfalse-host0000-shutdown_eventnone","title":"<code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a secure SSL/TLS TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each client (data, addr, client_socket). - <code>certfile</code> (str): Path to server certificate (PEM). - <code>keyfile</code> (str): Path to private key (PEM). - <code>cafile</code> (str, optional): CA cert for client verification. - <code>require_client_cert</code> (bool): Require client cert (mutual TLS). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_async_ssl_tcp_serverport-handler_func-certfile-keyfile-cafilenone-require_client_certfalse-host0000-shutdown_eventnone","title":"<code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async secure SSL/TLS TCP server.</p> <p>Parameters: Same as <code>start_ssl_tcp_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_1","title":"Client Functions","text":""},{"location":"api-reference/#send_ssl_tcp_messagehost-port-message-cafilenone-certfilenone-keyfilenone-verifytrue","title":"<code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Send a message over SSL/TLS TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send. - <code>cafile</code> (str, optional): CA cert for server verification. - <code>certfile</code> (str, optional): Client certificate. - <code>keyfile</code> (str, optional): Client private key. - <code>verify</code> (bool): Verify server cert (default: True).</p> <p>Returns: None</p>"},{"location":"api-reference/#send_ssl_tcp_message_asynchost-port-message-cafilenone-certfilenone-keyfilenone-verifytrue","title":"<code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Send a message over SSL/TLS TCP asynchronously.</p> <p>Parameters: Same as <code>send_ssl_tcp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#udp-functions","title":"UDP Functions","text":""},{"location":"api-reference/#server-functions_2","title":"Server Functions","text":""},{"location":"api-reference/#start_udp_serverport-handler_func-host0000-shutdown_eventnone","title":"<code>start_udp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a synchronous UDP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message (data, addr, server_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_udp_server_asyncport-handler_func-host0000-shutdown_eventnone","title":"<code>start_udp_server_async(port, handler_func, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an async UDP server.</p> <p>Parameters: Same as <code>start_udp_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_2","title":"Client Functions","text":""},{"location":"api-reference/#send_udp_messagehost-port-message","title":"<code>send_udp_message(host, port, message)</code>","text":"<p>Send a string message over UDP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_udp_message_asynchost-port-message","title":"<code>send_udp_message_async(host, port, message)</code>","text":"<p>Send a string message over UDP asynchronously.</p> <p>Parameters: Same as <code>send_udp_message</code></p> <p>Returns: None</p>"},{"location":"api-reference/#send_udp_multicastgroup-port-message-ttl1","title":"<code>send_udp_multicast(group, port, message, ttl=1)</code>","text":"<p>Send a message to a UDP multicast group.</p> <p>Parameters: - <code>group</code> (str): Multicast group address. - <code>port</code> (int): Target port. - <code>message</code> (str): Message to send. - <code>ttl</code> (int): Time-to-live for multicast packets.</p> <p>Returns: None</p>"},{"location":"api-reference/#start_udp_multicast_servergroup-port-handler_func-listen_ip0000-shutdown_eventnone","title":"<code>start_udp_multicast_server(group, port, handler_func, listen_ip='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a UDP multicast server.</p> <p>Parameters: - <code>group</code> (str): Multicast group address. - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message. - <code>listen_ip</code> (str): IP to listen on for multicast. - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#file-transfer-functions","title":"File Transfer Functions","text":""},{"location":"api-reference/#server-functions_3","title":"Server Functions","text":""},{"location":"api-reference/#start_file_serverport-save_dir-host0000","title":"<code>start_file_server(port, save_dir, host='0.0.0.0')</code>","text":"<p>Start a TCP file receiver.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>save_dir</code> (str): Directory to save received files. - <code>host</code> (str): Host to bind (default: '0.0.0.0').</p> <p>Returns: None</p>"},{"location":"api-reference/#start_file_server_asyncport-save_dir-host0000","title":"<code>start_file_server_async(port, save_dir, host='0.0.0.0')</code>","text":"<p>Start an async TCP file receiver.</p> <p>Parameters: Same as <code>start_file_server</code></p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_3","title":"Client Functions","text":""},{"location":"api-reference/#send_filehost-port-filepath-show_progresstrue-progress_callbacknone","title":"<code>send_file(host, port, filepath, show_progress=True, progress_callback=None)</code>","text":"<p>Send a file over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>filepath</code> (str): Path to file to send. - <code>show_progress</code> (bool): Show progress bar (default: True). - <code>progress_callback</code> (callable, optional): Custom progress function.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_file_asynchost-port-filepath","title":"<code>send_file_async(host, port, filepath)</code>","text":"<p>Send a file over TCP asynchronously.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>filepath</code> (str): Path to file to send.</p> <p>Returns: None</p>"},{"location":"api-reference/#json-socket-functions","title":"JSON Socket Functions","text":""},{"location":"api-reference/#server-functions_4","title":"Server Functions","text":""},{"location":"api-reference/#start_json_serverport-handler_func-host0000","title":"<code>start_json_server(port, handler_func, host='0.0.0.0')</code>","text":"<p>Start a JSON-over-TCP server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable): Function called for each message (data: dict, addr, client_socket). - <code>host</code> (str): Host to bind (default: '0.0.0.0').</p> <p>Returns: None</p>"},{"location":"api-reference/#start_json_server_asyncport-handler_func-host0000","title":"<code>start_json_server_async(port, handler_func, host='0.0.0.0')</code>","text":"<p>Start an async JSON-over-TCP server.</p> <p>Parameters: Same as <code>start_json_server</code> but handler is async.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_4","title":"Client Functions","text":""},{"location":"api-reference/#send_jsonhost-port-obj-timeout5","title":"<code>send_json(host, port, obj, timeout=5)</code>","text":"<p>Send a JSON object over TCP.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>obj</code> (dict): JSON-serializable object. - <code>timeout</code> (int): Timeout in seconds.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_json_asynchost-port-obj","title":"<code>send_json_async(host, port, obj)</code>","text":"<p>Send a JSON object over TCP asynchronously.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port. - <code>obj</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#response-helpers","title":"Response Helpers","text":""},{"location":"api-reference/#send_json_responsesock-data","title":"<code>send_json_response(sock, data)</code>","text":"<p>Send a JSON response to a client.</p> <p>Parameters: - <code>sock</code> (socket.socket): Client socket. - <code>data</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#send_json_response_asyncwriter-data","title":"<code>send_json_response_async(writer, data)</code>","text":"<p>Send a JSON response to a client asynchronously.</p> <p>Parameters: - <code>writer</code> (asyncio.StreamWriter): Writer object. - <code>data</code> (dict): JSON-serializable object.</p> <p>Returns: None</p>"},{"location":"api-reference/#websocket-functions","title":"WebSocket Functions","text":""},{"location":"api-reference/#server-functions_5","title":"Server Functions","text":""},{"location":"api-reference/#start_websocket_serverhost-port-handler-shutdown_eventnone","title":"<code>start_websocket_server(host, port, handler, shutdown_event=None)</code>","text":"<p>Start a WebSocket server.</p> <p>Parameters: - <code>host</code> (str): Host to bind. - <code>port</code> (int): Port to bind. - <code>handler</code> (callable): Function called for each client (ws). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_5","title":"Client Functions","text":""},{"location":"api-reference/#connect_websockethost-port-resource-headersnone","title":"<code>connect_websocket(host, port, resource='/', headers=None)</code>","text":"<p>Connect to a WebSocket server.</p> <p>Parameters: - <code>host</code> (str): Server host. - <code>port</code> (int): Server port. - <code>resource</code> (str): WebSocket resource path. - <code>headers</code> (dict, optional): Extra headers.</p> <p>Returns: WebSocket client object</p>"},{"location":"api-reference/#async_connect_websockethost-port-resource-headersnone","title":"<code>async_connect_websocket(host, port, resource='/', headers=None)</code>","text":"<p>Connect to a WebSocket server asynchronously.</p> <p>Parameters: Same as <code>connect_websocket</code></p> <p>Returns: AsyncWebSocketConnection</p>"},{"location":"api-reference/#httphttps-functions","title":"HTTP/HTTPS Functions","text":""},{"location":"api-reference/#client-functions_6","title":"Client Functions","text":""},{"location":"api-reference/#http_gethost-port80-path-headersnone","title":"<code>http_get(host, port=80, path='/', headers=None)</code>","text":"<p>Send an HTTP GET request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 80). - <code>path</code> (str): URL path. - <code>headers</code> (dict): HTTP headers.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#http_posthost-port80-path-data-headersnone","title":"<code>http_post(host, port=80, path='/', data='', headers=None)</code>","text":"<p>Send an HTTP POST request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 80). - <code>path</code> (str): URL path. - <code>data</code> (str): POST data. - <code>headers</code> (dict): HTTP headers.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#https_gethost-port443-path-headersnone-cafilenone","title":"<code>https_get(host, port=443, path='/', headers=None, cafile=None)</code>","text":"<p>Send an HTTPS GET request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 443). - <code>path</code> (str): URL path. - <code>headers</code> (dict): HTTP headers. - <code>cafile</code> (str): CA cert for verification.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#https_posthost-port443-path-data-headersnone-cafilenone","title":"<code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code>","text":"<p>Send an HTTPS POST request.</p> <p>Parameters: - <code>host</code> (str): Target host. - <code>port</code> (int): Target port (default: 443). - <code>path</code> (str): URL path. - <code>data</code> (str): POST data. - <code>headers</code> (dict): HTTP headers. - <code>cafile</code> (str): CA cert for verification.</p> <p>Returns: Response body (str)</p>"},{"location":"api-reference/#server-functions_6","title":"Server Functions","text":""},{"location":"api-reference/#start_http_serverhost-port-static_dirnone-routesnone-shutdown_eventnone","title":"<code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code>","text":"<p>Start an HTTP server.</p> <p>Parameters: - <code>host</code> (str): Host to bind. - <code>port</code> (int): Port to bind. - <code>static_dir</code> (str, optional): Directory to serve files from. - <code>routes</code> (dict, optional): Dict mapping (method, path) to handler functions. - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#pubsub-functions","title":"Pub/Sub Functions","text":""},{"location":"api-reference/#server-functions_7","title":"Server Functions","text":""},{"location":"api-reference/#start_pubsub_serverport-handler_funcnone-host0000-shutdown_eventnone","title":"<code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start a pub/sub server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>handler_func</code> (callable, optional): Custom handler. - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-class","title":"Client Class","text":""},{"location":"api-reference/#pubsubclienthost-port","title":"<code>PubSubClient(host, port)</code>","text":"<p>Pub/sub client class.</p> <p>Methods: - <code>subscribe(topic)</code>: Subscribe to a topic. - <code>unsubscribe(topic)</code>: Unsubscribe from a topic. - <code>publish(topic, message)</code>: Publish a message to a topic. - <code>recv(timeout=None)</code>: Receive a message. - <code>close()</code>: Close the connection.</p>"},{"location":"api-reference/#rpc-functions","title":"RPC Functions","text":""},{"location":"api-reference/#server-functions_8","title":"Server Functions","text":""},{"location":"api-reference/#start_rpc_serverport-register_funcs-host0000-shutdown_eventnone","title":"<code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code>","text":"<p>Start an RPC server.</p> <p>Parameters: - <code>port</code> (int): Port to bind. - <code>register_funcs</code> (dict): Function name to callable mapping. - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>shutdown_event</code> (threading.Event, optional): For graceful shutdown.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-class_1","title":"Client Class","text":""},{"location":"api-reference/#rpcclienthost-port","title":"<code>RPCClient(host, port)</code>","text":"<p>RPC client class.</p> <p>Methods: - <code>call(function, *args, **kwargs)</code>: Call a remote function. - <code>close()</code>: Close the connection.</p>"},{"location":"api-reference/#live-streaming-functions","title":"Live Streaming Functions","text":""},{"location":"api-reference/#server-functions_9","title":"Server Functions","text":""},{"location":"api-reference/#start_live_streamport-video_paths-host0000-audio_portnone","title":"<code>start_live_stream(port, video_paths, host='0.0.0.0', audio_port=None)</code>","text":"<p>Start a live video/audio stream server.</p> <p>Parameters: - <code>port</code> (int): Video port. - <code>video_paths</code> (list of str): Video file paths. - <code>host</code> (str): Host to bind (default: '0.0.0.0'). - <code>audio_port</code> (int, optional): Audio port.</p> <p>Returns: None</p>"},{"location":"api-reference/#client-functions_7","title":"Client Functions","text":""},{"location":"api-reference/#connect_to_live_serverip-port-audio_portnone","title":"<code>connect_to_live_server(ip, port, audio_port=None)</code>","text":"<p>Connect to a live stream server.</p> <p>Parameters: - <code>ip</code> (str): Server IP. - <code>port</code> (int): Video port. - <code>audio_port</code> (int, optional): Audio port.</p> <p>Returns: None</p>"},{"location":"api-reference/#classes","title":"Classes","text":""},{"location":"api-reference/#livestreamservervideo_paths-host0000-video_port9000-audio_port9001-control_port9010","title":"<code>LiveStreamServer(video_paths, host='0.0.0.0', video_port=9000, audio_port=9001, control_port=9010)</code>","text":"<p>Live stream server class.</p> <p>Methods: - <code>start()</code>: Start the server.</p>"},{"location":"api-reference/#livestreamclienthost-video_port9000-audio_port9001-control_port9010-video_buffer_ms200-audio_buffer_ms100-video_fps30","title":"<code>LiveStreamClient(host, video_port=9000, audio_port=9001, control_port=9010, video_buffer_ms=200, audio_buffer_ms=100, video_fps=30)</code>","text":"<p>Live stream client class.</p> <p>Methods: - <code>start()</code>: Start the client.</p>"},{"location":"api-reference/#video-chat-functions","title":"Video Chat Functions","text":""},{"location":"api-reference/#classes_1","title":"Classes","text":""},{"location":"api-reference/#videochatserverhost0000-video_port9000-audio_port9001-text_port9002","title":"<code>VideoChatServer(host='0.0.0.0', video_port=9000, audio_port=9001, text_port=9002)</code>","text":"<p>Multi-client video chat server class.</p> <p>Methods: - <code>start()</code>: Start the server.</p>"},{"location":"api-reference/#videochatclientserver_ip-video_port9000-audio_port9001-text_port9002-roomdefault-nicknameuser","title":"<code>VideoChatClient(server_ip, video_port=9000, audio_port=9001, text_port=9002, room='default', nickname='user')</code>","text":"<p>Video chat client class.</p> <p>Methods: - <code>start()</code>: Start the client. - <code>send_message(message)</code>: Send a text message. - <code>mute()</code>: Mute microphone. - <code>unmute()</code>: Unmute microphone. - <code>toggle_video()</code>: Toggle video on/off.</p>"},{"location":"api-reference/#connection-pooling","title":"Connection Pooling","text":""},{"location":"api-reference/#classes_2","title":"Classes","text":""},{"location":"api-reference/#tcpconnectionpoolhost-port-max_size10-idle_timeout60-sslfalse-ssl_kwargs","title":"<code>TCPConnectionPool(host, port, max_size=10, idle_timeout=60, ssl=False, **ssl_kwargs)</code>","text":"<p>TCP connection pool for efficient connection reuse.</p> <p>Methods: - <code>connection()</code>: Get a connection from the pool. - <code>closeall()</code>: Close all connections in the pool.</p>"},{"location":"api-reference/#utilities","title":"Utilities","text":""},{"location":"api-reference/#network-utilities","title":"Network Utilities","text":""},{"location":"api-reference/#get_free_port","title":"<code>get_free_port()</code>","text":"<p>Find a free TCP port.</p> <p>Returns: int</p>"},{"location":"api-reference/#get_local_ip","title":"<code>get_local_ip()</code>","text":"<p>Get the local IP address.</p> <p>Returns: str</p>"},{"location":"api-reference/#file-utilities","title":"File Utilities","text":""},{"location":"api-reference/#chunked_file_readerfilepath-chunk_size4096","title":"<code>chunked_file_reader(filepath, chunk_size=4096)</code>","text":"<p>Yield file data in chunks.</p> <p>Parameters: - <code>filepath</code> (str): Path to file. - <code>chunk_size</code> (int): Bytes per chunk.</p> <p>Returns: Iterator[bytes]</p>"},{"location":"api-reference/#recv_allsock-total_bytes","title":"<code>recv_all(sock, total_bytes)</code>","text":"<p>Receive exactly <code>total_bytes</code> from a socket.</p> <p>Parameters: - <code>sock</code> (socket.socket): Socket. - <code>total_bytes</code> (int): Number of bytes to receive.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#progress-display","title":"Progress Display","text":""},{"location":"api-reference/#print_progressreceived_bytes-total_bytes","title":"<code>print_progress(received_bytes, total_bytes)</code>","text":"<p>Print file transfer progress.</p> <p>Parameters: - <code>received_bytes</code> (int): Bytes received. - <code>total_bytes</code> (int): Total bytes.</p> <p>Returns: None</p>"},{"location":"api-reference/#json-utility","title":"JSON Utility","text":""},{"location":"api-reference/#is_valid_jsonjson_string","title":"<code>is_valid_json(json_string)</code>","text":"<p>Check if a string is valid JSON.</p> <p>Parameters: - <code>json_string</code> (str): String to check.</p> <p>Returns: bool</p>"},{"location":"api-reference/#decorators","title":"Decorators","text":""},{"location":"api-reference/#log_exceptionsraise_errorfalse","title":"<code>log_exceptions(raise_error=False)</code>","text":"<p>Logs exceptions and optionally re-raises them.</p> <p>Parameters: - <code>raise_error</code> (bool): Whether to re-raise the exception.</p>"},{"location":"api-reference/#retryretries3-delay10-exceptionsexception","title":"<code>retry(retries=3, delay=1.0, exceptions=(Exception,))</code>","text":"<p>Retries a function upon failure.</p> <p>Parameters: - <code>retries</code> (int): Number of retry attempts. - <code>delay</code> (float): Delay between attempts in seconds. - <code>exceptions</code> (tuple): Exception types to catch.</p>"},{"location":"api-reference/#measure_time","title":"<code>measure_time</code>","text":"<p>Measures and prints the execution time of the wrapped function.</p>"},{"location":"api-reference/#ensure_json_input","title":"<code>ensure_json_input</code>","text":"<p>Validates that the first argument is a valid JSON object.</p>"},{"location":"api-reference/#errors","title":"Errors","text":""},{"location":"api-reference/#base-exception","title":"Base Exception","text":""},{"location":"api-reference/#easysocketerror","title":"<code>EasySocketError</code>","text":"<p>Base exception for all kn_sock errors.</p>"},{"location":"api-reference/#connection-errors","title":"Connection Errors","text":""},{"location":"api-reference/#connectiontimeouterror","title":"<code>ConnectionTimeoutError</code>","text":"<p>Raised when a connection or read/write operation times out.</p>"},{"location":"api-reference/#portinuseerror","title":"<code>PortInUseError</code>","text":"<p>Raised when a specified port is already in use.</p>"},{"location":"api-reference/#data-protocol-errors","title":"Data &amp; Protocol Errors","text":""},{"location":"api-reference/#invalidjsonerror","title":"<code>InvalidJSONError</code>","text":"<p>Raised when a JSON message cannot be decoded.</p>"},{"location":"api-reference/#unsupportedprotocolerror","title":"<code>UnsupportedProtocolError</code>","text":"<p>Raised when a requested protocol is not supported.</p>"},{"location":"api-reference/#file-transfer-errors","title":"File Transfer Errors","text":""},{"location":"api-reference/#filetransfererror","title":"<code>FileTransferError</code>","text":"<p>Raised when file transfer fails.</p>"},{"location":"api-reference/#compression","title":"Compression","text":""},{"location":"api-reference/#functions","title":"Functions","text":""},{"location":"api-reference/#compress_datadata-methodgzip","title":"<code>compress_data(data, method='gzip')</code>","text":"<p>Compress data using gzip or deflate.</p> <p>Parameters: - <code>data</code> (bytes): Data to compress. - <code>method</code> (str): Compression method ('gzip' or 'deflate').</p> <p>Returns: bytes</p>"},{"location":"api-reference/#decompress_datadata","title":"<code>decompress_data(data)</code>","text":"<p>Decompress data (auto-detects gzip/deflate).</p> <p>Parameters: - <code>data</code> (bytes): Compressed data.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#detect_compressiondata","title":"<code>detect_compression(data)</code>","text":"<p>Detect compression type.</p> <p>Parameters: - <code>data</code> (bytes): Data to analyze.</p> <p>Returns: str ('gzip', 'deflate', or 'none')</p>"},{"location":"api-reference/#message-queues","title":"Message Queues","text":""},{"location":"api-reference/#classes_3","title":"Classes","text":""},{"location":"api-reference/#inmemoryqueue","title":"<code>InMemoryQueue()</code>","text":"<p>Thread-safe FIFO queue for fast, in-memory message passing.</p> <p>Methods: - <code>put(item)</code>: Add item to queue. - <code>get()</code>: Get item from queue. - <code>task_done()</code>: Mark task as done. - <code>join()</code>: Wait for all tasks to complete. - <code>empty()</code>: Check if queue is empty. - <code>qsize()</code>: Get queue size.</p>"},{"location":"api-reference/#filequeuefilename","title":"<code>FileQueue(filename)</code>","text":"<p>Persistent queue that stores messages on disk.</p> <p>Methods: Same as InMemoryQueue plus: - <code>close()</code>: Close the queue.</p>"},{"location":"api-reference/#protocol-buffers","title":"Protocol Buffers","text":""},{"location":"api-reference/#functions_1","title":"Functions","text":""},{"location":"api-reference/#serialize_messagemsg","title":"<code>serialize_message(msg)</code>","text":"<p>Serialize a protobuf message to bytes.</p> <p>Parameters: - <code>msg</code>: Protobuf message object.</p> <p>Returns: bytes</p>"},{"location":"api-reference/#deserialize_messagedata-schema","title":"<code>deserialize_message(data, schema)</code>","text":"<p>Deserialize bytes to a protobuf message.</p> <p>Parameters: - <code>data</code> (bytes): Serialized data. - <code>schema</code>: Protobuf message class.</p> <p>Returns: Protobuf message object</p>"},{"location":"api-reference/#load-balancing","title":"Load Balancing","text":""},{"location":"api-reference/#classes_4","title":"Classes","text":""},{"location":"api-reference/#roundrobinloadbalancer","title":"<code>RoundRobinLoadBalancer()</code>","text":"<p>Cycles through servers in order.</p> <p>Methods: - <code>add_server(server)</code>: Add a server. - <code>remove_server(server)</code>: Remove a server. - <code>get_server()</code>: Get next server in round-robin order.</p>"},{"location":"api-reference/#leastconnectionsloadbalancer","title":"<code>LeastConnectionsLoadBalancer()</code>","text":"<p>Selects server with fewest active connections.</p> <p>Methods: Same as RoundRobinLoadBalancer plus: - <code>update_connections(server, count)</code>: Update connection count for server.</p>"},{"location":"api-reference/#interactive-cli","title":"Interactive CLI","text":""},{"location":"api-reference/#functions_2","title":"Functions","text":""},{"location":"api-reference/#start_interactive_cli","title":"<code>start_interactive_cli()</code>","text":"<p>Start the interactive command-line interface.</p> <p>Returns: None</p>"},{"location":"api-reference/#commands","title":"Commands","text":"<ul> <li><code>connect &lt;name&gt; &lt;host&gt; &lt;port&gt;</code>: Connect to a server</li> <li><code>list</code>: List all active connections</li> <li><code>select &lt;name&gt;</code>: Set default connection</li> <li><code>send &lt;message&gt;</code>: Send a message</li> <li><code>receive</code>: Receive a message</li> <li><code>bg_receive</code>: Toggle background receive mode</li> <li><code>history</code>: Show message history</li> <li><code>disconnect &lt;name&gt;</code>: Disconnect a connection</li> <li><code>quit</code>/<code>exit</code>: Exit the CLI</li> <li><code>help</code>: Show help</li> </ul>"},{"location":"api-reference/#network-visibility-functions","title":"Network Visibility Functions","text":"<p>\u26a0\ufe0f ETHICAL WARNING: These functions are intended for use in authorized networks such as schools, labs, or controlled IT environments. Monitoring user traffic may be illegal without explicit consent. Use responsibly and ethically.</p>"},{"location":"api-reference/#arp-scanning-functions","title":"ARP Scanning Functions","text":""},{"location":"api-reference/#arp_scannetwork_range-interfacenone-timeout2-verbosefalse","title":"<code>arp_scan(network_range, interface=None, timeout=2, verbose=False)</code>","text":"<p>Perform ARP scan on a network range to discover active devices.</p> <p>Parameters: - <code>network_range</code> (str): Network range to scan (e.g., \"192.168.1.0/24\") - <code>interface</code> (str, optional): Network interface to use (auto-detect if None) - <code>timeout</code> (int): Timeout in seconds for each ARP request (default: 2) - <code>verbose</code> (bool): Enable verbose logging (default: False)</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of dictionaries containing IP and MAC addresses of discovered devices</p> <p>Raises: - <code>ImportError</code>: If scapy is not available - <code>ValueError</code>: If network range is invalid - <code>RuntimeError</code>: If scanning fails</p> <p>Example: <pre><code>from kn_sock.network import arp_scan\n\ndevices = arp_scan(\"192.168.1.0/24\", verbose=True)\nfor device in devices:\n    print(f\"IP: {device['ip']}, MAC: {device['mac']}\")\n</code></pre></p>"},{"location":"api-reference/#arp_scan_simpleip_range","title":"<code>arp_scan_simple(ip_range)</code>","text":"<p>Simple ARP scan that returns IP and MAC pairs.</p> <p>Parameters: - <code>ip_range</code> (str): IP range to scan (e.g., \"192.168.1.0/24\")</p> <p>Returns: - <code>List[Tuple[str, str]]</code>: List of tuples containing (IP, MAC) pairs</p>"},{"location":"api-reference/#get_local_network_info","title":"<code>get_local_network_info()</code>","text":"<p>Get information about the local network.</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing network information (local_ip, interface, gateway)</p>"},{"location":"api-reference/#mac-address-lookup-functions","title":"MAC Address Lookup Functions","text":""},{"location":"api-reference/#mac_lookupmac-use_apitrue-api_keynone","title":"<code>mac_lookup(mac, use_api=True, api_key=None)</code>","text":"<p>Lookup MAC address vendor information.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup - <code>use_api</code> (bool): Whether to use online API (default: True) - <code>api_key</code> (str, optional): Optional API key for online lookup</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information (mac, oui, vendor, source)</p> <p>Raises: - <code>ValueError</code>: If MAC address is invalid - <code>requests.RequestException</code>: If API request fails</p> <p>Example: <pre><code>from kn_sock.network import mac_lookup\n\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\")\nprint(f\"Vendor: {result['vendor']}\")\n</code></pre></p>"},{"location":"api-reference/#mac_lookup_apimac-api_keynone","title":"<code>mac_lookup_api(mac, api_key=None)</code>","text":"<p>Lookup MAC address vendor using macvendors.co API.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup - <code>api_key</code> (str, optional): Optional API key for higher rate limits</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information</p>"},{"location":"api-reference/#mac_lookup_offlinemac","title":"<code>mac_lookup_offline(mac)</code>","text":"<p>Lookup MAC address vendor using built-in OUI database.</p> <p>Parameters: - <code>mac</code> (str): MAC address to lookup</p> <p>Returns: - <code>Dict[str, str]</code>: Dictionary containing vendor information</p>"},{"location":"api-reference/#batch_mac_lookupmacs-use_apitrue-api_keynone","title":"<code>batch_mac_lookup(macs, use_api=True, api_key=None)</code>","text":"<p>Lookup multiple MAC addresses.</p> <p>Parameters: - <code>macs</code> (List[str]): List of MAC addresses to lookup - <code>use_api</code> (bool): Whether to use online API - <code>api_key</code> (str, optional): Optional API key for online lookup</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of dictionaries containing vendor information</p>"},{"location":"api-reference/#validate_macmac","title":"<code>validate_mac(mac)</code>","text":"<p>Validate MAC address format.</p> <p>Parameters: - <code>mac</code> (str): MAC address to validate</p> <p>Returns: - <code>bool</code>: True if valid, False otherwise</p>"},{"location":"api-reference/#dns-monitoring-functions","title":"DNS Monitoring Functions","text":""},{"location":"api-reference/#monitor_dnsduration60-interfacenone-log_filenone-callbacknone-verbosefalse","title":"<code>monitor_dns(duration=60, interface=None, log_file=None, callback=None, verbose=False)</code>","text":"<p>Monitor DNS requests on the network.</p> <p>Parameters: - <code>duration</code> (int): Duration to monitor in seconds (default: 60) - <code>interface</code> (str, optional): Network interface to monitor (auto-detect if None) - <code>log_file</code> (str, optional): File to save DNS logs (JSON format) - <code>callback</code> (callable, optional): Function to call for each DNS request - <code>verbose</code> (bool): Enable verbose logging (default: False)</p> <p>Returns: - <code>List[Dict[str, Any]]</code>: List of DNS request records</p> <p>Raises: - <code>ImportError</code>: If scapy is not available - <code>PermissionError</code>: If insufficient privileges - <code>RuntimeError</code>: If monitoring fails</p> <p>Example: <pre><code>from kn_sock.network import monitor_dns\n\nresults = monitor_dns(duration=60, log_file=\"dns_log.json\", verbose=True)\nfor result in results:\n    print(f\"{result['source_ip']} -&gt; {result['domain']}\")\n</code></pre></p>"},{"location":"api-reference/#monitor_dns_asyncduration60-interfacenone-log_filenone-callbacknone-verbosefalse","title":"<code>monitor_dns_async(duration=60, interface=None, log_file=None, callback=None, verbose=False)</code>","text":"<p>Start DNS monitoring in a separate thread.</p> <p>Parameters: - <code>duration</code> (int): Duration to monitor in seconds - <code>interface</code> (str, optional): Network interface to monitor - <code>log_file</code> (str, optional): File to save DNS logs - <code>callback</code> (callable, optional): Function to call for each DNS request - <code>verbose</code> (bool): Enable verbose logging</p> <p>Returns: - <code>threading.Thread</code>: Thread object running the monitoring</p>"},{"location":"api-reference/#analyze_dns_logslog_file","title":"<code>analyze_dns_logs(log_file)</code>","text":"<p>Analyze DNS logs and provide statistics.</p> <p>Parameters: - <code>log_file</code> (str): Path to DNS log file (JSON format)</p> <p>Returns: - <code>Dict[str, Any]</code>: Dictionary containing analysis results</p> <p>Raises: - <code>FileNotFoundError</code>: If log file not found - <code>ValueError</code>: If invalid JSON in log file</p>"},{"location":"api-reference/#get_network_interfaces","title":"<code>get_network_interfaces()</code>","text":"<p>Get list of available network interfaces.</p> <p>Returns: - <code>List[Dict[str, str]]</code>: List of interface information</p>"},{"location":"api-reference/#cli-commands","title":"CLI Commands","text":"<p>The network module provides the following CLI commands:</p>"},{"location":"api-reference/#knsock-scan-range-options","title":"<code>knsock scan &lt;range&gt; [options]</code>","text":"<p>Scan network for devices using ARP.</p> <p>Arguments: - <code>range</code>: Network range to scan (e.g., 192.168.1.0/24) - <code>--interface</code>: Network interface to use (auto-detect if not specified) - <code>--timeout</code>: Timeout in seconds for each ARP request (default: 2) - <code>--verbose</code>: Enable verbose output</p> <p>Example: <pre><code>knsock scan 192.168.1.0/24 --verbose\n</code></pre></p>"},{"location":"api-reference/#knsock-mac-lookup-mac-options","title":"<code>knsock mac-lookup &lt;mac&gt; [options]</code>","text":"<p>Lookup MAC address vendor information.</p> <p>Arguments: - <code>mac</code>: MAC address to lookup (e.g., 00:1A:2B:3C:4D:5E) - <code>--offline</code>: Use offline lookup only (no API calls) - <code>--api-key</code>: API key for macvendors.co (optional)</p> <p>Example: <pre><code>knsock mac-lookup 00:1A:2B:3C:4D:5E --offline\n</code></pre></p>"},{"location":"api-reference/#knsock-monitor-options","title":"<code>knsock monitor [options]</code>","text":"<p>Monitor DNS requests on the network.</p> <p>Arguments: - <code>--duration</code>: Duration to monitor in seconds (default: 60) - <code>--interface</code>: Network interface to monitor (auto-detect if not specified) - <code>--log</code>: File to save DNS logs (JSON format) - <code>--verbose</code>: Enable verbose output</p> <p>Example: <pre><code>knsock monitor --duration 120 --log dns_log.json --verbose\n</code></pre></p>"},{"location":"api-reference/#dependencies","title":"Dependencies","text":"<p>The network module requires the following optional dependencies:</p> <ul> <li> <p>scapy: For ARP scanning and DNS monitoring   <pre><code>pip install scapy\n</code></pre></p> </li> <li> <p>psutil: For network interface detection   <pre><code>pip install psutil\n</code></pre></p> </li> <li> <p>requests: For MAC vendor API lookups   <pre><code>pip install requests\n</code></pre></p> </li> </ul>"},{"location":"api-reference/#security-and-legal-considerations","title":"Security and Legal Considerations","text":"<p>\u26a0\ufe0f IMPORTANT LEGAL NOTICE:</p> <ol> <li> <p>Authorization Required: Only use these tools on networks you own or have explicit permission to monitor.</p> </li> <li> <p>Legal Compliance: Network monitoring may be subject to local laws and regulations. Ensure compliance with applicable privacy and surveillance laws.</p> </li> <li> <p>Ethical Use: These tools should only be used for legitimate network administration, security testing, or educational purposes.</p> </li> <li> <p>Privilege Requirements: Some functions require root/administrator privileges for packet sniffing.</p> </li> <li> <p>Data Privacy: Be mindful of sensitive information that may be captured during monitoring.</p> </li> </ol>"},{"location":"api-reference/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues:</p> <ol> <li> <p>Permission Denied: Run with <code>sudo</code> or as administrator for packet sniffing operations.</p> </li> <li> <p>Scapy Import Error: Install scapy with <code>pip install scapy</code>.</p> </li> <li> <p>No Devices Found: Check network range and interface selection.</p> </li> <li> <p>API Rate Limits: Use offline mode or provide API key for MAC lookups.</p> </li> <li> <p>Interface Detection: Manually specify interface if auto-detection fails.</p> </li> </ol>"},{"location":"cli/","title":"Command-Line Interface","text":"<p>kn-sock provides a comprehensive command-line interface for quick socket operations and testing.</p>"},{"location":"cli/#overview","title":"Overview","text":"<p>The <code>kn-sock</code> CLI allows you to: - Start servers for various protocols - Send messages and files - Connect to live streams and video chat - Use interactive mode for real-time communication - Test network connectivity</p>"},{"location":"cli/#basic-commands","title":"Basic Commands","text":""},{"location":"cli/#tcp-commands","title":"TCP Commands","text":""},{"location":"cli/#start-tcp-server","title":"Start TCP Server","text":"<pre><code>kn-sock run-tcp-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-tcp-server 8080\nkn-sock run-tcp-server 8080 --host 127.0.0.1\n</code></pre></p>"},{"location":"cli/#send-tcp-message","title":"Send TCP Message","text":"<pre><code>kn-sock send-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-tcp localhost 8080 \"Hello, World!\"\nkn-sock send-tcp 192.168.1.10 8080 \"Test message\"\n</code></pre></p>"},{"location":"cli/#udp-commands","title":"UDP Commands","text":""},{"location":"cli/#start-udp-server","title":"Start UDP Server","text":"<pre><code>kn-sock run-udp-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-udp-server 8080\n</code></pre></p>"},{"location":"cli/#send-udp-message","title":"Send UDP Message","text":"<pre><code>kn-sock send-udp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-udp localhost 8080 \"Hello, UDP!\"\n</code></pre></p>"},{"location":"cli/#send-udp-multicast","title":"Send UDP Multicast","text":"<pre><code>kn-sock send-udp-multicast &lt;group&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Options: - <code>--ttl &lt;ttl&gt;</code>: Time-to-live for multicast packets (default: 1)</p> <p>Example: <pre><code>kn-sock send-udp-multicast 224.0.0.1 8080 \"Multicast message\"\n</code></pre></p>"},{"location":"cli/#secure-tcp-ssltls-commands","title":"Secure TCP (SSL/TLS) Commands","text":""},{"location":"cli/#start-secure-tcp-server","title":"Start Secure TCP Server","text":"<pre><code>kn-sock run-ssl-tcp-server &lt;port&gt; &lt;certfile&gt; &lt;keyfile&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--cafile &lt;cafile&gt;</code>: CA certificate for client verification - <code>--require-client-cert</code>: Require client certificates (mutual TLS)</p> <p>Example: <pre><code>kn-sock run-ssl-tcp-server 8443 server.crt server.key\nkn-sock run-ssl-tcp-server 8443 server.crt server.key --cafile ca.crt --require-client-cert\n</code></pre></p>"},{"location":"cli/#send-secure-tcp-message","title":"Send Secure TCP Message","text":"<pre><code>kn-sock send-ssl-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Options: - <code>--cafile &lt;cafile&gt;</code>: CA certificate for server verification - <code>--certfile &lt;certfile&gt;</code>: Client certificate - <code>--keyfile &lt;keyfile&gt;</code>: Client private key - <code>--no-verify</code>: Disable server certificate verification</p> <p>Example: <pre><code>kn-sock send-ssl-tcp localhost 8443 \"Hello Secure\"\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\" --cafile ca.crt --certfile client.crt --keyfile client.key\n</code></pre></p>"},{"location":"cli/#file-transfer-commands","title":"File Transfer Commands","text":""},{"location":"cli/#start-file-server","title":"Start File Server","text":"<pre><code>kn-sock run-file-server &lt;port&gt; &lt;save_directory&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-file-server 8080 /path/to/save/directory\n</code></pre></p>"},{"location":"cli/#send-file","title":"Send File","text":"<pre><code>kn-sock send-file &lt;host&gt; &lt;port&gt; &lt;filepath&gt;\n</code></pre> <p>Options: - <code>--show-progress</code>: Show progress bar (default: true) - <code>--no-progress</code>: Hide progress bar</p> <p>Example: <pre><code>kn-sock send-file localhost 8080 /path/to/file.txt\nkn-sock send-file localhost 8080 large_file.zip --show-progress\n</code></pre></p>"},{"location":"cli/#json-commands","title":"JSON Commands","text":""},{"location":"cli/#send-json-data","title":"Send JSON Data","text":"<pre><code>kn-sock send-json &lt;host&gt; &lt;port&gt; &lt;json_data&gt;\n</code></pre> <p>Example: <pre><code>kn-sock send-json localhost 8080 '{\"message\": \"Hello\", \"type\": \"greeting\"}'\nkn-sock send-json localhost 8080 '{\"user_id\": 123, \"action\": \"login\"}'\n</code></pre></p>"},{"location":"cli/#websocket-commands","title":"WebSocket Commands","text":""},{"location":"cli/#start-websocket-server","title":"Start WebSocket Server","text":"<pre><code>kn-sock run-websocket-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Example: <pre><code>kn-sock run-websocket-server 127.0.0.1 8765\n</code></pre></p>"},{"location":"cli/#connect-to-websocket","title":"Connect to WebSocket","text":"<pre><code>kn-sock connect-websocket &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--resource &lt;path&gt;</code>: WebSocket resource path (default: /) - <code>--headers &lt;json&gt;</code>: Additional headers as JSON</p> <p>Example: <pre><code>kn-sock connect-websocket localhost 8765\nkn-sock connect-websocket localhost 8765 --resource /chat --headers '{\"Authorization\": \"Bearer token\"}'\n</code></pre></p>"},{"location":"cli/#http-commands","title":"HTTP Commands","text":""},{"location":"cli/#start-http-server","title":"Start HTTP Server","text":"<pre><code>kn-sock run-http-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--static-dir &lt;directory&gt;</code>: Directory to serve static files - <code>--routes &lt;json&gt;</code>: Custom routes as JSON</p> <p>Example: <pre><code>kn-sock run-http-server 127.0.0.1 8080\nkn-sock run-http-server 127.0.0.1 8080 --static-dir /path/to/static\n</code></pre></p>"},{"location":"cli/#http-get-request","title":"HTTP GET Request","text":"<pre><code>kn-sock http-get &lt;host&gt; &lt;port&gt; &lt;path&gt;\n</code></pre> <p>Options: - <code>--headers &lt;json&gt;</code>: HTTP headers as JSON</p> <p>Example: <pre><code>kn-sock http-get example.com 80 /\nkn-sock http-get api.example.com 443 /users --headers '{\"Authorization\": \"Bearer token\"}'\n</code></pre></p>"},{"location":"cli/#http-post-request","title":"HTTP POST Request","text":"<pre><code>kn-sock http-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;\n</code></pre> <p>Options: - <code>--headers &lt;json&gt;</code>: HTTP headers as JSON</p> <p>Example: <pre><code>kn-sock http-post api.example.com 80 /users '{\"name\": \"John\", \"email\": \"john@example.com\"}'\n</code></pre></p>"},{"location":"cli/#pubsub-commands","title":"Pub/Sub Commands","text":""},{"location":"cli/#start-pubsub-server","title":"Start Pub/Sub Server","text":"<pre><code>kn-sock run-pubsub-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0)</p> <p>Example: <pre><code>kn-sock run-pubsub-server 9000\n</code></pre></p>"},{"location":"cli/#pubsub-client-commands","title":"Pub/Sub Client Commands","text":"<pre><code># Subscribe to a topic\nkn-sock pubsub-subscribe &lt;host&gt; &lt;port&gt; &lt;topic&gt;\n\n# Publish a message\nkn-sock pubsub-publish &lt;host&gt; &lt;port&gt; &lt;topic&gt; &lt;message&gt;\n\n# Receive messages\nkn-sock pubsub-receive &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Example: <pre><code>kn-sock pubsub-subscribe localhost 9000 news\nkn-sock pubsub-publish localhost 9000 news \"Breaking news!\"\nkn-sock pubsub-receive localhost 9000\n</code></pre></p>"},{"location":"cli/#rpc-commands","title":"RPC Commands","text":""},{"location":"cli/#start-rpc-server","title":"Start RPC Server","text":"<pre><code>kn-sock run-rpc-server &lt;port&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--functions &lt;json&gt;</code>: Functions to register as JSON</p> <p>Example: <pre><code>kn-sock run-rpc-server 9001\nkn-sock run-rpc-server 9001 --functions '{\"add\": \"lambda x, y: x + y\", \"echo\": \"lambda msg: msg\"}'\n</code></pre></p>"},{"location":"cli/#rpc-client-commands","title":"RPC Client Commands","text":"<pre><code># Call a remote function\nkn-sock rpc-call &lt;host&gt; &lt;port&gt; &lt;function&gt; &lt;args...&gt;\n</code></pre> <p>Example: <pre><code>kn-sock rpc-call localhost 9001 add 2 3\nkn-sock rpc-call localhost 9001 echo \"Hello RPC\"\n</code></pre></p>"},{"location":"cli/#live-streaming-commands","title":"Live Streaming Commands","text":""},{"location":"cli/#start-live-stream-server","title":"Start Live Stream Server","text":"<pre><code>kn-sock run-live-server &lt;port&gt; &lt;video_files...&gt;\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: port + 1)</p> <p>Example: <pre><code>kn-sock run-live-server 9000 video1.mp4 video2.mp4 video3.mp4\nkn-sock run-live-server 9000 movie.mp4 --host 0.0.0.0 --audio-port 9001\n</code></pre></p>"},{"location":"cli/#connect-to-live-stream","title":"Connect to Live Stream","text":"<pre><code>kn-sock connect-live-server &lt;host&gt; &lt;port&gt;\n</code></pre> <p>Options: - <code>--audio-port &lt;port&gt;</code>: Audio port (default: port + 1)</p> <p>Example: <pre><code>kn-sock connect-live-server 192.168.1.10 9000\nkn-sock connect-live-server 192.168.1.10 9000 --audio-port 9001\n</code></pre></p>"},{"location":"cli/#video-chat-commands","title":"Video Chat Commands","text":""},{"location":"cli/#start-video-chat-server","title":"Start Video Chat Server","text":"<pre><code>kn-sock run-video-chat-server\n</code></pre> <p>Options: - <code>--host &lt;host&gt;</code>: Host to bind (default: 0.0.0.0) - <code>--video-port &lt;port&gt;</code>: Video port (default: 9000) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: 9001) - <code>--text-port &lt;port&gt;</code>: Text port (default: 9002)</p> <p>Example: <pre><code>kn-sock run-video-chat-server\nkn-sock run-video-chat-server --host 0.0.0.0 --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre></p>"},{"location":"cli/#connect-to-video-chat","title":"Connect to Video Chat","text":"<pre><code>kn-sock connect-video-chat &lt;server_ip&gt; &lt;room&gt; &lt;nickname&gt;\n</code></pre> <p>Options: - <code>--video-port &lt;port&gt;</code>: Video port (default: 9000) - <code>--audio-port &lt;port&gt;</code>: Audio port (default: 9001) - <code>--text-port &lt;port&gt;</code>: Text port (default: 9002) - <code>--no-audio</code>: Disable audio functionality</p> <p>Example: <pre><code>kn-sock connect-video-chat 127.0.0.1 myroom alice\nkn-sock connect-video-chat 192.168.1.10 conference john --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre></p>"},{"location":"cli/#interactive-mode","title":"Interactive Mode","text":""},{"location":"cli/#start-interactive-cli","title":"Start Interactive CLI","text":"<pre><code>kn-sock interactive\n</code></pre>"},{"location":"cli/#interactive-commands","title":"Interactive Commands","text":"<p>Once in interactive mode, you can use these commands:</p>"},{"location":"cli/#connection-management","title":"Connection Management","text":"<pre><code># Connect to a server\nconnect &lt;name&gt; &lt;host&gt; &lt;port&gt;\n\n# List all connections\nlist\n\n# Select default connection\nselect &lt;name&gt;\n\n# Disconnect a connection\ndisconnect &lt;name&gt;\n</code></pre>"},{"location":"cli/#communication","title":"Communication","text":"<pre><code># Send a message\nsend &lt;message&gt;\n\n# Receive a message\nreceive\n\n# Toggle background receive mode\nbg_receive\n\n# Show message history\nhistory\n</code></pre>"},{"location":"cli/#utility","title":"Utility","text":"<pre><code># Show help\nhelp\n\n# Exit the CLI\nquit\nexit\n</code></pre>"},{"location":"cli/#interactive-session-example","title":"Interactive Session Example","text":"<pre><code>$ kn-sock interactive\nkn-sock&gt; connect server1 localhost 8080\nConnected to localhost:8080 as 'server1'\nkn-sock&gt; send Hello, server!\nMessage sent\nkn-sock&gt; receive\nReceived: Message received!\nkn-sock&gt; bg_receive\nBackground receive mode enabled\nkn-sock&gt; send Another message\nMessage sent\nReceived: Message received!\nkn-sock&gt; history\nLast 10 messages:\n1. [SENT] Hello, server!\n2. [RECV] Message received!\n3. [SENT] Another message\n4. [RECV] Message received!\nkn-sock&gt; disconnect server1\nDisconnected from server1\nkn-sock&gt; quit\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--help</code>, <code>-h</code>: Show help message</li> <li><code>--version</code>, <code>-v</code>: Show version information</li> <li><code>--verbose</code>: Enable verbose output</li> <li><code>--quiet</code>: Suppress output (except errors)</li> </ul>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#complete-workflow-examples","title":"Complete Workflow Examples","text":""},{"location":"cli/#tcp-echo-server-and-client","title":"TCP Echo Server and Client","text":"<pre><code># Terminal 1: Start server\nkn-sock run-tcp-server 8080\n\n# Terminal 2: Send message\nkn-sock send-tcp localhost 8080 \"Hello, World!\"\n</code></pre>"},{"location":"cli/#file-transfer","title":"File Transfer","text":"<pre><code># Terminal 1: Start file server\nkn-sock run-file-server 8080 /tmp/received\n\n# Terminal 2: Send file\nkn-sock send-file localhost 8080 /path/to/document.pdf\n</code></pre>"},{"location":"cli/#secure-communication","title":"Secure Communication","text":"<pre><code># Terminal 1: Start secure server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key\n\n# Terminal 2: Send secure message\nkn-sock send-ssl-tcp localhost 8443 \"Secret message\"\n</code></pre>"},{"location":"cli/#live-streaming","title":"Live Streaming","text":"<pre><code># Terminal 1: Start live stream server\nkn-sock run-live-server 9000 movie.mp4\n\n# Terminal 2: Connect as client\nkn-sock connect-live-server 192.168.1.10 9000\n</code></pre>"},{"location":"cli/#video-chat","title":"Video Chat","text":"<pre><code># Terminal 1: Start video chat server\nkn-sock run-video-chat-server\n\n# Terminal 2: Connect as client\nkn-sock connect-video-chat 127.0.0.1 meeting alice\n\n# Terminal 3: Connect another client\nkn-sock connect-video-chat 127.0.0.1 meeting bob\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Port already in use <pre><code># Use a different port\nkn-sock run-tcp-server 8081\n</code></pre></p> </li> <li> <p>Permission denied <pre><code># Use a higher port number\nkn-sock run-tcp-server 8080\n</code></pre></p> </li> <li> <p>Connection refused <pre><code># Make sure server is running first\nkn-sock run-tcp-server 8080 &amp;\nkn-sock send-tcp localhost 8080 \"test\"\n</code></pre></p> </li> <li> <p>SSL certificate issues <pre><code># For testing, disable verification\nkn-sock send-ssl-tcp localhost 8443 \"test\" --no-verify\n</code></pre></p> </li> </ol>"},{"location":"cli/#debug-mode","title":"Debug Mode","text":"<p>Enable verbose output for debugging:</p> <pre><code>kn-sock --verbose run-tcp-server 8080\nkn-sock --verbose send-tcp localhost 8080 \"test\"\n</code></pre>"},{"location":"cli/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic usage examples</li> <li>Interactive CLI - For detailed interactive mode documentation</li> <li>API Reference - For programmatic usage </li> </ul>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>kn-sock provides flexible configuration options to customize behavior for different environments and use cases.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>Configuration in kn-sock can be managed through: - Environment variables: For deployment-specific settings - Configuration files: For complex, structured configuration - Runtime parameters: For dynamic configuration changes - Global defaults: Built-in sensible defaults for all features</p>"},{"location":"configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"configuration/#1-environment-variables","title":"1. Environment Variables","text":"<p>Set environment variables to configure kn-sock behavior:</p> <pre><code># Basic networking\nexport KN_SOCK_DEFAULT_HOST=\"0.0.0.0\"\nexport KN_SOCK_DEFAULT_PORT=\"8080\"\nexport KN_SOCK_TIMEOUT=\"30\"\n\n# Security settings\nexport KN_SOCK_SSL_VERIFY=\"true\"\nexport KN_SOCK_SSL_CERT_PATH=\"/path/to/cert.pem\"\nexport KN_SOCK_SSL_KEY_PATH=\"/path/to/key.pem\"\n\n# Performance tuning\nexport KN_SOCK_BUFFER_SIZE=\"8192\"\nexport KN_SOCK_MAX_CONNECTIONS=\"100\"\nexport KN_SOCK_THREAD_POOL_SIZE=\"10\"\n\n# Logging\nexport KN_SOCK_LOG_LEVEL=\"INFO\"\nexport KN_SOCK_LOG_FILE=\"/var/log/kn-sock.log\"\n\n# Run your application\npython your_app.py\n</code></pre>"},{"location":"configuration/#2-configuration-files","title":"2. Configuration Files","text":"<p>Create a configuration file for structured settings:</p> <p>config.yaml: <pre><code># Network Configuration\nnetwork:\n  default_host: \"0.0.0.0\"\n  default_port: 8080\n  timeout: 30\n  buffer_size: 8192\n  max_connections: 100\n  keep_alive: true\n  tcp_nodelay: true\n\n# Security Configuration\nsecurity:\n  ssl:\n    enabled: true\n    cert_file: \"/path/to/cert.pem\"\n    key_file: \"/path/to/key.pem\"\n    ca_file: \"/path/to/ca.pem\"\n    verify_mode: \"CERT_REQUIRED\"\n  authentication:\n    enabled: true\n    secret_key: \"your-secret-key\"\n    token_expiry: 3600\n\n# Performance Configuration\nperformance:\n  thread_pool_size: 10\n  connection_pool_size: 20\n  async_workers: 4\n  compression:\n    enabled: true\n    algorithm: \"gzip\"\n    level: 6\n\n# Logging Configuration\nlogging:\n  level: \"INFO\"\n  file: \"/var/log/kn-sock.log\"\n  format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n  max_size: \"10MB\"\n  backup_count: 5\n\n# Protocol-specific Configuration\nprotocols:\n  tcp:\n    keepalive: true\n    keepalive_idle: 7200\n    keepalive_interval: 75\n    keepalive_probes: 9\n\n  udp:\n    multicast_ttl: 1\n    broadcast: false\n\n  websocket:\n    ping_interval: 20\n    ping_timeout: 10\n    max_message_size: \"1MB\"\n\n  http:\n    user_agent: \"kn-sock/1.0\"\n    timeout: 30\n    max_redirects: 5\n\n# Feature-specific Configuration\nfeatures:\n  file_transfer:\n    chunk_size: 64KB\n    progress_callback: true\n    checksum_verification: true\n\n  live_streaming:\n    buffer_size: 1MB\n    quality_levels: [240, 480, 720, 1080]\n    adaptive_bitrate: true\n\n  pubsub:\n    max_subscribers: 1000\n    message_history: 100\n    persistence: true\n\n  rpc:\n    timeout: 30\n    retry_attempts: 3\n    load_balancing: \"round_robin\"\n</code></pre></p> <p>Using the configuration file:</p> <pre><code>from kn_sock.config import load_config\n\n# Load configuration\nconfig = load_config(\"config.yaml\")\n\n# Use configured settings\nfrom kn_sock import start_tcp_server\n\nstart_tcp_server(\n    port=config.network.default_port,\n    host=config.network.default_host,\n    timeout=config.network.timeout\n)\n</code></pre>"},{"location":"configuration/#3-runtime-configuration","title":"3. Runtime Configuration","text":"<p>Configure settings programmatically at runtime:</p> <pre><code>from kn_sock.config import Config\n\n# Create configuration instance\nconfig = Config()\n\n# Set network configuration\nconfig.set_network_config(\n    default_host=\"localhost\",\n    default_port=9000,\n    timeout=60,\n    buffer_size=16384\n)\n\n# Set SSL configuration\nconfig.set_ssl_config(\n    cert_file=\"server.crt\",\n    key_file=\"server.key\",\n    verify_mode=\"CERT_OPTIONAL\"\n)\n\n# Set performance configuration\nconfig.set_performance_config(\n    thread_pool_size=20,\n    connection_pool_size=50,\n    compression_enabled=True\n)\n\n# Apply configuration globally\nconfig.apply_global()\n\n# Now all kn-sock operations will use these settings\nfrom kn_sock import start_tcp_server\nstart_tcp_server(8080, handler)  # Uses configured settings\n</code></pre>"},{"location":"configuration/#configuration-categories","title":"Configuration Categories","text":""},{"location":"configuration/#network-configuration","title":"Network Configuration","text":"<p>Control fundamental networking behavior:</p> <pre><code>from kn_sock.config import NetworkConfig\n\nnetwork_config = NetworkConfig(\n    # Basic settings\n    default_host=\"0.0.0.0\",\n    default_port=8080,\n    timeout=30,\n\n    # Buffer and connection limits\n    buffer_size=8192,\n    max_connections=100,\n    backlog=128,\n\n    # TCP-specific options\n    keep_alive=True,\n    tcp_nodelay=True,\n    socket_reuse=True,\n\n    # Retry and timeout settings\n    connect_timeout=10,\n    read_timeout=30,\n    write_timeout=30,\n    retry_attempts=3,\n    retry_delay=1.0\n)\n</code></pre> <p>Environment Variables: - <code>KN_SOCK_DEFAULT_HOST</code>: Default host for servers - <code>KN_SOCK_DEFAULT_PORT</code>: Default port for servers - <code>KN_SOCK_TIMEOUT</code>: Default timeout for operations - <code>KN_SOCK_BUFFER_SIZE</code>: Socket buffer size - <code>KN_SOCK_MAX_CONNECTIONS</code>: Maximum concurrent connections</p>"},{"location":"configuration/#security-configuration","title":"Security Configuration","text":"<p>Configure SSL/TLS and authentication:</p> <pre><code>from kn_sock.config import SecurityConfig\n\nsecurity_config = SecurityConfig(\n    # SSL/TLS settings\n    ssl_enabled=True,\n    ssl_cert_file=\"/path/to/server.crt\",\n    ssl_key_file=\"/path/to/server.key\",\n    ssl_ca_file=\"/path/to/ca.crt\",\n    ssl_verify_mode=\"CERT_REQUIRED\",  # CERT_NONE, CERT_OPTIONAL, CERT_REQUIRED\n    ssl_check_hostname=True,\n    ssl_ciphers=\"HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA\",\n\n    # Authentication settings\n    auth_enabled=True,\n    auth_secret_key=\"your-secret-key\",\n    auth_algorithm=\"HS256\",\n    auth_token_expiry=3600,\n\n    # Rate limiting\n    rate_limit_enabled=True,\n    rate_limit_requests=100,\n    rate_limit_window=60,\n\n    # IP filtering\n    allowed_ips=[\"192.168.1.0/24\", \"10.0.0.0/8\"],\n    blocked_ips=[\"192.168.1.100\"]\n)\n</code></pre> <p>Environment Variables: - <code>KN_SOCK_SSL_CERT_PATH</code>: Path to SSL certificate - <code>KN_SOCK_SSL_KEY_PATH</code>: Path to SSL private key - <code>KN_SOCK_SSL_VERIFY</code>: SSL verification mode - <code>KN_SOCK_AUTH_SECRET</code>: Authentication secret key</p>"},{"location":"configuration/#performance-configuration","title":"Performance Configuration","text":"<p>Optimize performance for your use case:</p> <pre><code>from kn_sock.config import PerformanceConfig\n\nperformance_config = PerformanceConfig(\n    # Threading configuration\n    thread_pool_size=10,\n    thread_pool_max_size=50,\n    thread_timeout=300,\n\n    # Connection pooling\n    connection_pool_size=20,\n    connection_pool_max_size=100,\n    connection_idle_timeout=300,\n\n    # Async configuration\n    async_workers=4,\n    async_queue_size=1000,\n\n    # Compression settings\n    compression_enabled=True,\n    compression_algorithm=\"gzip\",  # gzip, deflate, brotli\n    compression_level=6,\n    compression_threshold=1024,\n\n    # Caching\n    cache_enabled=True,\n    cache_size=1000,\n    cache_ttl=300,\n\n    # Memory management\n    max_memory_usage=\"512MB\",\n    gc_threshold=10000\n)\n</code></pre> <p>Environment Variables: - <code>KN_SOCK_THREAD_POOL_SIZE</code>: Thread pool size - <code>KN_SOCK_COMPRESSION</code>: Enable/disable compression - <code>KN_SOCK_CACHE_SIZE</code>: Cache size limit</p>"},{"location":"configuration/#logging-configuration","title":"Logging Configuration","text":"<p>Control logging behavior:</p> <pre><code>from kn_sock.config import LoggingConfig\n\nlogging_config = LoggingConfig(\n    # Basic logging settings\n    level=\"INFO\",  # DEBUG, INFO, WARNING, ERROR, CRITICAL\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n\n    # File logging\n    file_enabled=True,\n    file_path=\"/var/log/kn-sock.log\",\n    file_max_size=\"10MB\",\n    file_backup_count=5,\n\n    # Console logging\n    console_enabled=True,\n    console_colored=True,\n\n    # Structured logging\n    structured=True,\n    json_format=False,\n\n    # Performance logging\n    performance_logging=True,\n    slow_query_threshold=1.0,\n\n    # Security logging\n    security_events=True,\n    audit_trail=True\n)\n</code></pre> <p>Environment Variables: - <code>KN_SOCK_LOG_LEVEL</code>: Logging level - <code>KN_SOCK_LOG_FILE</code>: Log file path - <code>KN_SOCK_LOG_FORMAT</code>: Log message format</p>"},{"location":"configuration/#protocol-specific-configuration","title":"Protocol-Specific Configuration","text":""},{"location":"configuration/#tcp-configuration","title":"TCP Configuration","text":"<pre><code>from kn_sock.config import TCPConfig\n\ntcp_config = TCPConfig(\n    # Connection settings\n    keepalive=True,\n    keepalive_idle=7200,      # Seconds before sending keepalive probes\n    keepalive_interval=75,    # Interval between keepalive probes\n    keepalive_probes=9,       # Number of keepalive probes\n\n    # Socket options\n    tcp_nodelay=True,         # Disable Nagle's algorithm\n    socket_reuse=True,        # Enable SO_REUSEADDR\n\n    # Buffer settings\n    send_buffer_size=65536,\n    recv_buffer_size=65536,\n\n    # Timeout settings\n    connect_timeout=10,\n    send_timeout=30,\n    recv_timeout=30\n)\n</code></pre>"},{"location":"configuration/#websocket-configuration","title":"WebSocket Configuration","text":"<pre><code>from kn_sock.config import WebSocketConfig\n\nwebsocket_config = WebSocketConfig(\n    # Connection management\n    ping_interval=20,         # Seconds between ping frames\n    ping_timeout=10,          # Timeout waiting for pong\n    close_timeout=10,         # Timeout for close handshake\n\n    # Message limits\n    max_message_size=\"1MB\",\n    max_frame_size=\"64KB\",\n    max_queue_size=100,\n\n    # Compression\n    per_message_deflate=True,\n    compression_level=6,\n\n    # Subprotocols\n    subprotocols=[\"chat\", \"echo\"],\n\n    # Headers\n    extra_headers={\n        \"Server\": \"kn-sock/1.0\"\n    }\n)\n</code></pre>"},{"location":"configuration/#rpc-configuration","title":"RPC Configuration","text":"<pre><code>from kn_sock.config import RPCConfig\n\nrpc_config = RPCConfig(\n    # Timeout settings\n    call_timeout=30,\n    connect_timeout=10,\n\n    # Retry configuration\n    retry_attempts=3,\n    retry_delay=1.0,\n    retry_backoff=\"exponential\",  # linear, exponential\n\n    # Load balancing\n    load_balancing=\"round_robin\",  # round_robin, random, least_connections\n    health_check_interval=30,\n\n    # Serialization\n    serialization=\"json\",     # json, pickle, protobuf\n    compression=True,\n\n    # Authentication\n    auth_required=False,\n    auth_timeout=60,\n\n    # Middleware\n    middleware_enabled=True,\n    request_logging=True,\n    performance_monitoring=True\n)\n</code></pre>"},{"location":"configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"configuration/#development-configuration","title":"Development Configuration","text":"<pre><code># development.yaml\nnetwork:\n  default_host: \"127.0.0.1\"\n  default_port: 8080\n\nsecurity:\n  ssl:\n    enabled: false\n  authentication:\n    enabled: false\n\nlogging:\n  level: \"DEBUG\"\n  console_enabled: true\n  file_enabled: false\n\nperformance:\n  thread_pool_size: 2\n  compression:\n    enabled: false\n</code></pre>"},{"location":"configuration/#production-configuration","title":"Production Configuration","text":"<pre><code># production.yaml\nnetwork:\n  default_host: \"0.0.0.0\"\n  default_port: 8080\n  max_connections: 1000\n\nsecurity:\n  ssl:\n    enabled: true\n    cert_file: \"/etc/ssl/certs/server.crt\"\n    key_file: \"/etc/ssl/private/server.key\"\n    verify_mode: \"CERT_REQUIRED\"\n  authentication:\n    enabled: true\n    secret_key: \"${AUTH_SECRET_KEY}\"\n\nlogging:\n  level: \"INFO\"\n  file_enabled: true\n  file_path: \"/var/log/kn-sock.log\"\n  structured: true\n\nperformance:\n  thread_pool_size: 20\n  connection_pool_size: 100\n  compression:\n    enabled: true\n    level: 6\n</code></pre>"},{"location":"configuration/#testing-configuration","title":"Testing Configuration","text":"<pre><code># testing.yaml\nnetwork:\n  default_host: \"127.0.0.1\"\n  timeout: 5\n\nsecurity:\n  ssl:\n    enabled: false\n  authentication:\n    enabled: false\n\nlogging:\n  level: \"WARNING\"\n  console_enabled: false\n  file_enabled: false\n\nperformance:\n  thread_pool_size: 1\n  compression:\n    enabled: false\n\nfeatures:\n  file_transfer:\n    chunk_size: 1KB\n  live_streaming:\n    buffer_size: 64KB\n</code></pre>"},{"location":"configuration/#configuration-loading","title":"Configuration Loading","text":""},{"location":"configuration/#loading-order","title":"Loading Order","text":"<p>kn-sock loads configuration in the following order (later sources override earlier ones):</p> <ol> <li>Built-in defaults</li> <li>System configuration file (<code>/etc/kn-sock/config.yaml</code>)</li> <li>User configuration file (<code>~/.kn-sock/config.yaml</code>)</li> <li>Local configuration file (<code>./kn-sock.yaml</code>)</li> <li>Environment variables</li> <li>Runtime configuration</li> <li>Function/method parameters</li> </ol>"},{"location":"configuration/#configuration-file-discovery","title":"Configuration File Discovery","text":"<pre><code>from kn_sock.config import load_config\n\n# Automatic discovery (searches standard locations)\nconfig = load_config()\n\n# Explicit file path\nconfig = load_config(\"/path/to/config.yaml\")\n\n# Multiple files (merged in order)\nconfig = load_config([\n    \"/etc/kn-sock/default.yaml\",\n    \"/etc/kn-sock/production.yaml\",\n    \"./local-overrides.yaml\"\n])\n\n# With environment-based selection\nimport os\nenv = os.getenv(\"ENVIRONMENT\", \"development\")\nconfig = load_config(f\"config/{env}.yaml\")\n</code></pre>"},{"location":"configuration/#validation-and-defaults","title":"Validation and Defaults","text":"<pre><code>from kn_sock.config import Config, ValidationError\n\ntry:\n    config = Config.from_file(\"config.yaml\")\n\n    # Validate configuration\n    config.validate()\n\n    # Get with defaults\n    port = config.get(\"network.port\", default=8080)\n    ssl_enabled = config.get(\"security.ssl.enabled\", default=False)\n\nexcept ValidationError as e:\n    print(f\"Configuration error: {e}\")\n    # Handle validation errors\n</code></pre>"},{"location":"configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"configuration/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"<pre><code># config.yaml - Never put secrets directly in config files\nsecurity:\n  authentication:\n    secret_key: \"${AUTH_SECRET_KEY}\"\n  ssl:\n    cert_file: \"${SSL_CERT_PATH}\"\n    key_file: \"${SSL_KEY_PATH}\"\n</code></pre> <pre><code># Set environment variables\nexport AUTH_SECRET_KEY=\"your-secret-key\"\nexport SSL_CERT_PATH=\"/path/to/cert.pem\"\nexport SSL_KEY_PATH=\"/path/to/key.pem\"\n</code></pre>"},{"location":"configuration/#2-environment-specific-configurations","title":"2. Environment-Specific Configurations","text":"<pre><code>import os\nfrom kn_sock.config import load_config\n\n# Load environment-specific configuration\nenvironment = os.getenv(\"ENVIRONMENT\", \"development\")\nconfig_file = f\"config/{environment}.yaml\"\nconfig = load_config(config_file)\n</code></pre>"},{"location":"configuration/#3-configuration-validation","title":"3. Configuration Validation","text":"<pre><code>from kn_sock.config import Config, ConfigSchema\nfrom marshmallow import fields\n\nclass NetworkConfigSchema(ConfigSchema):\n    host = fields.Str(required=True, validate=lambda x: len(x) &gt; 0)\n    port = fields.Int(required=True, validate=lambda x: 1 &lt;= x &lt;= 65535)\n    timeout = fields.Int(validate=lambda x: x &gt; 0)\n\n# Validate configuration against schema\nconfig = Config.from_file(\"config.yaml\")\nschema = NetworkConfigSchema()\nerrors = schema.validate(config.network)\n\nif errors:\n    print(f\"Configuration errors: {errors}\")\n</code></pre>"},{"location":"configuration/#4-configuration-monitoring","title":"4. Configuration Monitoring","text":"<pre><code>import threading\nimport time\nfrom kn_sock.config import Config\n\nclass ConfigMonitor:\n    def __init__(self, config_file, reload_callback=None):\n        self.config_file = config_file\n        self.reload_callback = reload_callback\n        self.last_modified = os.path.getmtime(config_file)\n        self.monitoring = True\n\n        # Start monitoring thread\n        self.monitor_thread = threading.Thread(target=self._monitor, daemon=True)\n        self.monitor_thread.start()\n\n    def _monitor(self):\n        while self.monitoring:\n            try:\n                current_modified = os.path.getmtime(self.config_file)\n                if current_modified &gt; self.last_modified:\n                    print(\"Configuration file changed, reloading...\")\n                    new_config = Config.from_file(self.config_file)\n\n                    if self.reload_callback:\n                        self.reload_callback(new_config)\n\n                    self.last_modified = current_modified\n\n            except Exception as e:\n                print(f\"Error monitoring config file: {e}\")\n\n            time.sleep(1)  # Check every second\n\n# Usage\ndef on_config_reload(new_config):\n    print(\"Configuration reloaded!\")\n    # Update application settings\n\nmonitor = ConfigMonitor(\"config.yaml\", on_config_reload)\n</code></pre>"},{"location":"configuration/#5-configuration-documentation","title":"5. Configuration Documentation","text":"<p>Always document your configuration options:</p> <pre><code># config.yaml\n# Network Configuration\nnetwork:\n  # Host to bind servers to (default: 0.0.0.0)\n  default_host: \"0.0.0.0\"\n\n  # Default port for servers (default: 8080)\n  default_port: 8080\n\n  # Connection timeout in seconds (default: 30)\n  timeout: 30\n\n  # Maximum concurrent connections (default: 100)\n  max_connections: 100\n\n# Security Configuration\nsecurity:\n  ssl:\n    # Enable SSL/TLS encryption (default: false)\n    enabled: true\n\n    # Path to SSL certificate file (required if SSL enabled)\n    cert_file: \"/path/to/cert.pem\"\n\n    # Path to SSL private key file (required if SSL enabled)\n    key_file: \"/path/to/key.pem\"\n</code></pre>"},{"location":"configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"configuration/#common-configuration-issues","title":"Common Configuration Issues","text":""},{"location":"configuration/#1-file-not-found","title":"1. File Not Found","text":"<pre><code>try:\n    config = load_config(\"config.yaml\")\nexcept FileNotFoundError:\n    print(\"Configuration file not found, using defaults\")\n    config = Config.default()\n</code></pre>"},{"location":"configuration/#2-invalid-configuration-values","title":"2. Invalid Configuration Values","text":"<pre><code>try:\n    config = load_config(\"config.yaml\")\n    config.validate()\nexcept ValidationError as e:\n    print(f\"Invalid configuration: {e}\")\n    # Fix configuration or exit\n</code></pre>"},{"location":"configuration/#3-environment-variable-issues","title":"3. Environment Variable Issues","text":"<pre><code># Check if environment variables are set\nenv | grep KN_SOCK\n\n# Debug environment variable loading\nexport KN_SOCK_DEBUG=true\npython your_app.py\n</code></pre>"},{"location":"configuration/#4-permission-issues","title":"4. Permission Issues","text":"<pre><code># Ensure configuration files are readable\nchmod 644 config.yaml\n\n# Ensure SSL files have correct permissions\nchmod 600 /path/to/server.key\nchmod 644 /path/to/server.crt\n</code></pre>"},{"location":"configuration/#configuration-debugging","title":"Configuration Debugging","text":"<pre><code>from kn_sock.config import Config\n\n# Enable debug logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Load configuration with debug info\nconfig = Config.from_file(\"config.yaml\", debug=True)\n\n# Print effective configuration\nprint(\"Effective configuration:\")\nconfig.dump()\n\n# Check configuration sources\nprint(\"Configuration sources:\")\nfor source in config.sources:\n    print(f\"  - {source}\")\n</code></pre>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic setup and configuration</li> <li>Docker Guide - Docker-specific configuration</li> <li>Security Guide - Security configuration best practices</li> <li>Performance Guide - Performance tuning configuration</li> <li>Troubleshooting - Common configuration issues</li> </ul>"},{"location":"docker/","title":"Docker Guide","text":"<p>This guide covers how to use kn-sock with Docker for development, testing, and deployment.</p>"},{"location":"docker/#overview","title":"Overview","text":"<p>kn-sock provides Docker support through: - Pre-built Docker images for running CLI commands - Docker Compose configuration for easy development - Containerized test environment - Production-ready deployment options</p>"},{"location":"docker/#quick-start","title":"Quick Start","text":""},{"location":"docker/#using-docker-compose","title":"Using Docker Compose","text":"<p>The easiest way to get started with kn-sock in Docker:</p> <pre><code># Show CLI help\ndocker-compose run knsock --help\n\n# Start a TCP server\ndocker-compose run knsock tcp-server --port 8080\n\n# Send a message from another terminal\ndocker-compose run knsock tcp-client --host localhost --port 8080 --message \"Hello Docker!\"\n</code></pre>"},{"location":"docker/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\ndocker-compose run test\n\n# Run specific test files\ndocker-compose run test pytest test/test_tcp_udp_msg.py -v\n\n# Run tests with coverage\ndocker-compose run test pytest --cov=kn_sock test/\n</code></pre>"},{"location":"docker/#docker-compose-configuration","title":"Docker Compose Configuration","text":"<p>The <code>docker-compose.yml</code> provides two main services:</p>"},{"location":"docker/#knsock-service","title":"knsock Service","text":"<pre><code>knsock:\n  build: .\n  image: knsock:latest\n  command: [\"--help\"]\n  volumes:\n    - .:/app\n</code></pre> <p>Usage: - Runs kn-sock CLI commands - Mounts current directory for development - Uses host networking for socket operations</p>"},{"location":"docker/#test-service","title":"test Service","text":"<pre><code>test:\n  build: .\n  image: knsock:latest\n  command: [\"pytest\", \"test/\"]\n  volumes:\n    - .:/app\n</code></pre> <p>Usage: - Runs the complete test suite - Isolated testing environment - Same image as main service for consistency</p>"},{"location":"docker/#manual-docker-usage","title":"Manual Docker Usage","text":""},{"location":"docker/#building-the-image","title":"Building the Image","text":"<pre><code># Build the Docker image\ndocker build -t knsock:latest .\n\n# Build with specific tag\ndocker build -t knsock:1.0.0 .\n</code></pre>"},{"location":"docker/#running-cli-commands","title":"Running CLI Commands","text":"<pre><code># Show help\ndocker run --rm knsock:latest --help\n\n# Start a TCP server (requires host networking)\ndocker run --rm --network host knsock:latest tcp-server --port 8080\n\n# Send a TCP message\ndocker run --rm --network host knsock:latest tcp-client --host localhost --port 8080 --message \"Hello\"\n</code></pre>"},{"location":"docker/#interactive-development","title":"Interactive Development","text":"<pre><code># Run interactive shell for development\ndocker run -it --rm -v $(pwd):/app knsock:latest bash\n\n# Inside container, you can run:\n# python -m kn_sock.cli --help\n# pytest test/\n# python examples/tcp_server.py\n</code></pre>"},{"location":"docker/#production-deployment","title":"Production Deployment","text":""},{"location":"docker/#multi-stage-build-recommended","title":"Multi-Stage Build (Recommended)","text":"<p>Create a production Dockerfile:</p> <pre><code># Build stage\nFROM python:3.11-slim as builder\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Production stage\nFROM python:3.11-slim\nWORKDIR /app\nCOPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\nCOPY . .\nEXPOSE 8080\nENTRYPOINT [\"python\", \"-m\", \"kn_sock.cli\"]\n</code></pre>"},{"location":"docker/#docker-compose-for-production","title":"Docker Compose for Production","text":"<pre><code>version: '3.8'\nservices:\n  tcp-server:\n    build: .\n    image: knsock:latest\n    command: [\"tcp-server\", \"--port\", \"8080\", \"--host\", \"0.0.0.0\"]\n    ports:\n      - \"8080:8080\"\n    restart: unless-stopped\n\n  udp-server:\n    build: .\n    image: knsock:latest\n    command: [\"udp-server\", \"--port\", \"8081\", \"--host\", \"0.0.0.0\"]\n    ports:\n      - \"8081:8081/udp\"\n    restart: unless-stopped\n</code></pre>"},{"location":"docker/#networking-considerations","title":"Networking Considerations","text":""},{"location":"docker/#host-networking","title":"Host Networking","text":"<p>For development and testing, use host networking:</p> <pre><code>docker run --network host knsock:latest tcp-server --port 8080\n</code></pre> <p>Pros: - Simple configuration - Direct access to host ports - No port mapping required</p> <p>Cons: - Less isolation - Not suitable for production clusters</p>"},{"location":"docker/#bridge-networking-recommended-for-production","title":"Bridge Networking (Recommended for Production)","text":"<pre><code># Run with explicit port mapping\ndocker run -p 8080:8080 knsock:latest tcp-server --port 8080 --host 0.0.0.0\n</code></pre> <p>Pros: - Better isolation - Explicit port control - Works in orchestrated environments</p> <p>Cons: - Requires port mapping configuration</p>"},{"location":"docker/#development-workflow","title":"Development Workflow","text":""},{"location":"docker/#1-code-changes","title":"1. Code Changes","text":"<p>Make changes to your code, then rebuild:</p> <pre><code>docker-compose build\n</code></pre>"},{"location":"docker/#2-testing","title":"2. Testing","text":"<p>Run tests to validate changes:</p> <pre><code>docker-compose run test\n</code></pre>"},{"location":"docker/#3-manual-testing","title":"3. Manual Testing","text":"<p>Test specific functionality:</p> <pre><code># Terminal 1: Start server\ndocker-compose run knsock tcp-server --port 8080\n\n# Terminal 2: Test client\ndocker-compose run knsock tcp-client --host localhost --port 8080 --message \"Test\"\n</code></pre>"},{"location":"docker/#advanced-usage","title":"Advanced Usage","text":""},{"location":"docker/#custom-entrypoint","title":"Custom Entrypoint","text":"<p>Override the default entrypoint for custom applications:</p> <pre><code># Run your own application\ndocker run --rm -v $(pwd):/app --entrypoint python knsock:latest examples/tcp_server.py\n</code></pre>"},{"location":"docker/#environment-variables","title":"Environment Variables","text":"<p>Set environment variables for configuration:</p> <pre><code>docker run --rm \\\n  -e KN_SOCK_DEBUG=1 \\\n  -e KN_SOCK_LOG_LEVEL=DEBUG \\\n  knsock:latest tcp-server --port 8080\n</code></pre>"},{"location":"docker/#volume-mounts","title":"Volume Mounts","text":"<p>Mount specific directories for file operations:</p> <pre><code># Mount data directory for file transfer\ndocker run --rm \\\n  -v $(pwd)/data:/app/data \\\n  --network host \\\n  knsock:latest file-server --port 8080 --directory /app/data\n</code></pre>"},{"location":"docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"docker/#port-already-in-use","title":"Port Already in Use","text":"<pre><code># Check what's using the port\ndocker run --rm --network host nicolaka/netshoot netstat -tuln | grep 8080\n\n# Use a different port\ndocker-compose run knsock tcp-server --port 8081\n</code></pre>"},{"location":"docker/#permission-issues","title":"Permission Issues","text":"<pre><code># Run with specific user\ndocker run --rm --user $(id -u):$(id -g) -v $(pwd):/app knsock:latest --help\n</code></pre>"},{"location":"docker/#container-wont-start","title":"Container Won't Start","text":"<pre><code># Check container logs\ndocker-compose logs knsock\n\n# Run with debug output\ndocker-compose run knsock --debug tcp-server --port 8080\n</code></pre>"},{"location":"docker/#network-connectivity","title":"Network Connectivity","text":"<pre><code># Test network connectivity\ndocker run --rm --network host nicolaka/netshoot ping host.docker.internal\n\n# Check if ports are accessible\ndocker run --rm --network host nicolaka/netshoot telnet localhost 8080\n</code></pre>"},{"location":"docker/#best-practices","title":"Best Practices","text":""},{"location":"docker/#1-use-dockerignore","title":"1. Use .dockerignore","text":"<p>Create <code>.dockerignore</code> to exclude unnecessary files:</p> <pre><code>__pycache__/\n*.pyc\n.git/\n.pytest_cache/\nsite/\nbuild/\n*.egg-info/\n.coverage\nhtmlcov/\n</code></pre>"},{"location":"docker/#2-multi-stage-builds","title":"2. Multi-stage Builds","text":"<p>Use multi-stage builds for smaller production images:</p> <pre><code>FROM python:3.11-slim as dependencies\nRUN pip install kn-sock\n\nFROM python:3.11-slim\nCOPY --from=dependencies /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\n</code></pre>"},{"location":"docker/#3-health-checks","title":"3. Health Checks","text":"<p>Add health checks for production deployments:</p> <pre><code>HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD python -c \"import socket; s=socket.socket(); s.connect(('localhost', 8080)); s.close()\" || exit 1\n</code></pre>"},{"location":"docker/#4-security","title":"4. Security","text":"<ul> <li>Run as non-root user in production</li> <li>Use specific image tags instead of <code>latest</code></li> <li>Scan images for vulnerabilities</li> <li>Use secrets management for sensitive data</li> </ul>"},{"location":"docker/#integration-with-cicd","title":"Integration with CI/CD","text":""},{"location":"docker/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Docker Build and Test\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build Docker image\n        run: docker-compose build\n      - name: Run tests\n        run: docker-compose run test\n      - name: Test CLI\n        run: docker-compose run knsock --help\n</code></pre>"},{"location":"docker/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>test:\n  image: docker:latest\n  services:\n    - docker:dind\n  script:\n    - docker-compose build\n    - docker-compose run test\n</code></pre>"},{"location":"docker/#see-also","title":"See Also","text":"<ul> <li>CLI Guide - Complete CLI reference</li> <li>Getting Started - Basic setup without Docker</li> <li>Troubleshooting - Common issues and solutions</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page showcases real-world examples and complete applications built with kn-sock.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#echo-server-and-client","title":"Echo Server and Client","text":"<p>Server: <pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, client_socket):\n    message = data.decode('utf-8')\n    print(f\"Received from {addr}: {message}\")\n    response = f\"Echo: {message}\"\n    client_socket.sendall(response.encode('utf-8'))\n\nstart_tcp_server(8080, echo_handler)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_tcp_message\n\nmessages = [\"Hello\", \"How are you?\", \"Goodbye\"]\nfor message in messages:\n    send_tcp_message(\"localhost\", 8080, message)\n</code></pre></p>"},{"location":"examples/#file-transfer","title":"File Transfer","text":"<p>Server: <pre><code>from kn_sock import start_file_server\nimport os\n\ndef file_received_handler(filename, filepath, addr):\n    file_size = os.path.getsize(filepath)\n    print(f\"File '{filename}' ({file_size} bytes) received from {addr}\")\n\nstart_file_server(8080, \"/tmp/received\", handler=file_received_handler)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_file\n\nsend_file(\"localhost\", 8080, \"/path/to/file.txt\", show_progress=True)\n</code></pre></p>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#chat-application","title":"Chat Application","text":"<p>Server: <pre><code>from kn_sock import start_websocket_server\nimport json\n\nclass ChatServer:\n    def __init__(self):\n        self.rooms = {}  # room_name -&gt; set of clients\n        self.clients = {}  # client_id -&gt; (ws, room, nickname)\n\n    def handle_client(self, ws):\n        client_id = id(ws)\n        try:\n            while ws.open:\n                message = ws.recv()\n                if not message:\n                    break\n\n                data = json.loads(message)\n                self.process_message(client_id, ws, data)\n        finally:\n            self.remove_client(client_id)\n\n    def process_message(self, client_id, ws, data):\n        msg_type = data.get('type')\n\n        if msg_type == 'join':\n            self.join_room(client_id, ws, data.get('room'), data.get('nickname'))\n        elif msg_type == 'message':\n            self.broadcast_message(client_id, data.get('message'))\n\n    def join_room(self, client_id, ws, room, nickname):\n        if room not in self.rooms:\n            self.rooms[room] = set()\n\n        self.rooms[room].add(client_id)\n        self.clients[client_id] = (ws, room, nickname)\n\n        # Notify others\n        self.broadcast_to_room(room, {\n            'type': 'user_joined',\n            'nickname': nickname\n        }, exclude_client=client_id)\n\n    def broadcast_message(self, client_id, message):\n        if client_id not in self.clients:\n            return\n\n        ws, room, nickname = self.clients[client_id]\n        self.broadcast_to_room(room, {\n            'type': 'message',\n            'nickname': nickname,\n            'message': message\n        })\n\n    def broadcast_to_room(self, room, data, exclude_client=None):\n        if room not in self.rooms:\n            return\n\n        message = json.dumps(data)\n        for client_id in self.rooms[room]:\n            if client_id != exclude_client and client_id in self.clients:\n                ws, _, _ = self.clients[client_id]\n                try:\n                    ws.send(message)\n                except:\n                    pass\n\n    def remove_client(self, client_id):\n        if client_id in self.clients:\n            ws, room, nickname = self.clients[client_id]\n\n            if room in self.rooms:\n                self.rooms[room].discard(client_id)\n\n            del self.clients[client_id]\n\n            self.broadcast_to_room(room, {\n                'type': 'user_left',\n                'nickname': nickname\n            })\n\nserver = ChatServer()\nstart_websocket_server(\"127.0.0.1\", 8765, server.handle_client)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import connect_websocket\nimport json\nimport threading\n\nclass ChatClient:\n    def __init__(self, host, port, room, nickname):\n        self.host = host\n        self.port = port\n        self.room = room\n        self.nickname = nickname\n        self.ws = None\n        self.running = False\n\n    def connect(self):\n        self.ws = connect_websocket(self.host, self.port)\n\n        join_message = {\n            'type': 'join',\n            'room': self.room,\n            'nickname': self.nickname\n        }\n        self.ws.send(json.dumps(join_message))\n\n    def start(self):\n        self.connect()\n        self.running = True\n\n        # Start receive thread\n        receive_thread = threading.Thread(target=self.receive_messages, daemon=True)\n        receive_thread.start()\n\n        # Main input loop\n        try:\n            while self.running:\n                message = input()\n                if message.lower() == 'quit':\n                    break\n                self.send_message(message)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.stop()\n\n    def send_message(self, message):\n        if self.ws and self.ws.open:\n            data = {'type': 'message', 'message': message}\n            self.ws.send(json.dumps(data))\n\n    def receive_messages(self):\n        while self.running and self.ws and self.ws.open:\n            try:\n                message = self.ws.recv()\n                if not message:\n                    break\n\n                data = json.loads(message)\n                self.handle_message(data)\n            except Exception as e:\n                print(f\"Error receiving message: {e}\")\n                break\n\n    def handle_message(self, data):\n        msg_type = data.get('type')\n\n        if msg_type == 'message':\n            nickname = data.get('nickname')\n            message = data.get('message')\n            print(f\"[{nickname}]: {message}\")\n        elif msg_type == 'user_joined':\n            nickname = data.get('nickname')\n            print(f\"*** {nickname} joined the room ***\")\n        elif msg_type == 'user_left':\n            nickname = data.get('nickname')\n            print(f\"*** {nickname} left the room ***\")\n\n    def stop(self):\n        self.running = False\n        if self.ws:\n            self.ws.close()\n\n# Usage\nclient = ChatClient(\"localhost\", 8765, \"general\", \"alice\")\nclient.start()\n</code></pre></p>"},{"location":"examples/#iot-device-simulator","title":"IoT Device Simulator","text":"<p>Device: <pre><code>from kn_sock import send_json\nimport random\nimport time\n\nclass IoTDevice:\n    def __init__(self, device_id, server_host, server_port):\n        self.device_id = device_id\n        self.server_host = server_host\n        self.server_port = server_port\n\n    def generate_sensor_data(self):\n        return {\n            'device_id': self.device_id,\n            'timestamp': time.time(),\n            'temperature': random.uniform(20, 30),\n            'humidity': random.uniform(40, 80),\n            'pressure': random.uniform(1000, 1020)\n        }\n\n    def start(self, interval=5):\n        print(f\"IoT Device {self.device_id} started\")\n\n        try:\n            while True:\n                data = self.generate_sensor_data()\n                try:\n                    send_json(self.server_host, self.server_port, data)\n                    print(f\"\u2713 Data sent: {data['temperature']:.1f}\u00b0C\")\n                except Exception as e:\n                    print(f\"\u2717 Failed to send data: {e}\")\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"Device stopped\")\n\n# Usage\ndevice = IoTDevice(\"sensor001\", \"localhost\", 8080)\ndevice.start()\n</code></pre></p> <p>Server: <pre><code>from kn_sock import start_json_server\nimport json\nimport time\n\nclass IoTServer:\n    def __init__(self):\n        self.devices = {}\n\n    def handle_device_data(self, data, addr, client_socket):\n        device_id = data.get('device_id')\n        self.devices[device_id] = {\n            'data': data,\n            'last_seen': time.time(),\n            'address': addr\n        }\n\n        # Check for alerts\n        alerts = self.check_alerts(data)\n\n        response = {\n            'status': 'received',\n            'device_id': device_id,\n            'alerts': alerts\n        }\n        client_socket.sendall(json.dumps(response).encode('utf-8'))\n\n        print(f\"\ud83d\udcca Data from {device_id}: {data['temperature']:.1f}\u00b0C\")\n\n    def check_alerts(self, data):\n        alerts = []\n\n        if data['temperature'] &gt; 28:\n            alerts.append(f\"High temperature: {data['temperature']:.1f}\u00b0C\")\n        elif data['temperature'] &lt; 22:\n            alerts.append(f\"Low temperature: {data['temperature']:.1f}\u00b0C\")\n\n        return alerts\n\nserver = IoTServer()\nstart_json_server(8080, server.handle_device_data)\n</code></pre></p>"},{"location":"examples/#secure-file-transfer","title":"Secure File Transfer","text":"<p>Server: <pre><code>from kn_sock import start_ssl_tcp_server\nimport os\n\ndef handle_secure_file_transfer(data, addr, client_socket):\n    filename = data.decode().strip()\n\n    try:\n        with open(filename, 'rb') as f:\n            file_data = f.read()\n\n        # Send file size first\n        size_msg = f\"SIZE:{len(file_data)}\".encode()\n        client_socket.sendall(size_msg)\n\n        # Send file data\n        client_socket.sendall(file_data)\n\n    except FileNotFoundError:\n        error_msg = \"ERROR:File not found\".encode()\n        client_socket.sendall(error_msg)\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure_file_transfer,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n)\n</code></pre></p> <p>Client: <pre><code>from kn_sock import send_ssl_tcp_message\nimport os\n\ndef request_file(host, port, filename):\n    try:\n        # Request file\n        send_ssl_tcp_message(host, port, filename)\n        print(f\"Requested file: {filename}\")\n    except Exception as e:\n        print(f\"Error requesting file: {e}\")\n\n# Usage\nrequest_file(\"localhost\", 8443, \"document.pdf\")\n</code></pre></p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install kn-sock\n# For video/audio examples:\npip install opencv-python pyaudio numpy\n</code></pre>"},{"location":"examples/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Echo Server: <pre><code># Terminal 1\npython echo_server.py\n\n# Terminal 2\npython echo_client.py\n</code></pre></p> </li> <li> <p>Chat Application: <pre><code># Terminal 1\npython chat_server.py\n\n# Terminal 2\npython chat_client.py localhost general alice\n\n# Terminal 3\npython chat_client.py localhost general bob\n</code></pre></p> </li> <li> <p>IoT System: <pre><code># Terminal 1\npython iot_server.py\n\n# Terminal 2\npython iot_device.py\n</code></pre></p> </li> </ol>"},{"location":"examples/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic setup and usage</li> <li>API Reference - For detailed function documentation</li> <li>CLI Guide - For command-line examples </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to kn-sock! This guide will help you get up and running with the library quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting-started/#install-kn-sock","title":"Install kn-sock","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"<p>For advanced features like video chat and live streaming, you may need additional packages:</p> <pre><code># For video/audio features\npip install opencv-python pyaudio numpy\n\n# For compression support\npip install tqdm\n\n# For protocol buffers\npip install protobuf\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<p>kn-sock is built around a few core concepts:</p>"},{"location":"getting-started/#1-server-client-pattern","title":"1. Server-Client Pattern","text":"<p>Most kn-sock functionality follows a server-client pattern:</p> <ul> <li>Server: Listens for incoming connections and handles requests</li> <li>Client: Connects to servers and sends requests</li> </ul>"},{"location":"getting-started/#2-message-handlers","title":"2. Message Handlers","text":"<p>Servers use message handler functions to process incoming data:</p> <pre><code>def handle_message(data, addr, client_socket):\n    # Process the received data\n    print(f\"Received: {data.decode()}\")\n    # Send a response\n    client_socket.sendall(b\"Response\")\n</code></pre>"},{"location":"getting-started/#3-synchronous-vs-asynchronous","title":"3. Synchronous vs Asynchronous","text":"<p>kn-sock supports both synchronous and asynchronous operations:</p> <ul> <li>Synchronous: Blocking operations, simpler to understand</li> <li>Asynchronous: Non-blocking operations, better for high-performance applications</li> </ul>"},{"location":"getting-started/#your-first-kn-sock-application","title":"Your First kn-sock Application","text":"<p>Let's create a simple echo server and client:</p>"},{"location":"getting-started/#step-1-create-the-server","title":"Step 1: Create the Server","text":"<p>Create a file called <code>server.py</code>:</p> <pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, client_socket):\n    \"\"\"Echo back any message received\"\"\"\n    message = data.decode('utf-8')\n    print(f\"Received from {addr}: {message}\")\n\n    # Echo the message back\n    response = f\"Echo: {message}\"\n    client_socket.sendall(response.encode('utf-8'))\n\nif __name__ == \"__main__\":\n    print(\"Starting echo server on port 8080...\")\n    start_tcp_server(8080, echo_handler)\n</code></pre>"},{"location":"getting-started/#step-2-create-the-client","title":"Step 2: Create the Client","text":"<p>Create a file called <code>client.py</code>:</p> <pre><code>from kn_sock import send_tcp_message\n\nif __name__ == \"__main__\":\n    message = \"Hello, kn-sock!\"\n    print(f\"Sending: {message}\")\n\n    send_tcp_message(\"localhost\", 8080, message)\n    print(\"Message sent!\")\n</code></pre>"},{"location":"getting-started/#step-3-run-the-application","title":"Step 3: Run the Application","text":"<ol> <li> <p>Start the server in one terminal:    <pre><code>python server.py\n</code></pre></p> </li> <li> <p>Run the client in another terminal:    <pre><code>python client.py\n</code></pre></p> </li> </ol> <p>You should see the message being sent and echoed back!</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics, explore these areas:</p> <ul> <li>TCP Protocol - Learn about TCP communication</li> <li>UDP Protocol - Discover UDP messaging</li> <li>JSON Communication - Send structured data</li> <li>File Transfer - Transfer files between systems</li> </ul>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>For production applications, use shutdown events:</p> <pre><code>import threading\nfrom kn_sock import start_tcp_server\n\nshutdown_event = threading.Event()\n\ndef handler(data, addr, client_socket):\n    # Your handler code here\n    pass\n\n# Start server with shutdown event\nserver_thread = threading.Thread(\n    target=start_tcp_server,\n    args=(8080, handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n\n# Later, to shutdown gracefully:\nshutdown_event.set()\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Always handle potential errors:</p> <pre><code>from kn_sock.errors import EasySocketError, ConnectionTimeoutError\n\ntry:\n    send_tcp_message(\"localhost\", 8080, \"Hello\")\nexcept ConnectionTimeoutError:\n    print(\"Connection timed out\")\nexcept EasySocketError as e:\n    print(f\"Socket error: {e}\")\n</code></pre>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<ol> <li>Port already in use: Use a different port number</li> <li>Connection refused: Make sure the server is running</li> <li>Permission denied: Check if you have permission to bind to the port</li> </ol>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Check the API Reference for detailed function documentation</li> <li>Look at the examples for working code samples</li> <li>Visit the GitHub repository for issues and discussions </li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide provides solutions to common issues you may encounter while using kn-sock.</p>"},{"location":"troubleshooting/#general-issues","title":"General Issues","text":""},{"location":"troubleshooting/#port-conflicts","title":"Port Conflicts","text":"<p>Error: <code>OSError: [Errno 98] Address already in use</code></p> <p>Cause: The port is already used by another process.</p> <p>Solutions: 1. Use a different port number:    <pre><code>start_tcp_server(8081, handler)  # Instead of 8080\n</code></pre></p> <ol> <li> <p>Find and stop the process using the port:    <pre><code># Find the process\nlsof -i :8080\n# or\nnetstat -tuln | grep 8080\n\n# Kill the process (replace PID with actual process ID)\nsudo kill &lt;PID&gt;\n</code></pre></p> </li> <li> <p>Wait for the port to be released (usually takes a few seconds after stopping a server).</p> </li> </ol>"},{"location":"troubleshooting/#permission-issues","title":"Permission Issues","text":"<p>Error: <code>PermissionError: [Errno 13] Permission denied</code></p> <p>Cause: Insufficient permissions to bind to the port.</p> <p>Solutions: 1. Use a port number above 1024 (ports below 1024 require root privileges):    <pre><code>start_tcp_server(8080, handler)  # Instead of 80\n</code></pre></p> <ol> <li>Run with appropriate permissions (not recommended for production):    <pre><code>sudo python your_script.py\n</code></pre></li> </ol>"},{"location":"troubleshooting/#network-connectivity","title":"Network Connectivity","text":"<p>Error: <code>ConnectionRefusedError</code> or <code>TimeoutError</code></p> <p>Cause: Server not running, wrong address/port, or network issues.</p> <p>Solutions: 1. Verify server is running:    <pre><code># Check if server is actually listening\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nresult = sock.connect_ex(('localhost', 8080))\nif result == 0:\n    print(\"Port is open\")\nelse:\n    print(\"Port is closed\")\nsock.close()\n</code></pre></p> <ol> <li> <p>Check firewall settings:    <pre><code># Temporarily disable firewall for testing\nsudo ufw disable  # Ubuntu/Debian\nsudo systemctl stop firewalld  # CentOS/RHEL\n</code></pre></p> </li> <li> <p>Use correct host/port:    <pre><code># Make sure host and port match between client and server\nsend_tcp_message(\"localhost\", 8080, \"Hello\")  # Not 127.0.0.1:8081\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#tcpudp-issues","title":"TCP/UDP Issues","text":""},{"location":"troubleshooting/#connection-timeout","title":"Connection Timeout","text":"<p>Error: <code>ConnectionTimeoutError</code></p> <p>Cause: Network latency or server overload.</p> <p>Solutions: 1. Increase timeout:    <pre><code>import socket\nsocket.setdefaulttimeout(30)  # 30 seconds\n</code></pre></p> <ol> <li>Implement retry logic:    <pre><code>from kn_sock.decorators import retry\n\n@retry(retries=3, delay=1.0)\ndef send_with_retry(host, port, message):\n    send_tcp_message(host, port, message)\n</code></pre></li> </ol>"},{"location":"troubleshooting/#data-corruption","title":"Data Corruption","text":"<p>Error: Unexpected data received</p> <p>Cause: Network issues or encoding problems.</p> <p>Solutions: 1. Use proper encoding:    <pre><code># Server\ndef handler(data, addr, client_socket):\n    message = data.decode('utf-8')  # Specify encoding\n    print(f\"Received: {message}\")\n\n# Client\nsend_tcp_message(\"localhost\", 8080, \"Hello\".encode('utf-8'))\n</code></pre></p> <ol> <li>Implement data validation:    <pre><code>def validate_data(data):\n    try:\n        decoded = data.decode('utf-8')\n        return decoded\n    except UnicodeDecodeError:\n        print(\"Invalid data received\")\n        return None\n</code></pre></li> </ol>"},{"location":"troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":""},{"location":"troubleshooting/#certificate-verification-failed","title":"Certificate Verification Failed","text":"<p>Error: <code>ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]</code></p> <p>Cause: Invalid, missing, or self-signed certificates.</p> <p>Solutions: 1. For testing, disable verification:    <pre><code>send_ssl_tcp_message(\"localhost\", 8443, \"Hello\", verify=False)\n</code></pre></p> <ol> <li> <p>Provide correct certificates:    <pre><code>send_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello\",\n    cafile=\"ca.crt\",\n    certfile=\"client.crt\",\n    keyfile=\"client.key\"\n)\n</code></pre></p> </li> <li> <p>Generate proper certificates:    <pre><code># Generate self-signed certificate for testing\nopenssl req -new -x509 -keyout server.key -out server.crt -days 365 -nodes\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#certificate-file-not-found","title":"Certificate File Not Found","text":"<p>Error: <code>FileNotFoundError: [Errno 2] No such file or directory</code></p> <p>Cause: Certificate files don't exist or wrong path.</p> <p>Solutions: 1. Check file paths:    <pre><code>import os\ncertfile = \"server.crt\"\nif not os.path.exists(certfile):\n    print(f\"Certificate file {certfile} not found\")\n</code></pre></p> <ol> <li>Use absolute paths:    <pre><code>certfile = \"/path/to/server.crt\"\nkeyfile = \"/path/to/server.key\"\n</code></pre></li> </ol>"},{"location":"troubleshooting/#file-transfer-issues","title":"File Transfer Issues","text":""},{"location":"troubleshooting/#file-not-found","title":"File Not Found","text":"<p>Error: <code>FileNotFoundError: [Errno 2] No such file or directory</code></p> <p>Cause: File doesn't exist or wrong path.</p> <p>Solutions: 1. Check file existence:    <pre><code>import os\nif os.path.exists(filepath):\n    send_file(\"localhost\", 8080, filepath)\nelse:\n    print(f\"File {filepath} not found\")\n</code></pre></p> <ol> <li>Use absolute paths:    <pre><code>filepath = os.path.abspath(\"file.txt\")\nsend_file(\"localhost\", 8080, filepath)\n</code></pre></li> </ol>"},{"location":"troubleshooting/#incomplete-file-transfer","title":"Incomplete File Transfer","text":"<p>Error: File received but corrupted or incomplete</p> <p>Cause: Network interruption or insufficient disk space.</p> <p>Solutions: 1. Check disk space:    <pre><code>import shutil\ntotal, used, free = shutil.disk_usage(\"/path/to/save/directory\")\nprint(f\"Free space: {free // (1024**3)} GB\")\n</code></pre></p> <ol> <li> <p>Implement retry logic:    <pre><code>@retry(retries=3, delay=2.0)\ndef send_file_with_retry(host, port, filepath):\n    send_file(host, port, filepath)\n</code></pre></p> </li> <li> <p>Verify file integrity:    <pre><code>import hashlib\n\ndef get_file_hash(filepath):\n    with open(filepath, 'rb') as f:\n        return hashlib.md5(f.read()).hexdigest()\n\n# Before sending\noriginal_hash = get_file_hash(filepath)\n\n# After receiving, verify hash matches\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#videoaudio-issues","title":"Video/Audio Issues","text":""},{"location":"troubleshooting/#pyaudio-errors","title":"PyAudio Errors","text":"<p>Error: <code>OSError: [Errno -9996] Invalid input device</code></p> <p>Cause: Audio device not available or misconfigured.</p> <p>Solutions: 1. Install audio drivers:    <pre><code># Ubuntu/Debian\nsudo apt-get install portaudio19-dev\n\n# Arch Linux\nsudo pacman -S pulseaudio pulseaudio-alsa\n\n# macOS\nbrew install portaudio\n</code></pre></p> <ol> <li> <p>Set audio environment variables:    <pre><code>export PULSE_SERVER=unix:/tmp/pulse-socket\nexport ALSA_PCM_CARD=0\n</code></pre></p> </li> <li> <p>Use audio-only client:    <pre><code>python examples/video_chat_client_no_audio.py 127.0.0.1 myroom alice\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#opencv-camera-issues","title":"OpenCV Camera Issues","text":"<p>Error: <code>cv2.error: OpenCV(4.x.x) /path/to/cap.cpp: error: (-215:Assertion failed)</code></p> <p>Cause: Camera not available or in use.</p> <p>Solutions: 1. Check camera permissions:    <pre><code># Linux\nls -l /dev/video*\nsudo usermod -a -G video $USER\n</code></pre></p> <ol> <li> <p>Test camera separately:    <pre><code>import cv2\ncap = cv2.VideoCapture(0)\nif cap.isOpened():\n    print(\"Camera is working\")\n    cap.release()\nelse:\n    print(\"Camera not available\")\n</code></pre></p> </li> <li> <p>Try different camera indices:    <pre><code># Try different camera numbers\nfor i in range(5):\n    cap = cv2.VideoCapture(i)\n    if cap.isOpened():\n        print(f\"Camera {i} is available\")\n        cap.release()\n        break\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#display-issues","title":"Display Issues","text":"<p>Error: <code>cv2.error: OpenCV(4.x.x) /path/to/window.cpp: error: (-215:Assertion failed)</code></p> <p>Cause: Display backend issues.</p> <p>Solutions: 1. Set display backend:    <pre><code>export QT_QPA_PLATFORM=xcb\nexport DISPLAY=:0\n</code></pre></p> <ol> <li>Use headless mode:    <pre><code>import os\nos.environ['OPENCV_VIDEOIO_PRIORITY_MSMF'] = '0'\n</code></pre></li> </ol>"},{"location":"troubleshooting/#json-communication-issues","title":"JSON Communication Issues","text":""},{"location":"troubleshooting/#invalid-json","title":"Invalid JSON","text":"<p>Error: <code>InvalidJSONError</code> or <code>json.JSONDecodeError</code></p> <p>Cause: Malformed JSON data.</p> <p>Solutions: 1. Validate JSON before sending:    <pre><code>import json\n\ndef send_valid_json(host, port, data):\n    try:\n        json.dumps(data)  # Validate JSON\n        send_json(host, port, data)\n    except TypeError as e:\n        print(f\"Invalid JSON data: {e}\")\n</code></pre></p> <ol> <li>Use JSON decorator:    <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, client_socket):\n    # data is guaranteed to be valid JSON\n    pass\n</code></pre></li> </ol>"},{"location":"troubleshooting/#encoding-issues","title":"Encoding Issues","text":"<p>Error: Unicode encoding/decoding errors</p> <p>Cause: Character encoding mismatches.</p> <p>Solutions: 1. Use UTF-8 encoding:    <pre><code># Server\ndef handler(data, addr, client_socket):\n    try:\n        message = data.decode('utf-8')\n        json_data = json.loads(message)\n    except UnicodeDecodeError:\n        print(\"Invalid encoding\")\n</code></pre></p> <ol> <li>Handle encoding explicitly:    <pre><code># Client\njson_str = json.dumps(data, ensure_ascii=False)\nsend_tcp_message(host, port, json_str.encode('utf-8'))\n</code></pre></li> </ol>"},{"location":"troubleshooting/#websocket-issues","title":"WebSocket Issues","text":""},{"location":"troubleshooting/#connection-failed","title":"Connection Failed","text":"<p>Error: <code>WebSocket connection failed</code></p> <p>Cause: Server not running or protocol mismatch.</p> <p>Solutions: 1. Verify server is running:    <pre><code># Test basic connectivity first\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nresult = sock.connect_ex(('localhost', 8765))\nsock.close()\n</code></pre></p> <ol> <li>Check WebSocket handshake:    <pre><code># Use proper WebSocket client\nws = connect_websocket(\"localhost\", 8765)\nif ws.open:\n    print(\"WebSocket connected successfully\")\n</code></pre></li> </ol>"},{"location":"troubleshooting/#message-format-issues","title":"Message Format Issues","text":"<p>Error: WebSocket messages not received</p> <p>Cause: Incorrect message format or protocol.</p> <p>Solutions: 1. Use proper WebSocket methods:    <pre><code># Send text message\nws.send(\"Hello WebSocket\")\n\n# Receive message\nmessage = ws.recv()\n</code></pre></p> <ol> <li>Handle connection state:    <pre><code>if ws.open:\n    ws.send(message)\nelse:\n    print(\"WebSocket not connected\")\n</code></pre></li> </ol>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Cause: Large buffers or memory leaks.</p> <p>Solutions: 1. Use smaller buffers:    <pre><code># For file transfer\nsend_file(host, port, filepath, chunk_size=1024)\n</code></pre></p> <ol> <li>Implement streaming:    <pre><code>from kn_sock.utils import chunked_file_reader\n\nfor chunk in chunked_file_reader(filepath, chunk_size=4096):\n    # Process chunk\n    pass\n</code></pre></li> </ol>"},{"location":"troubleshooting/#slow-performance","title":"Slow Performance","text":"<p>Cause: Network latency or inefficient code.</p> <p>Solutions: 1. Use connection pooling:    <pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool('localhost', 8080, max_size=5)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello\")\n</code></pre></p> <ol> <li>Use async operations:    <pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello\"))\n</code></pre></li> </ol>"},{"location":"troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Or use kn-sock CLI with verbose flag\n# kn-sock --verbose run-tcp-server 8080\n</code></pre>"},{"location":"troubleshooting/#test-network-connectivity","title":"Test Network Connectivity","text":"<pre><code>def test_connectivity(host, port):\n    import socket\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(5)\n        result = sock.connect_ex((host, port))\n        sock.close()\n        return result == 0\n    except Exception as e:\n        print(f\"Connection test failed: {e}\")\n        return False\n</code></pre>"},{"location":"troubleshooting/#monitor-system-resources","title":"Monitor System Resources","text":"<pre><code># Monitor network connections\nnetstat -tuln\n\n# Monitor process resources\ntop -p $(pgrep -f \"python.*kn-sock\")\n\n# Monitor disk usage\ndf -h\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#check-documentation","title":"Check Documentation","text":"<ul> <li>Review the API Reference for function details</li> <li>Check Getting Started for basic usage</li> <li>Look at examples for working code samples</li> </ul>"},{"location":"troubleshooting/#report-issues","title":"Report Issues","text":"<p>When reporting issues, include:</p> <ol> <li>Environment details:</li> <li>Operating system and version</li> <li>Python version</li> <li> <p>kn-sock version</p> </li> <li> <p>Error details:</p> </li> <li>Complete error message and traceback</li> <li>Steps to reproduce the issue</li> <li> <p>Expected vs actual behavior</p> </li> <li> <p>Code example:</p> </li> <li>Minimal code that reproduces the issue</li> <li> <p>Any relevant configuration</p> </li> <li> <p>System information:</p> </li> <li>Network configuration</li> <li>Firewall settings</li> <li>Available ports</li> </ol>"},{"location":"troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Likely Cause Solution <code>Address already in use</code> Port conflict Use different port or kill existing process <code>Connection refused</code> Server not running Start server first <code>Permission denied</code> Insufficient privileges Use port &gt; 1024 or run with sudo <code>Timeout</code> Network issues Increase timeout or check connectivity <code>Invalid JSON</code> Malformed data Validate JSON before sending <code>SSL certificate failed</code> Certificate issues Use correct certs or disable verification <code>File not found</code> Wrong path Check file existence and path <code>Camera not available</code> Hardware/permission issues Check camera permissions and availability"},{"location":"troubleshooting/#related-topics","title":"Related Topics","text":"<ul> <li>Getting Started - For basic setup and usage</li> <li>API Reference - For detailed function documentation</li> <li>CLI Guide - For command-line troubleshooting </li> </ul>"},{"location":"advanced/http/","title":"HTTP/HTTPS","text":"<p>kn-sock provides simple HTTP and HTTPS client helpers and a basic HTTP server for serving static files and handling API routes.</p>"},{"location":"advanced/http/#http-client","title":"HTTP Client","text":""},{"location":"advanced/http/#basic-http-get","title":"Basic HTTP GET","text":"<pre><code>from kn_sock import http_get\n\n# Simple GET request\nresponse = http_get(\"example.com\", 80, \"/\")\nprint(response)\n\n# GET with custom headers\nheaders = {\n    \"User-Agent\": \"kn-sock/1.0\",\n    \"Accept\": \"application/json\"\n}\nresponse = http_get(\"api.example.com\", 80, \"/users\", headers=headers)\nprint(response)\n</code></pre>"},{"location":"advanced/http/#http-post","title":"HTTP POST","text":"<pre><code>from kn_sock import http_post\n\n# POST with form data\ndata = \"name=John&amp;email=john@example.com\"\nresponse = http_post(\"api.example.com\", 80, \"/users\", data=data)\n\n# POST with JSON data\nimport json\njson_data = json.dumps({\"name\": \"John\", \"email\": \"john@example.com\"})\nheaders = {\"Content-Type\": \"application/json\"}\nresponse = http_post(\"api.example.com\", 80, \"/users\", data=json_data, headers=headers)\n</code></pre>"},{"location":"advanced/http/#https-client","title":"HTTPS Client","text":""},{"location":"advanced/http/#https-get","title":"HTTPS GET","text":"<pre><code>from kn_sock import https_get\n\n# Simple HTTPS GET\nresponse = https_get(\"example.com\", 443, \"/\")\nprint(response)\n\n# HTTPS GET with certificate verification\nresponse = https_get(\"api.example.com\", 443, \"/secure\", cafile=\"ca.crt\")\n</code></pre>"},{"location":"advanced/http/#https-post","title":"HTTPS POST","text":"<pre><code>from kn_sock import https_post\n\n# HTTPS POST with JSON\nimport json\ndata = json.dumps({\"action\": \"login\", \"username\": \"user\", \"password\": \"pass\"})\nheaders = {\"Content-Type\": \"application/json\"}\n\nresponse = https_post(\"api.example.com\", 443, \"/auth\", data=data, headers=headers)\nprint(response)\n</code></pre>"},{"location":"advanced/http/#http-server","title":"HTTP Server","text":""},{"location":"advanced/http/#basic-http-server","title":"Basic HTTP Server","text":"<pre><code>from kn_sock import start_http_server\n\n# Start server serving static files\nstart_http_server(\"127.0.0.1\", 8080, static_dir=\"/path/to/static/files\")\n</code></pre>"},{"location":"advanced/http/#http-server-with-custom-routes","title":"HTTP Server with Custom Routes","text":"<pre><code>from kn_sock import start_http_server\nimport json\n\ndef hello_handler(request, client_socket):\n    \"\"\"Handle /hello route\"\"\"\n    response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nHello\"\n    client_socket.sendall(response.encode())\n\ndef api_handler(request, client_socket):\n    \"\"\"Handle /api route\"\"\"\n    data = {\"message\": \"Hello from API\", \"status\": \"success\"}\n    response_json = json.dumps(data)\n\n    response = f\"\"\"HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: {len(response_json)}\n\n{response_json}\"\"\"\n    client_socket.sendall(response.encode())\n\ndef echo_handler(request, client_socket):\n    \"\"\"Handle POST /echo route\"\"\"\n    # Extract body from request\n    body = request['raw'].decode('utf-8').split('\\r\\n\\r\\n', 1)[-1]\n\n    response = f\"\"\"HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: {len(body)}\n\n{body}\"\"\"\n    client_socket.sendall(response.encode())\n\n# Define routes\nroutes = {\n    (\"GET\", \"/hello\"): hello_handler,\n    (\"GET\", \"/api\"): api_handler,\n    (\"POST\", \"/echo\"): echo_handler,\n}\n\n# Start server with routes\nstart_http_server(\"127.0.0.1\", 8080, static_dir=\"static\", routes=routes)\n</code></pre>"},{"location":"advanced/http/#use-cases","title":"Use Cases","text":""},{"location":"advanced/http/#simple-api-client","title":"Simple API Client","text":"<pre><code>from kn_sock import http_get, http_post\nimport json\n\nclass APIClient:\n    def __init__(self, host, port=80):\n        self.host = host\n        self.port = port\n        self.headers = {\"Content-Type\": \"application/json\"}\n\n    def get_users(self):\n        \"\"\"Get all users\"\"\"\n        response = http_get(self.host, self.port, \"/api/users\", headers=self.headers)\n        return json.loads(response)\n\n    def create_user(self, name, email):\n        \"\"\"Create a new user\"\"\"\n        data = json.dumps({\"name\": name, \"email\": email})\n        response = http_post(self.host, self.port, \"/api/users\", data=data, headers=self.headers)\n        return json.loads(response)\n\n    def update_user(self, user_id, **kwargs):\n        \"\"\"Update a user\"\"\"\n        data = json.dumps(kwargs)\n        response = http_post(self.host, self.port, f\"/api/users/{user_id}\", data=data, headers=self.headers)\n        return json.loads(response)\n\n# Usage\nclient = APIClient(\"api.example.com\")\nusers = client.get_users()\nnew_user = client.create_user(\"Alice\", \"alice@example.com\")\n</code></pre>"},{"location":"advanced/http/#file-upload-server","title":"File Upload Server","text":"<pre><code>from kn_sock import start_http_server\nimport os\n\ndef upload_handler(request, client_socket):\n    \"\"\"Handle file uploads\"\"\"\n    try:\n        # Parse multipart form data (simplified)\n        body = request['raw'].decode('utf-8').split('\\r\\n\\r\\n', 1)[-1]\n\n        # Extract filename and content (simplified parsing)\n        if 'filename=' in body:\n            filename_start = body.find('filename=\"') + 10\n            filename_end = body.find('\"', filename_start)\n            filename = body[filename_start:filename_end]\n\n            # Extract file content\n            content_start = body.find('\\r\\n\\r\\n', body.find('Content-Type:')) + 4\n            content = body[content_start:].split('\\r\\n--')[0]\n\n            # Save file\n            with open(f\"uploads/{filename}\", \"w\") as f:\n                f.write(content)\n\n            response = f\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 20\\r\\n\\r\\nFile uploaded successfully\"\n        else:\n            response = \"HTTP/1.1 400 Bad Request\\r\\nContent-Type: text/plain\\r\\nContent-Length: 15\\r\\n\\r\\nNo file provided\"\n\n        client_socket.sendall(response.encode())\n\n    except Exception as e:\n        error_response = f\"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: {len(str(e))}\\r\\n\\r\\n{str(e)}\"\n        client_socket.sendall(error_response.encode())\n\n# Create uploads directory\nos.makedirs(\"uploads\", exist_ok=True)\n\n# Start server\nroutes = {(\"POST\", \"/upload\"): upload_handler}\nstart_http_server(\"127.0.0.1\", 8080, routes=routes)\n</code></pre>"},{"location":"advanced/http/#webhook-receiver","title":"Webhook Receiver","text":"<pre><code>from kn_sock import start_http_server\nimport json\nimport hmac\nimport hashlib\n\nclass WebhookReceiver:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def verify_signature(self, payload, signature):\n        \"\"\"Verify webhook signature\"\"\"\n        expected_signature = hmac.new(\n            self.secret_key.encode(),\n            payload.encode(),\n            hashlib.sha256\n        ).hexdigest()\n        return hmac.compare_digest(f\"sha256={expected_signature}\", signature)\n\n    def handle_webhook(self, request, client_socket):\n        \"\"\"Handle incoming webhook\"\"\"\n        try:\n            # Extract headers and body\n            headers = {}\n            body = \"\"\n\n            request_text = request['raw'].decode('utf-8')\n            parts = request_text.split('\\r\\n\\r\\n', 1)\n\n            if len(parts) &gt; 1:\n                header_text, body = parts\n\n                # Parse headers\n                for line in header_text.split('\\r\\n')[1:]:\n                    if ':' in line:\n                        key, value = line.split(':', 1)\n                        headers[key.strip()] = value.strip()\n\n            # Verify signature\n            signature = headers.get('X-Hub-Signature-256', '')\n            if not self.verify_signature(body, signature):\n                response = \"HTTP/1.1 401 Unauthorized\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nUnauthorized\"\n                client_socket.sendall(response.encode())\n                return\n\n            # Process webhook\n            webhook_data = json.loads(body)\n            self.process_webhook(webhook_data)\n\n            # Send success response\n            response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 2\\r\\n\\r\\nOK\"\n            client_socket.sendall(response.encode())\n\n        except Exception as e:\n            error_response = f\"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: {len(str(e))}\\r\\n\\r\\n{str(e)}\"\n            client_socket.sendall(error_response.encode())\n\n    def process_webhook(self, data):\n        \"\"\"Process webhook data\"\"\"\n        event_type = data.get('event_type')\n\n        if event_type == 'user.created':\n            print(f\"New user created: {data.get('user', {}).get('email')}\")\n        elif event_type == 'payment.completed':\n            print(f\"Payment completed: {data.get('payment', {}).get('amount')}\")\n        else:\n            print(f\"Unknown event type: {event_type}\")\n\n# Usage\nwebhook_receiver = WebhookReceiver(\"your-secret-key\")\nroutes = {(\"POST\", \"/webhook\"): webhook_receiver.handle_webhook}\nstart_http_server(\"127.0.0.1\", 8080, routes=routes)\n</code></pre>"},{"location":"advanced/http/#error-handling","title":"Error Handling","text":""},{"location":"advanced/http/#client-error-handling","title":"Client Error Handling","text":"<pre><code>from kn_sock import http_get\nimport socket\n\ndef safe_http_get(host, port, path, headers=None):\n    \"\"\"Safely make HTTP GET request with error handling\"\"\"\n    try:\n        response = http_get(host, port, path, headers=headers)\n        return response\n    except socket.timeout:\n        print(f\"Timeout connecting to {host}:{port}\")\n        return None\n    except ConnectionRefusedError:\n        print(f\"Connection refused to {host}:{port}\")\n        return None\n    except Exception as e:\n        print(f\"Error making request: {e}\")\n        return None\n\n# Usage\nresponse = safe_http_get(\"example.com\", 80, \"/\")\nif response:\n    print(\"Request successful\")\nelse:\n    print(\"Request failed\")\n</code></pre>"},{"location":"advanced/http/#server-error-handling","title":"Server Error Handling","text":"<pre><code>from kn_sock import start_http_server\n\ndef safe_handler(request, client_socket):\n    \"\"\"Handler with error handling\"\"\"\n    try:\n        # Your handler logic here\n        response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nHello\"\n        client_socket.sendall(response.encode())\n    except Exception as e:\n        # Send error response\n        error_msg = f\"Internal Server Error: {str(e)}\"\n        error_response = f\"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: {len(error_msg)}\\r\\n\\r\\n{error_msg}\"\n        client_socket.sendall(error_response.encode())\n\nroutes = {(\"GET\", \"/safe\"): safe_handler}\nstart_http_server(\"127.0.0.1\", 8080, routes=routes)\n</code></pre>"},{"location":"advanced/http/#limitations","title":"Limitations","text":""},{"location":"advanced/http/#current-limitations","title":"Current Limitations","text":"<ul> <li>No support for redirects</li> <li>No support for chunked encoding</li> <li>No support for cookies</li> <li>No support for HTTP/2</li> <li>Limited header parsing</li> <li>No support for streaming responses</li> </ul>"},{"location":"advanced/http/#workarounds","title":"Workarounds","text":"<p>For advanced HTTP features, consider using a full HTTP library like <code>requests</code> or <code>httpx</code>:</p> <pre><code>import requests\n\n# For complex HTTP operations\nresponse = requests.get(\"https://api.example.com/users\", \n                       headers={\"Authorization\": \"Bearer token\"},\n                       timeout=30)\ndata = response.json()\n</code></pre>"},{"location":"advanced/http/#best-practices","title":"Best Practices","text":""},{"location":"advanced/http/#security","title":"Security","text":"<ol> <li>Always validate input in server handlers</li> <li>Use HTTPS for sensitive data</li> <li>Implement proper authentication for APIs</li> <li>Validate file uploads to prevent security issues</li> <li>Use proper error handling to avoid information leakage</li> </ol>"},{"location":"advanced/http/#performance","title":"Performance","text":"<ol> <li>Use connection pooling for multiple requests</li> <li>Implement caching for static content</li> <li>Compress responses for large data</li> <li>Use async operations for high concurrency</li> </ol>"},{"location":"advanced/http/#reliability","title":"Reliability","text":"<ol> <li>Implement retry logic for failed requests</li> <li>Use timeouts to prevent hanging connections</li> <li>Handle network errors gracefully</li> <li>Log errors for debugging</li> </ol>"},{"location":"advanced/http/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For underlying transport</li> <li>Secure TCP - For HTTPS functionality</li> <li>API Reference - For complete function documentation </li> </ul>"},{"location":"advanced/live-streaming/","title":"Live Streaming","text":"<p>kn-sock provides advanced live video and audio streaming capabilities with multi-video support, adaptive bitrate, and smooth playback.</p>"},{"location":"advanced/live-streaming/#overview","title":"Overview","text":"<p>Live streaming features in kn-sock: - Multi-Video Support: Server can offer multiple videos; clients select which to play - Adaptive Bitrate: Server adjusts video quality per client based on buffer feedback - Jitter Buffer: Client-side buffering for smooth video/audio playback - Robust Audio Protocol: Audio stream uses magic numbers and timestamps for resynchronization - Real-time Feedback: Client sends buffer status to server for quality adjustment</p>"},{"location":"advanced/live-streaming/#basic-live-streaming","title":"Basic Live Streaming","text":""},{"location":"advanced/live-streaming/#live-stream-server","title":"Live Stream Server","text":"<pre><code>from kn_sock import start_live_stream\n\n# Start a live stream server with multiple videos\nstart_live_stream(9000, [\"video1.mp4\", \"video2.mp4\", \"video3.mp4\"])\n\n# Or with a single video\nstart_live_stream(9000, [\"video.mp4\"])\n</code></pre>"},{"location":"advanced/live-streaming/#live-stream-client","title":"Live Stream Client","text":"<pre><code>from kn_sock import connect_to_live_server\n\n# Connect to a live stream server\nconnect_to_live_server(\"192.168.1.10\", 9000)\n</code></pre>"},{"location":"advanced/live-streaming/#advanced-usage","title":"Advanced Usage","text":""},{"location":"advanced/live-streaming/#custom-server-configuration","title":"Custom Server Configuration","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer\n\n# Server with custom configuration\nserver = LiveStreamServer(\n    video_paths=[\"video1.mp4\", \"video2.mp4\"],\n    host='0.0.0.0',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010\n)\nserver.start()\n</code></pre>"},{"location":"advanced/live-streaming/#custom-client-configuration","title":"Custom Client Configuration","text":"<pre><code>from kn_sock.live_stream import LiveStreamClient\n\n# Client with custom buffer settings\nclient = LiveStreamClient(\n    host='127.0.0.1',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010,\n    video_buffer_ms=200,  # 200ms video buffer\n    audio_buffer_ms=100,  # 100ms audio buffer\n    video_fps=30\n)\nclient.start()\n</code></pre>"},{"location":"advanced/live-streaming/#cli-usage","title":"CLI Usage","text":""},{"location":"advanced/live-streaming/#start-live-stream-server","title":"Start Live Stream Server","text":"<pre><code># Start with multiple videos\nkn-sock run-live-server 9000 video1.mp4 video2.mp4 video3.mp4\n\n# Start with custom host and audio port\nkn-sock run-live-server 9000 video.mp4 --host 0.0.0.0 --audio-port 9001\n</code></pre>"},{"location":"advanced/live-streaming/#connect-as-live-stream-client","title":"Connect as Live Stream Client","text":"<pre><code># Connect to server\nkn-sock connect-live-server 192.168.1.10 9000\n\n# Connect with custom audio port\nkn-sock connect-live-server 192.168.1.10 9000 --audio-port 9001\n</code></pre>"},{"location":"advanced/live-streaming/#how-it-works","title":"How It Works","text":""},{"location":"advanced/live-streaming/#1-server-setup","title":"1. Server Setup","text":"<p>The server extracts audio from video files using FFmpeg and prepares for streaming:</p> <pre><code>from kn_sock.live_stream import LiveStreamServer\n\nserver = LiveStreamServer(\n    video_paths=[\"movie1.mp4\", \"movie2.mp4\", \"documentary.mp4\"],\n    host='0.0.0.0',\n    video_port=9000,\n    audio_port=9001,\n    control_port=9010\n)\n\nprint(\"Available videos:\")\nfor i, video in enumerate(server.video_paths):\n    print(f\"{i+1}. {video}\")\n\nserver.start()\n</code></pre>"},{"location":"advanced/live-streaming/#2-client-connection","title":"2. Client Connection","text":"<p>Clients connect to video, audio, and control ports:</p> <pre><code>from kn_sock.live_stream import LiveStreamClient\n\nclient = LiveStreamClient(\n    host='192.168.1.10',\n    video_port=9000,\n    audio_port=9001,\n    control_port=9010,\n    video_buffer_ms=300,  # Larger buffer for slower connections\n    audio_buffer_ms=150,\n    video_fps=25  # Lower FPS for bandwidth optimization\n)\n\nclient.start()\n</code></pre>"},{"location":"advanced/live-streaming/#3-video-selection","title":"3. Video Selection","text":"<p>If multiple videos are available, clients are prompted to select one:</p> <pre><code># The client will automatically show available videos\n# and allow selection if multiple videos are offered\n</code></pre>"},{"location":"advanced/live-streaming/#4-adaptive-streaming","title":"4. Adaptive Streaming","text":"<p>The server adjusts video quality based on client feedback:</p> <pre><code># Server automatically adjusts JPEG quality (40-90) based on:\n# - Client buffer levels\n# - Network conditions\n# - Client feedback\n</code></pre>"},{"location":"advanced/live-streaming/#protocol-details","title":"Protocol Details","text":""},{"location":"advanced/live-streaming/#video-protocol","title":"Video Protocol","text":"<p>Each video frame is sent with timestamp and length information:</p> <pre><code>[8-byte timestamp][4-byte length][JPEG data]\n</code></pre>"},{"location":"advanced/live-streaming/#audio-protocol","title":"Audio Protocol","text":"<p>Audio chunks include magic numbers and timestamps for synchronization:</p> <pre><code>[4-byte magic][8-byte timestamp][4-byte length][audio data]\n</code></pre>"},{"location":"advanced/live-streaming/#control-protocol","title":"Control Protocol","text":"<p>Clients send JSON feedback for adaptive quality:</p> <pre><code>{\n    \"buffer_level\": 0.2,\n    \"network_quality\": \"good\",\n    \"timestamp\": 1234567890.123\n}\n</code></pre>"},{"location":"advanced/live-streaming/#configuration-options","title":"Configuration Options","text":""},{"location":"advanced/live-streaming/#server-configuration","title":"Server Configuration","text":"Parameter Description Default <code>video_paths</code> List of video file paths Required <code>host</code> Host to bind '0.0.0.0' <code>video_port</code> Port for video stream 9000 <code>audio_port</code> Port for audio stream 9001 <code>control_port</code> Port for control messages 9010 <code>video_fps</code> Target video FPS 30 <code>jpeg_quality</code> Initial JPEG quality 70"},{"location":"advanced/live-streaming/#client-configuration","title":"Client Configuration","text":"Parameter Description Default <code>host</code> Server host Required <code>video_port</code> Video stream port 9000 <code>audio_port</code> Audio stream port 9001 <code>control_port</code> Control port 9010 <code>video_buffer_ms</code> Video buffer size 200 <code>audio_buffer_ms</code> Audio buffer size 100 <code>video_fps</code> Target FPS 30"},{"location":"advanced/live-streaming/#use-cases","title":"Use Cases","text":""},{"location":"advanced/live-streaming/#multi-room-video-streaming","title":"Multi-Room Video Streaming","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer\nimport threading\n\ndef start_room(room_name, videos, port_base):\n    \"\"\"Start a streaming room\"\"\"\n    server = LiveStreamServer(\n        video_paths=videos,\n        host='0.0.0.0',\n        video_port=port_base,\n        audio_port=port_base + 1,\n        control_port=port_base + 10\n    )\n\n    print(f\"Starting {room_name} on ports {port_base}, {port_base+1}, {port_base+10}\")\n    server.start()\n\n# Start multiple rooms\nrooms = [\n    (\"Action Movies\", [\"action1.mp4\", \"action2.mp4\"], 9000),\n    (\"Comedy Movies\", [\"comedy1.mp4\", \"comedy2.mp4\"], 9100),\n    (\"Documentaries\", [\"doc1.mp4\", \"doc2.mp4\"], 9200)\n]\n\nfor room_name, videos, port_base in rooms:\n    thread = threading.Thread(\n        target=start_room,\n        args=(room_name, videos, port_base),\n        daemon=True\n    )\n    thread.start()\n</code></pre>"},{"location":"advanced/live-streaming/#adaptive-quality-streaming","title":"Adaptive Quality Streaming","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer\n\nclass AdaptiveStreamServer(LiveStreamServer):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.client_qualities = {}  # Track quality per client\n\n    def adjust_quality_for_client(self, client_addr, buffer_level):\n        \"\"\"Adjust video quality based on client buffer\"\"\"\n        current_quality = self.client_qualities.get(client_addr, 70)\n\n        if buffer_level &lt; 0.1:  # Low buffer\n            new_quality = max(40, current_quality - 10)\n        elif buffer_level &gt; 0.8:  # High buffer\n            new_quality = min(90, current_quality + 5)\n        else:\n            new_quality = current_quality\n\n        self.client_qualities[client_addr] = new_quality\n        return new_quality\n\nserver = AdaptiveStreamServer(\n    video_paths=[\"movie.mp4\"],\n    host='0.0.0.0',\n    video_port=9000\n)\nserver.start()\n</code></pre>"},{"location":"advanced/live-streaming/#bandwidth-monitoring","title":"Bandwidth Monitoring","text":"<pre><code>from kn_sock.live_stream import LiveStreamClient\nimport time\n\nclass MonitoredClient(LiveStreamClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.bytes_received = 0\n        self.start_time = time.time()\n\n    def on_video_frame(self, frame_data):\n        \"\"\"Called when video frame is received\"\"\"\n        self.bytes_received += len(frame_data)\n        self.log_bandwidth()\n\n    def log_bandwidth(self):\n        \"\"\"Log current bandwidth usage\"\"\"\n        elapsed = time.time() - self.start_time\n        if elapsed &gt; 0:\n            bandwidth_mbps = (self.bytes_received * 8) / (elapsed * 1024 * 1024)\n            print(f\"Current bandwidth: {bandwidth_mbps:.2f} Mbps\")\n\nclient = MonitoredClient(\n    host='192.168.1.10',\n    video_port=9000,\n    audio_port=9001\n)\nclient.start()\n</code></pre>"},{"location":"advanced/live-streaming/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/live-streaming/#buffer-tuning","title":"Buffer Tuning","text":"<pre><code># For high-latency networks\nclient = LiveStreamClient(\n    host='remote-server.com',\n    video_buffer_ms=500,  # Larger buffer\n    audio_buffer_ms=200,\n    video_fps=24  # Lower FPS\n)\n\n# For low-latency requirements\nclient = LiveStreamClient(\n    host='local-server',\n    video_buffer_ms=100,  # Smaller buffer\n    audio_buffer_ms=50,\n    video_fps=60  # Higher FPS\n)\n</code></pre>"},{"location":"advanced/live-streaming/#quality-optimization","title":"Quality Optimization","text":"<pre><code># Server with quality optimization\nserver = LiveStreamServer(\n    video_paths=[\"video.mp4\"],\n    video_fps=30,\n    jpeg_quality=80,  # Higher initial quality\n    adaptive_quality=True\n)\n\n# Client with quality preferences\nclient = LiveStreamClient(\n    host='server',\n    video_port=9000,\n    max_quality=85,  # Maximum quality preference\n    min_quality=50   # Minimum quality preference\n)\n</code></pre>"},{"location":"advanced/live-streaming/#error-handling","title":"Error Handling","text":""},{"location":"advanced/live-streaming/#network-issues","title":"Network Issues","text":"<pre><code>from kn_sock.live_stream import LiveStreamClient\nimport time\n\ndef resilient_client():\n    while True:\n        try:\n            client = LiveStreamClient(\n                host='192.168.1.10',\n                video_port=9000,\n                audio_port=9001\n            )\n            client.start()\n        except Exception as e:\n            print(f\"Connection lost: {e}\")\n            print(\"Reconnecting in 5 seconds...\")\n            time.sleep(5)\n\nresilient_client()\n</code></pre>"},{"location":"advanced/live-streaming/#video-file-issues","title":"Video File Issues","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer\nimport os\n\ndef validate_videos(video_paths):\n    \"\"\"Validate video files before starting server\"\"\"\n    valid_videos = []\n\n    for video_path in video_paths:\n        if os.path.exists(video_path):\n            # Check if it's a valid video file\n            if video_path.lower().endswith(('.mp4', '.avi', '.mkv')):\n                valid_videos.append(video_path)\n            else:\n                print(f\"Warning: {video_path} is not a supported video format\")\n        else:\n            print(f\"Warning: {video_path} not found\")\n\n    return valid_videos\n\nvideo_paths = [\"video1.mp4\", \"video2.mp4\", \"invalid.txt\"]\nvalid_videos = validate_videos(video_paths)\n\nif valid_videos:\n    server = LiveStreamServer(video_paths=valid_videos)\n    server.start()\nelse:\n    print(\"No valid videos found\")\n</code></pre>"},{"location":"advanced/live-streaming/#requirements","title":"Requirements","text":""},{"location":"advanced/live-streaming/#python-dependencies","title":"Python Dependencies","text":"<pre><code>pip install opencv-python pyaudio numpy\n</code></pre>"},{"location":"advanced/live-streaming/#system-dependencies","title":"System Dependencies","text":"<ul> <li>FFmpeg: Required for audio extraction   <pre><code># Ubuntu/Debian\nsudo apt-get install ffmpeg\n\n# macOS\nbrew install ffmpeg\n\n# Windows\n# Download from https://ffmpeg.org/download.html\n</code></pre></li> </ul>"},{"location":"advanced/live-streaming/#network-requirements","title":"Network Requirements","text":"<ul> <li>TCP ports for video, audio, and control streams</li> <li>Sufficient bandwidth for video streaming</li> <li>Low latency for real-time streaming</li> </ul>"},{"location":"advanced/live-streaming/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/live-streaming/#common-issues","title":"Common Issues","text":"<ol> <li>Video not playing</li> <li>Check video file format (mp4 recommended)</li> <li>Ensure FFmpeg is installed</li> <li> <p>Verify video file is not corrupted</p> </li> <li> <p>Audio issues</p> </li> <li>Check PyAudio installation</li> <li>Verify audio drivers</li> <li> <p>Test with audio-only files</p> </li> <li> <p>Poor performance</p> </li> <li>Reduce video FPS</li> <li>Increase buffer sizes</li> <li> <p>Check network bandwidth</p> </li> <li> <p>Connection issues</p> </li> <li>Verify firewall settings</li> <li>Check port availability</li> <li>Test network connectivity</li> </ol>"},{"location":"advanced/live-streaming/#diagnostic-tools","title":"Diagnostic Tools","text":"<pre><code># Test video file compatibility\nfrom kn_sock.live_stream import LiveStreamServer\n\ndef test_video(video_path):\n    try:\n        server = LiveStreamServer(video_paths=[video_path])\n        print(f\"\u2713 {video_path} is compatible\")\n        return True\n    except Exception as e:\n        print(f\"\u2717 {video_path} failed: {e}\")\n        return False\n\n# Test multiple videos\nvideos = [\"video1.mp4\", \"video2.avi\", \"video3.mkv\"]\nfor video in videos:\n    test_video(video)\n</code></pre>"},{"location":"advanced/live-streaming/#related-topics","title":"Related Topics","text":"<ul> <li>Video Chat - For real-time video communication</li> <li>TCP Protocol - For underlying transport</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"advanced/pubsub/","title":"Publish/Subscribe Messaging","text":"<p>kn-sock provides a robust publish/subscribe (pub/sub) messaging system for decoupled, scalable communication between applications.</p>"},{"location":"advanced/pubsub/#overview","title":"Overview","text":"<p>Pub/Sub features in kn-sock: - Topic-based messaging: Organize messages by topics - Multiple subscribers: Many clients can subscribe to the same topic - Message persistence: Optional message persistence and replay - Quality of Service: Configurable delivery guarantees - Broker architecture: Centralized message distribution - Pattern matching: Subscribe to topics using wildcards - Message filtering: Server-side message filtering capabilities</p>"},{"location":"advanced/pubsub/#basic-pubsub-usage","title":"Basic Pub/Sub Usage","text":""},{"location":"advanced/pubsub/#starting-a-pubsub-broker","title":"Starting a Pub/Sub Broker","text":"<pre><code>from kn_sock import start_pubsub_broker\n\ndef message_handler(topic, message, publisher_info):\n    \"\"\"\n    Handle published messages (optional custom processing).\n\n    Args:\n        topic (str): The topic the message was published to\n        message (str): The message content\n        publisher_info (dict): Information about the publisher\n    \"\"\"\n    print(f\"Message on topic '{topic}': {message}\")\n    print(f\"Published by: {publisher_info}\")\n\n# Start the pub/sub broker\nstart_pubsub_broker(\n    port=8080,\n    host='0.0.0.0',\n    message_handler=message_handler,  # Optional\n    persistence=True,  # Enable message persistence\n    max_messages=1000  # Maximum messages to store per topic\n)\n</code></pre>"},{"location":"advanced/pubsub/#publisher-client","title":"Publisher Client","text":"<pre><code>from kn_sock import PubSubPublisher\n\ndef publisher_example():\n    \"\"\"Example publisher client.\"\"\"\n\n    # Connect to the broker\n    publisher = PubSubPublisher(\"localhost\", 8080)\n\n    try:\n        # Publish messages to different topics\n        publisher.publish(\"news/technology\", \"New AI breakthrough announced!\")\n        publisher.publish(\"news/sports\", \"Championship game tonight\")\n        publisher.publish(\"alerts/system\", \"Server maintenance scheduled\")\n\n        # Publish with metadata\n        publisher.publish(\n            \"user/updates\", \n            \"User profile updated\",\n            metadata={\n                \"user_id\": \"12345\",\n                \"timestamp\": \"2024-01-15T10:30:00Z\",\n                \"priority\": \"normal\"\n            }\n        )\n\n        # Publish JSON data\n        import json\n        data = {\n            \"event\": \"order_created\",\n            \"order_id\": \"ORD-789\",\n            \"amount\": 99.99,\n            \"customer\": \"john@example.com\"\n        }\n        publisher.publish(\"orders/created\", json.dumps(data))\n\n    finally:\n        publisher.disconnect()\n\npublisher_example()\n</code></pre>"},{"location":"advanced/pubsub/#subscriber-client","title":"Subscriber Client","text":"<pre><code>from kn_sock import PubSubSubscriber\nimport threading\n\ndef subscriber_example():\n    \"\"\"Example subscriber client.\"\"\"\n\n    # Connect to the broker\n    subscriber = PubSubSubscriber(\"localhost\", 8080)\n\n    def handle_news_message(topic, message, metadata=None):\n        \"\"\"Handle news messages.\"\"\"\n        print(f\"NEWS: [{topic}] {message}\")\n        if metadata:\n            print(f\"Metadata: {metadata}\")\n\n    def handle_alert_message(topic, message, metadata=None):\n        \"\"\"Handle alert messages.\"\"\"\n        print(f\"ALERT: [{topic}] {message}\")\n        # Could trigger notifications, emails, etc.\n\n    def handle_order_message(topic, message, metadata=None):\n        \"\"\"Handle order messages.\"\"\"\n        import json\n        try:\n            order_data = json.loads(message)\n            print(f\"ORDER: {order_data['event']} - ID: {order_data['order_id']}\")\n        except json.JSONDecodeError:\n            print(f\"ORDER: [{topic}] {message}\")\n\n    try:\n        # Subscribe to specific topics\n        subscriber.subscribe(\"news/technology\", handle_news_message)\n        subscriber.subscribe(\"news/sports\", handle_news_message)\n        subscriber.subscribe(\"alerts/system\", handle_alert_message)\n        subscriber.subscribe(\"orders/created\", handle_order_message)\n\n        # Subscribe with wildcards\n        subscriber.subscribe(\"user/*\", lambda t, m, meta: print(f\"USER EVENT: [{t}] {m}\"))\n\n        # Start listening for messages\n        print(\"Subscriber started. Press Ctrl+C to stop.\")\n        subscriber.start_listening()\n\n    except KeyboardInterrupt:\n        print(\"\\nShutting down subscriber...\")\n    finally:\n        subscriber.disconnect()\n\nsubscriber_example()\n</code></pre>"},{"location":"advanced/pubsub/#advanced-pubsub-features","title":"Advanced Pub/Sub Features","text":""},{"location":"advanced/pubsub/#message-persistence-and-replay","title":"Message Persistence and Replay","text":"<pre><code>from kn_sock import PubSubBroker, PubSubSubscriber\n\nclass PersistentPubSubBroker(PubSubBroker):\n    \"\"\"Pub/Sub broker with advanced persistence features.\"\"\"\n\n    def __init__(self, port, host='0.0.0.0'):\n        super().__init__(port, host)\n        self.message_history = {}  # topic -&gt; list of messages\n        self.max_history_per_topic = 100\n\n    def publish_message(self, topic, message, publisher_info, metadata=None):\n        \"\"\"Publish message with persistence.\"\"\"\n\n        # Store message in history\n        if topic not in self.message_history:\n            self.message_history[topic] = []\n\n        message_entry = {\n            \"message\": message,\n            \"publisher\": publisher_info,\n            \"metadata\": metadata,\n            \"timestamp\": time.time()\n        }\n\n        self.message_history[topic].append(message_entry)\n\n        # Limit history size\n        if len(self.message_history[topic]) &gt; self.max_history_per_topic:\n            self.message_history[topic].pop(0)\n\n        # Call parent to distribute message\n        super().publish_message(topic, message, publisher_info, metadata)\n\n    def replay_messages(self, topic, subscriber_info, since_timestamp=None):\n        \"\"\"Replay historical messages to a subscriber.\"\"\"\n\n        if topic not in self.message_history:\n            return\n\n        for entry in self.message_history[topic]:\n            if since_timestamp is None or entry[\"timestamp\"] &gt;= since_timestamp:\n                self.send_to_subscriber(subscriber_info, topic, entry)\n\n    def get_topic_stats(self, topic):\n        \"\"\"Get statistics for a topic.\"\"\"\n        if topic not in self.message_history:\n            return {\"message_count\": 0, \"subscribers\": 0}\n\n        return {\n            \"message_count\": len(self.message_history[topic]),\n            \"subscribers\": len(self.get_subscribers(topic)),\n            \"latest_message\": self.message_history[topic][-1] if self.message_history[topic] else None\n        }\n\n# Usage with replay functionality\ndef subscriber_with_replay():\n    \"\"\"Subscriber that requests message replay.\"\"\"\n\n    subscriber = PubSubSubscriber(\"localhost\", 8080)\n\n    def message_handler(topic, message, metadata=None):\n        print(f\"Received: [{topic}] {message}\")\n\n    # Subscribe and request replay of last hour's messages\n    import time\n    one_hour_ago = time.time() - 3600\n\n    subscriber.subscribe(\"news/*\", message_handler)\n    subscriber.request_replay(\"news/*\", since_timestamp=one_hour_ago)\n\n    subscriber.start_listening()\n</code></pre>"},{"location":"advanced/pubsub/#quality-of-service-qos-levels","title":"Quality of Service (QoS) Levels","text":"<pre><code>from kn_sock import PubSubPublisher, PubSubSubscriber\nfrom enum import Enum\n\nclass QoSLevel(Enum):\n    \"\"\"Quality of Service levels.\"\"\"\n    AT_MOST_ONCE = 0   # Fire and forget\n    AT_LEAST_ONCE = 1  # Guaranteed delivery, possible duplicates\n    EXACTLY_ONCE = 2   # Guaranteed delivery, no duplicates\n\nclass QoSPubSubPublisher(PubSubPublisher):\n    \"\"\"Publisher with QoS support.\"\"\"\n\n    def __init__(self, host, port):\n        super().__init__(host, port)\n        self.message_acknowledgments = {}\n        self.message_counter = 0\n\n    def publish_with_qos(self, topic, message, qos_level=QoSLevel.AT_MOST_ONCE, timeout=30):\n        \"\"\"Publish message with specified QoS level.\"\"\"\n\n        if qos_level == QoSLevel.AT_MOST_ONCE:\n            # Simple fire-and-forget\n            return self.publish(topic, message)\n\n        elif qos_level == QoSLevel.AT_LEAST_ONCE:\n            # Wait for acknowledgment, retry if needed\n            message_id = self.generate_message_id()\n\n            for attempt in range(3):  # Max 3 attempts\n                self.publish(topic, message, metadata={\"message_id\": message_id, \"qos\": 1})\n\n                if self.wait_for_ack(message_id, timeout):\n                    return True\n\n                print(f\"Retry {attempt + 1} for message {message_id}\")\n\n            return False\n\n        elif qos_level == QoSLevel.EXACTLY_ONCE:\n            # Two-phase commit for exactly-once delivery\n            return self.publish_exactly_once(topic, message, timeout)\n\n    def generate_message_id(self):\n        \"\"\"Generate unique message ID.\"\"\"\n        self.message_counter += 1\n        return f\"{self.client_id}_{self.message_counter}\"\n\n    def wait_for_ack(self, message_id, timeout):\n        \"\"\"Wait for message acknowledgment.\"\"\"\n        import time\n        start_time = time.time()\n\n        while time.time() - start_time &lt; timeout:\n            if message_id in self.message_acknowledgments:\n                del self.message_acknowledgments[message_id]\n                return True\n            time.sleep(0.1)\n\n        return False\n\n    def handle_acknowledgment(self, ack_data):\n        \"\"\"Handle acknowledgment from broker.\"\"\"\n        message_id = ack_data.get(\"message_id\")\n        if message_id:\n            self.message_acknowledgments[message_id] = True\n\n# QoS Subscriber with acknowledgments\nclass QoSPubSubSubscriber(PubSubSubscriber):\n    \"\"\"Subscriber with QoS acknowledgment support.\"\"\"\n\n    def __init__(self, host, port):\n        super().__init__(host, port)\n        self.processed_messages = set()  # For exactly-once processing\n\n    def handle_qos_message(self, topic, message, metadata=None):\n        \"\"\"Handle message with QoS processing.\"\"\"\n\n        qos_level = metadata.get(\"qos\", 0) if metadata else 0\n        message_id = metadata.get(\"message_id\") if metadata else None\n\n        if qos_level == 1 and message_id:\n            # Send acknowledgment for at-least-once\n            self.send_acknowledgment(message_id)\n\n        elif qos_level == 2 and message_id:\n            # Handle exactly-once processing\n            if message_id in self.processed_messages:\n                print(f\"Duplicate message {message_id} ignored\")\n                return\n\n            self.processed_messages.add(message_id)\n            self.send_acknowledgment(message_id)\n\n        # Process the message\n        self.process_message(topic, message, metadata)\n\n    def send_acknowledgment(self, message_id):\n        \"\"\"Send acknowledgment to broker.\"\"\"\n        ack_data = {\n            \"type\": \"acknowledgment\",\n            \"message_id\": message_id\n        }\n        self.send_control_message(ack_data)\n\n    def process_message(self, topic, message, metadata):\n        \"\"\"Process the actual message (override in subclass).\"\"\"\n        print(f\"Processing: [{topic}] {message}\")\n\n# Usage example\npublisher = QoSPubSubPublisher(\"localhost\", 8080)\n\n# Publish with different QoS levels\npublisher.publish_with_qos(\"critical/alerts\", \"System failure!\", QoSLevel.EXACTLY_ONCE)\npublisher.publish_with_qos(\"notifications\", \"New message\", QoSLevel.AT_LEAST_ONCE)\npublisher.publish_with_qos(\"metrics\", \"CPU: 45%\", QoSLevel.AT_MOST_ONCE)\n</code></pre>"},{"location":"advanced/pubsub/#topic-hierarchies-and-wildcards","title":"Topic Hierarchies and Wildcards","text":"<pre><code>from kn_sock import PubSubSubscriber\n\ndef wildcard_subscription_example():\n    \"\"\"Example of wildcard topic subscriptions.\"\"\"\n\n    subscriber = PubSubSubscriber(\"localhost\", 8080)\n\n    def sports_handler(topic, message, metadata=None):\n        \"\"\"Handle all sports-related messages.\"\"\"\n        sport = topic.split('/')[-1]  # Extract sport from topic\n        print(f\"SPORTS [{sport.upper()}]: {message}\")\n\n    def alert_handler(topic, message, metadata=None):\n        \"\"\"Handle all alert messages.\"\"\"\n        alert_level = topic.split('/')[-1]\n        print(f\"ALERT [{alert_level.upper()}]: {message}\")\n\n    def user_activity_handler(topic, message, metadata=None):\n        \"\"\"Handle user activity messages.\"\"\"\n        user_id = topic.split('/')[1]  # Extract user ID\n        action = topic.split('/')[-1]\n        print(f\"User {user_id} performed action: {action}\")\n\n    # Subscribe to topic hierarchies\n    subscriber.subscribe(\"sports/*\", sports_handler)           # sports/football, sports/basketball\n    subscriber.subscribe(\"alerts/*\", alert_handler)           # alerts/critical, alerts/warning\n    subscriber.subscribe(\"user/*/activity\", user_activity_handler)  # user/123/activity, user/456/activity\n\n    # Multi-level wildcards\n    subscriber.subscribe(\"system/*/logs/*\", lambda t, m, meta: print(f\"LOG: {t} -&gt; {m}\"))\n\n    # Exact topic subscription\n    subscriber.subscribe(\"admin/shutdown\", lambda t, m, meta: print(f\"SHUTDOWN: {m}\"))\n\n    subscriber.start_listening()\n\n# Publisher with hierarchical topics\ndef hierarchical_publisher_example():\n    \"\"\"Example of publishing to hierarchical topics.\"\"\"\n\n    from kn_sock import PubSubPublisher\n\n    publisher = PubSubPublisher(\"localhost\", 8080)\n\n    # Sports topics\n    publisher.publish(\"sports/football\", \"Goal scored!\")\n    publisher.publish(\"sports/basketball\", \"Three-pointer!\")\n    publisher.publish(\"sports/tennis\", \"Match point!\")\n\n    # Alert topics\n    publisher.publish(\"alerts/critical\", \"Database connection lost\")\n    publisher.publish(\"alerts/warning\", \"High memory usage detected\")\n    publisher.publish(\"alerts/info\", \"Backup completed successfully\")\n\n    # User activity topics\n    publisher.publish(\"user/123/activity\", \"logged_in\")\n    publisher.publish(\"user/456/activity\", \"file_uploaded\")\n    publisher.publish(\"user/789/activity\", \"password_changed\")\n\n    # System logs\n    publisher.publish(\"system/web/logs/access\", \"GET /api/users 200\")\n    publisher.publish(\"system/db/logs/query\", \"SELECT * FROM users executed\")\n\n    publisher.disconnect()\n</code></pre>"},{"location":"advanced/pubsub/#message-filtering","title":"Message Filtering","text":"<pre><code>from kn_sock import PubSubBroker\n\nclass FilteringPubSubBroker(PubSubBroker):\n    \"\"\"Pub/Sub broker with server-side message filtering.\"\"\"\n\n    def __init__(self, port, host='0.0.0.0'):\n        super().__init__(port, host)\n        self.subscriber_filters = {}  # subscriber_id -&gt; filters\n\n    def add_subscriber_filter(self, subscriber_id, filter_func):\n        \"\"\"Add a filter function for a subscriber.\"\"\"\n        if subscriber_id not in self.subscriber_filters:\n            self.subscriber_filters[subscriber_id] = []\n        self.subscriber_filters[subscriber_id].append(filter_func)\n\n    def should_deliver_message(self, subscriber_id, topic, message, metadata):\n        \"\"\"Check if message should be delivered to subscriber.\"\"\"\n\n        if subscriber_id not in self.subscriber_filters:\n            return True  # No filters, deliver all messages\n\n        for filter_func in self.subscriber_filters[subscriber_id]:\n            if not filter_func(topic, message, metadata):\n                return False\n\n        return True\n\n    def distribute_message(self, topic, message, metadata=None):\n        \"\"\"Distribute message to filtered subscribers.\"\"\"\n\n        for subscriber_id, subscriber_info in self.get_topic_subscribers(topic).items():\n            if self.should_deliver_message(subscriber_id, topic, message, metadata):\n                self.send_to_subscriber(subscriber_info, topic, message, metadata)\n\n# Filter functions\ndef priority_filter(min_priority):\n    \"\"\"Create a filter for minimum priority messages.\"\"\"\n    def filter_func(topic, message, metadata):\n        if not metadata or 'priority' not in metadata:\n            return True  # No priority info, allow message\n\n        priority_levels = {'low': 1, 'normal': 2, 'high': 3, 'critical': 4}\n        message_priority = priority_levels.get(metadata['priority'], 0)\n        required_priority = priority_levels.get(min_priority, 0)\n\n        return message_priority &gt;= required_priority\n\n    return filter_func\n\ndef content_filter(keywords):\n    \"\"\"Create a filter for messages containing specific keywords.\"\"\"\n    def filter_func(topic, message, metadata):\n        message_lower = message.lower()\n        return any(keyword.lower() in message_lower for keyword in keywords)\n\n    return filter_func\n\ndef time_filter(start_hour, end_hour):\n    \"\"\"Create a filter for messages within specific hours.\"\"\"\n    def filter_func(topic, message, metadata):\n        import datetime\n        current_hour = datetime.datetime.now().hour\n        return start_hour &lt;= current_hour &lt;= end_hour\n\n    return filter_func\n\n# Usage example\ndef filtered_subscriber_example():\n    \"\"\"Example subscriber with server-side filtering.\"\"\"\n\n    from kn_sock import PubSubSubscriber\n\n    subscriber = PubSubSubscriber(\"localhost\", 8080)\n\n    # Register filters with the broker\n    subscriber.add_filter(priority_filter('high'))  # Only high/critical priority\n    subscriber.add_filter(content_filter(['urgent', 'error', 'failure']))  # Only urgent content\n    subscriber.add_filter(time_filter(9, 17))  # Only during business hours\n\n    def filtered_handler(topic, message, metadata=None):\n        print(f\"FILTERED MESSAGE: [{topic}] {message}\")\n        if metadata:\n            print(f\"Priority: {metadata.get('priority', 'unknown')}\")\n\n    subscriber.subscribe(\"alerts/*\", filtered_handler)\n    subscriber.start_listening()\n</code></pre>"},{"location":"advanced/pubsub/#pubsub-patterns","title":"Pub/Sub Patterns","text":""},{"location":"advanced/pubsub/#request-reply-pattern","title":"Request-Reply Pattern","text":"<pre><code>from kn_sock import PubSubPublisher, PubSubSubscriber\nimport uuid\nimport threading\nimport time\n\nclass RequestReplyClient:\n    \"\"\"Client that implements request-reply pattern over pub/sub.\"\"\"\n\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.client_id = str(uuid.uuid4())\n        self.publisher = PubSubPublisher(host, port)\n        self.subscriber = PubSubSubscriber(host, port)\n        self.pending_requests = {}\n        self.reply_topic = f\"replies/{self.client_id}\"\n\n        # Subscribe to reply topic\n        self.subscriber.subscribe(self.reply_topic, self.handle_reply)\n\n        # Start subscriber in background\n        self.subscriber_thread = threading.Thread(\n            target=self.subscriber.start_listening, \n            daemon=True\n        )\n        self.subscriber_thread.start()\n\n    def send_request(self, service_topic, request_data, timeout=30):\n        \"\"\"Send request and wait for reply.\"\"\"\n\n        request_id = str(uuid.uuid4())\n\n        # Prepare request message\n        request_message = {\n            \"id\": request_id,\n            \"reply_to\": self.reply_topic,\n            \"data\": request_data,\n            \"timestamp\": time.time()\n        }\n\n        # Create event to wait for reply\n        reply_event = threading.Event()\n        self.pending_requests[request_id] = {\n            \"event\": reply_event,\n            \"reply\": None\n        }\n\n        try:\n            # Send request\n            self.publisher.publish(\n                service_topic, \n                json.dumps(request_message)\n            )\n\n            # Wait for reply\n            if reply_event.wait(timeout):\n                return self.pending_requests[request_id][\"reply\"]\n            else:\n                raise TimeoutError(f\"Request {request_id} timed out\")\n\n        finally:\n            # Clean up\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n\n    def handle_reply(self, topic, message, metadata=None):\n        \"\"\"Handle reply message.\"\"\"\n        try:\n            reply_data = json.loads(message)\n            request_id = reply_data.get(\"request_id\")\n\n            if request_id in self.pending_requests:\n                self.pending_requests[request_id][\"reply\"] = reply_data\n                self.pending_requests[request_id][\"event\"].set()\n\n        except json.JSONDecodeError:\n            print(f\"Invalid reply format: {message}\")\n\nclass RequestReplyService:\n    \"\"\"Service that handles requests and sends replies.\"\"\"\n\n    def __init__(self, host, port, service_name):\n        self.host = host\n        self.port = port\n        self.service_name = service_name\n        self.publisher = PubSubPublisher(host, port)\n        self.subscriber = PubSubSubscriber(host, port)\n\n        # Subscribe to service topic\n        service_topic = f\"services/{service_name}\"\n        self.subscriber.subscribe(service_topic, self.handle_request)\n\n    def handle_request(self, topic, message, metadata=None):\n        \"\"\"Handle incoming request.\"\"\"\n        try:\n            request_data = json.loads(message)\n            request_id = request_data.get(\"id\")\n            reply_topic = request_data.get(\"reply_to\")\n            data = request_data.get(\"data\")\n\n            # Process the request\n            reply_data = self.process_request(data)\n\n            # Send reply\n            reply_message = {\n                \"request_id\": request_id,\n                \"data\": reply_data,\n                \"timestamp\": time.time(),\n                \"service\": self.service_name\n            }\n\n            self.publisher.publish(reply_topic, json.dumps(reply_message))\n\n        except Exception as e:\n            print(f\"Error handling request: {e}\")\n\n    def process_request(self, data):\n        \"\"\"Process request data (override in subclass).\"\"\"\n        # Example: echo service\n        return f\"Echo: {data}\"\n\n    def start(self):\n        \"\"\"Start the service.\"\"\"\n        print(f\"Service {self.service_name} started\")\n        self.subscriber.start_listening()\n\n# Usage example\nimport json\n\n# Start a calculator service\nclass CalculatorService(RequestReplyService):\n    \"\"\"Calculator service example.\"\"\"\n\n    def process_request(self, data):\n        \"\"\"Process calculation request.\"\"\"\n        try:\n            operation = data.get(\"operation\")\n            operands = data.get(\"operands\", [])\n\n            if operation == \"add\":\n                result = sum(operands)\n            elif operation == \"multiply\":\n                result = 1\n                for operand in operands:\n                    result *= operand\n            elif operation == \"divide\":\n                result = operands[0] / operands[1] if len(operands) &gt;= 2 else None\n            else:\n                result = f\"Unknown operation: {operation}\"\n\n            return {\"result\": result, \"status\": \"success\"}\n\n        except Exception as e:\n            return {\"error\": str(e), \"status\": \"error\"}\n\n# Start calculator service\ncalc_service = CalculatorService(\"localhost\", 8080, \"calculator\")\nservice_thread = threading.Thread(target=calc_service.start, daemon=True)\nservice_thread.start()\n\n# Use the service\nclient = RequestReplyClient(\"localhost\", 8080)\n\n# Send calculation requests\nadd_result = client.send_request(\n    \"services/calculator\",\n    {\"operation\": \"add\", \"operands\": [10, 20, 30]}\n)\nprint(f\"Addition result: {add_result}\")\n\nmultiply_result = client.send_request(\n    \"services/calculator\", \n    {\"operation\": \"multiply\", \"operands\": [5, 6]}\n)\nprint(f\"Multiplication result: {multiply_result}\")\n</code></pre>"},{"location":"advanced/pubsub/#performance-and-scaling","title":"Performance and Scaling","text":""},{"location":"advanced/pubsub/#clustered-pubsub-brokers","title":"Clustered Pub/Sub Brokers","text":"<pre><code>from kn_sock import PubSubBroker\nimport threading\nimport json\n\nclass ClusteredPubSubBroker(PubSubBroker):\n    \"\"\"Pub/Sub broker with clustering support.\"\"\"\n\n    def __init__(self, port, host='0.0.0.0', cluster_nodes=None):\n        super().__init__(port, host)\n        self.cluster_nodes = cluster_nodes or []\n        self.broker_id = f\"{host}:{port}\"\n        self.cluster_connections = {}\n\n        # Connect to other brokers in cluster\n        self.connect_to_cluster()\n\n    def connect_to_cluster(self):\n        \"\"\"Connect to other brokers in the cluster.\"\"\"\n        for node in self.cluster_nodes:\n            if node != self.broker_id:\n                try:\n                    connection = self.create_cluster_connection(node)\n                    self.cluster_connections[node] = connection\n                    print(f\"Connected to cluster node: {node}\")\n                except Exception as e:\n                    print(f\"Failed to connect to cluster node {node}: {e}\")\n\n    def publish_to_cluster(self, topic, message, metadata=None, origin_broker=None):\n        \"\"\"Publish message to cluster nodes.\"\"\"\n\n        # Don't forward if we're the origin\n        if origin_broker == self.broker_id:\n            return\n\n        cluster_message = {\n            \"type\": \"cluster_publish\",\n            \"topic\": topic,\n            \"message\": message,\n            \"metadata\": metadata,\n            \"origin_broker\": self.broker_id\n        }\n\n        for node_id, connection in self.cluster_connections.items():\n            try:\n                connection.send(json.dumps(cluster_message))\n            except Exception as e:\n                print(f\"Failed to forward to cluster node {node_id}: {e}\")\n\n    def handle_cluster_message(self, cluster_message):\n        \"\"\"Handle message from cluster node.\"\"\"\n        message_type = cluster_message.get(\"type\")\n\n        if message_type == \"cluster_publish\":\n            # Distribute to local subscribers only\n            self.distribute_locally(\n                cluster_message[\"topic\"],\n                cluster_message[\"message\"],\n                cluster_message.get(\"metadata\"),\n                cluster_message.get(\"origin_broker\")\n            )\n\n    def publish_message(self, topic, message, publisher_info, metadata=None):\n        \"\"\"Publish message locally and to cluster.\"\"\"\n\n        # Distribute locally\n        super().publish_message(topic, message, publisher_info, metadata)\n\n        # Forward to cluster\n        self.publish_to_cluster(topic, message, metadata)\n\n# Load balancing subscriber connections\nclass LoadBalancedSubscriber:\n    \"\"\"Subscriber that connects to multiple brokers for load balancing.\"\"\"\n\n    def __init__(self, broker_addresses):\n        self.broker_addresses = broker_addresses\n        self.subscribers = []\n        self.current_broker = 0\n\n        # Create connections to all brokers\n        for address in broker_addresses:\n            host, port = address.split(':')\n            subscriber = PubSubSubscriber(host, int(port))\n            self.subscribers.append(subscriber)\n\n    def subscribe(self, topic, handler):\n        \"\"\"Subscribe to topic on next available broker.\"\"\"\n        broker = self.subscribers[self.current_broker]\n        broker.subscribe(topic, handler)\n\n        # Round-robin to next broker\n        self.current_broker = (self.current_broker + 1) % len(self.subscribers)\n\n    def start_all(self):\n        \"\"\"Start all subscriber connections.\"\"\"\n        threads = []\n        for subscriber in self.subscribers:\n            thread = threading.Thread(target=subscriber.start_listening, daemon=True)\n            thread.start()\n            threads.append(thread)\n        return threads\n\n# Usage example\ncluster_nodes = [\"localhost:8080\", \"localhost:8081\", \"localhost:8082\"]\n\n# Start clustered brokers\nbrokers = []\nfor i, node in enumerate(cluster_nodes):\n    host, port = node.split(':')\n    other_nodes = [n for n in cluster_nodes if n != node]\n\n    broker = ClusteredPubSubBroker(int(port), host, other_nodes)\n    brokers.append(broker)\n\n    # Start each broker in a separate thread\n    broker_thread = threading.Thread(target=broker.start, daemon=True)\n    broker_thread.start()\n\n# Use load-balanced subscriber\nload_balanced_subscriber = LoadBalancedSubscriber(cluster_nodes)\nload_balanced_subscriber.subscribe(\"test/*\", lambda t, m, meta: print(f\"Received: {t} -&gt; {m}\"))\nload_balanced_subscriber.start_all()\n</code></pre>"},{"location":"advanced/pubsub/#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<pre><code>import time\nimport threading\nfrom collections import defaultdict, deque\n\nclass MonitoredPubSubBroker(PubSubBroker):\n    \"\"\"Pub/Sub broker with monitoring and metrics.\"\"\"\n\n    def __init__(self, port, host='0.0.0.0'):\n        super().__init__(port, host)\n\n        # Metrics storage\n        self.metrics = {\n            \"messages_published\": 0,\n            \"messages_delivered\": 0,\n            \"active_subscribers\": 0,\n            \"topics_count\": 0,\n            \"uptime_start\": time.time()\n        }\n\n        self.topic_metrics = defaultdict(lambda: {\n            \"message_count\": 0,\n            \"subscriber_count\": 0,\n            \"last_message_time\": None\n        })\n\n        self.performance_history = deque(maxlen=100)  # Last 100 measurements\n\n        # Start metrics collection thread\n        self.metrics_thread = threading.Thread(target=self.collect_metrics, daemon=True)\n        self.metrics_thread.start()\n\n    def publish_message(self, topic, message, publisher_info, metadata=None):\n        \"\"\"Publish message with metrics tracking.\"\"\"\n        start_time = time.time()\n\n        # Call parent method\n        super().publish_message(topic, message, publisher_info, metadata)\n\n        # Update metrics\n        self.metrics[\"messages_published\"] += 1\n        self.topic_metrics[topic][\"message_count\"] += 1\n        self.topic_metrics[topic][\"last_message_time\"] = time.time()\n\n        # Track performance\n        end_time = time.time()\n        self.performance_history.append({\n            \"publish_time\": end_time - start_time,\n            \"timestamp\": end_time,\n            \"topic\": topic\n        })\n\n    def add_subscriber(self, topic, subscriber_info):\n        \"\"\"Add subscriber with metrics tracking.\"\"\"\n        super().add_subscriber(topic, subscriber_info)\n\n        self.metrics[\"active_subscribers\"] += 1\n        self.topic_metrics[topic][\"subscriber_count\"] += 1\n        self.metrics[\"topics_count\"] = len(self.topic_metrics)\n\n    def remove_subscriber(self, topic, subscriber_id):\n        \"\"\"Remove subscriber with metrics tracking.\"\"\"\n        super().remove_subscriber(topic, subscriber_id)\n\n        self.metrics[\"active_subscribers\"] -= 1\n        if topic in self.topic_metrics:\n            self.topic_metrics[topic][\"subscriber_count\"] -= 1\n\n    def collect_metrics(self):\n        \"\"\"Collect performance metrics periodically.\"\"\"\n        while True:\n            time.sleep(10)  # Collect every 10 seconds\n\n            # Calculate average publish time\n            if self.performance_history:\n                recent_times = [entry[\"publish_time\"] for entry in self.performance_history]\n                avg_publish_time = sum(recent_times) / len(recent_times)\n                self.metrics[\"avg_publish_time_ms\"] = avg_publish_time * 1000\n\n            # Calculate uptime\n            self.metrics[\"uptime_seconds\"] = time.time() - self.metrics[\"uptime_start\"]\n\n            # Log metrics (or send to monitoring system)\n            self.log_metrics()\n\n    def log_metrics(self):\n        \"\"\"Log current metrics.\"\"\"\n        print(f\"Pub/Sub Metrics:\")\n        print(f\"  Messages Published: {self.metrics['messages_published']}\")\n        print(f\"  Active Subscribers: {self.metrics['active_subscribers']}\")\n        print(f\"  Topics: {self.metrics['topics_count']}\")\n        print(f\"  Uptime: {self.metrics['uptime_seconds']:.1f}s\")\n        if \"avg_publish_time_ms\" in self.metrics:\n            print(f\"  Avg Publish Time: {self.metrics['avg_publish_time_ms']:.2f}ms\")\n        print()\n\n    def get_metrics(self):\n        \"\"\"Get current metrics.\"\"\"\n        return {\n            \"broker_metrics\": self.metrics.copy(),\n            \"topic_metrics\": dict(self.topic_metrics),\n            \"performance_history\": list(self.performance_history)\n        }\n\n    def get_health_status(self):\n        \"\"\"Get broker health status.\"\"\"\n        health = {\n            \"status\": \"healthy\",\n            \"checks\": {\n                \"uptime\": self.metrics[\"uptime_seconds\"] &gt; 0,\n                \"subscribers\": self.metrics[\"active_subscribers\"] &gt;= 0,\n                \"performance\": True\n            }\n        }\n\n        # Check performance\n        if \"avg_publish_time_ms\" in self.metrics:\n            if self.metrics[\"avg_publish_time_ms\"] &gt; 100:  # &gt;100ms is concerning\n                health[\"checks\"][\"performance\"] = False\n                health[\"status\"] = \"degraded\"\n\n        return health\n\n# Usage with monitoring\nbroker = MonitoredPubSubBroker(8080)\n\n# Start broker in background\nbroker_thread = threading.Thread(target=broker.start, daemon=True)\nbroker_thread.start()\n\n# Monitor health periodically\ndef health_monitor():\n    while True:\n        time.sleep(30)\n        health = broker.get_health_status()\n        print(f\"Broker Health: {health['status']}\")\n\n        if health[\"status\"] != \"healthy\":\n            print(f\"Health issues detected: {health}\")\n\nhealth_thread = threading.Thread(target=health_monitor, daemon=True)\nhealth_thread.start()\n</code></pre>"},{"location":"advanced/pubsub/#see-also","title":"See Also","text":"<ul> <li>TCP Protocol - For reliable message transport</li> <li>JSON Communication - For structured message data</li> <li>WebSocket Protocol - For real-time communication</li> <li>RPC - For remote procedure calls</li> <li>Examples - Pub/Sub application examples</li> </ul>"},{"location":"advanced/rpc/","title":"Remote Procedure Calls (RPC)","text":"<p>kn-sock provides a comprehensive RPC system that allows you to call functions on remote servers as if they were local, with support for both synchronous and asynchronous operations.</p>"},{"location":"advanced/rpc/#overview","title":"Overview","text":"<p>RPC features in kn-sock: - Transparent remote calls: Call remote functions like local functions - Multiple serialization formats: JSON, Protocol Buffers, and custom serializers - Async and sync support: Both synchronous and asynchronous RPC calls - Error handling: Automatic exception propagation across network - Authentication: Built-in authentication and authorization - Load balancing: Distribute calls across multiple servers - Middleware support: Custom preprocessing and postprocessing - Service discovery: Automatic server discovery and registration</p>"},{"location":"advanced/rpc/#basic-rpc-usage","title":"Basic RPC Usage","text":""},{"location":"advanced/rpc/#rpc-server","title":"RPC Server","text":"<pre><code>from kn_sock import RPCServer\n\nclass MathService:\n    \"\"\"Example RPC service with mathematical operations.\"\"\"\n\n    def add(self, a, b):\n        \"\"\"Add two numbers.\"\"\"\n        return a + b\n\n    def subtract(self, a, b):\n        \"\"\"Subtract two numbers.\"\"\"\n        return a - b\n\n    def multiply(self, a, b):\n        \"\"\"Multiply two numbers.\"\"\"\n        return a * b\n\n    def divide(self, a, b):\n        \"\"\"Divide two numbers.\"\"\"\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return a / b\n\n    def factorial(self, n):\n        \"\"\"Calculate factorial of a number.\"\"\"\n        if n &lt; 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        if n == 0 or n == 1:\n            return 1\n\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\ndef basic_rpc_server():\n    \"\"\"Start a basic RPC server.\"\"\"\n\n    # Create RPC server\n    server = RPCServer(host='0.0.0.0', port=8080)\n\n    # Register service\n    math_service = MathService()\n    server.register_service('math', math_service)\n\n    # Register individual functions\n    def hello(name):\n        return f\"Hello, {name}!\"\n\n    def get_server_time():\n        import datetime\n        return datetime.datetime.now().isoformat()\n\n    server.register_function('hello', hello)\n    server.register_function('get_time', get_server_time)\n\n    print(\"RPC Server started on localhost:8080\")\n    print(\"Available services:\")\n    print(\"  - math.add(a, b)\")\n    print(\"  - math.subtract(a, b)\")\n    print(\"  - math.multiply(a, b)\")\n    print(\"  - math.divide(a, b)\")\n    print(\"  - math.factorial(n)\")\n    print(\"  - hello(name)\")\n    print(\"  - get_time()\")\n\n    # Start the server\n    server.start()\n\nif __name__ == \"__main__\":\n    basic_rpc_server()\n</code></pre>"},{"location":"advanced/rpc/#rpc-client","title":"RPC Client","text":"<pre><code>from kn_sock import RPCClient\n\ndef basic_rpc_client():\n    \"\"\"Example RPC client.\"\"\"\n\n    # Connect to RPC server\n    client = RPCClient('localhost', 8080)\n\n    try:\n        # Call individual functions\n        greeting = client.call('hello', 'Alice')\n        print(f\"Greeting: {greeting}\")\n\n        server_time = client.call('get_time')\n        print(f\"Server time: {server_time}\")\n\n        # Call service methods\n        result = client.call('math.add', 10, 20)\n        print(f\"10 + 20 = {result}\")\n\n        result = client.call('math.multiply', 7, 8)\n        print(f\"7 * 8 = {result}\")\n\n        result = client.call('math.factorial', 5)\n        print(f\"5! = {result}\")\n\n        # Handle errors\n        try:\n            result = client.call('math.divide', 10, 0)\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n        # Batch calls\n        batch_results = client.batch_call([\n            ('math.add', [1, 2]),\n            ('math.multiply', [3, 4]),\n            ('hello', ['Bob'])\n        ])\n\n        print(f\"Batch results: {batch_results}\")\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    basic_rpc_client()\n</code></pre>"},{"location":"advanced/rpc/#asynchronous-rpc","title":"Asynchronous RPC","text":""},{"location":"advanced/rpc/#async-rpc-server","title":"Async RPC Server","text":"<pre><code>import asyncio\nfrom kn_sock import AsyncRPCServer\n\nclass AsyncDatabaseService:\n    \"\"\"Example async RPC service simulating database operations.\"\"\"\n\n    def __init__(self):\n        self.data = {}\n\n    async def get(self, key):\n        \"\"\"Get value by key.\"\"\"\n        # Simulate database delay\n        await asyncio.sleep(0.1)\n        return self.data.get(key)\n\n    async def set(self, key, value):\n        \"\"\"Set key-value pair.\"\"\"\n        # Simulate database delay\n        await asyncio.sleep(0.05)\n        self.data[key] = value\n        return True\n\n    async def delete(self, key):\n        \"\"\"Delete key.\"\"\"\n        await asyncio.sleep(0.05)\n        return self.data.pop(key, None)\n\n    async def list_keys(self):\n        \"\"\"List all keys.\"\"\"\n        await asyncio.sleep(0.1)\n        return list(self.data.keys())\n\n    async def bulk_set(self, items):\n        \"\"\"Set multiple key-value pairs.\"\"\"\n        await asyncio.sleep(0.1)\n        for key, value in items.items():\n            self.data[key] = value\n        return len(items)\n\nasync def async_rpc_server():\n    \"\"\"Start an async RPC server.\"\"\"\n\n    # Create async RPC server\n    server = AsyncRPCServer(host='0.0.0.0', port=8081)\n\n    # Register async service\n    db_service = AsyncDatabaseService()\n    server.register_service('db', db_service)\n\n    # Register async functions\n    async def async_hello(name):\n        await asyncio.sleep(0.1)  # Simulate async work\n        return f\"Async hello, {name}!\"\n\n    async def fetch_data(url):\n        \"\"\"Simulate fetching data from URL.\"\"\"\n        await asyncio.sleep(0.5)  # Simulate network delay\n        return f\"Data from {url}: [simulated response]\"\n\n    server.register_function('async_hello', async_hello)\n    server.register_function('fetch_data', fetch_data)\n\n    print(\"Async RPC Server started on localhost:8081\")\n    print(\"Available async services:\")\n    print(\"  - db.get(key)\")\n    print(\"  - db.set(key, value)\")\n    print(\"  - db.delete(key)\")\n    print(\"  - db.list_keys()\")\n    print(\"  - db.bulk_set(items)\")\n    print(\"  - async_hello(name)\")\n    print(\"  - fetch_data(url)\")\n\n    # Start the server\n    await server.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(async_rpc_server())\n</code></pre>"},{"location":"advanced/rpc/#async-rpc-client","title":"Async RPC Client","text":"<pre><code>import asyncio\nfrom kn_sock import AsyncRPCClient\n\nasync def async_rpc_client():\n    \"\"\"Example async RPC client.\"\"\"\n\n    # Connect to async RPC server\n    client = AsyncRPCClient('localhost', 8081)\n\n    try:\n        # Async function calls\n        greeting = await client.call('async_hello', 'Alice')\n        print(f\"Async greeting: {greeting}\")\n\n        # Database operations\n        await client.call('db.set', 'user:1', {'name': 'John', 'age': 30})\n        await client.call('db.set', 'user:2', {'name': 'Jane', 'age': 25})\n\n        user1 = await client.call('db.get', 'user:1')\n        print(f\"User 1: {user1}\")\n\n        keys = await client.call('db.list_keys')\n        print(f\"All keys: {keys}\")\n\n        # Bulk operations\n        bulk_data = {\n            'product:1': {'name': 'Laptop', 'price': 999},\n            'product:2': {'name': 'Mouse', 'price': 25},\n            'product:3': {'name': 'Keyboard', 'price': 75}\n        }\n\n        items_set = await client.call('db.bulk_set', bulk_data)\n        print(f\"Bulk set {items_set} items\")\n\n        # Concurrent calls\n        tasks = [\n            client.call('fetch_data', 'https://api1.example.com'),\n            client.call('fetch_data', 'https://api2.example.com'),\n            client.call('fetch_data', 'https://api3.example.com')\n        ]\n\n        results = await asyncio.gather(*tasks)\n        for i, result in enumerate(results, 1):\n            print(f\"Concurrent call {i}: {result}\")\n\n        # Async batch calls\n        batch_results = await client.batch_call([\n            ('db.get', ['user:1']),\n            ('db.get', ['user:2']),\n            ('async_hello', ['Bob'])\n        ])\n\n        print(f\"Async batch results: {batch_results}\")\n\n    finally:\n        await client.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(async_rpc_client())\n</code></pre>"},{"location":"advanced/rpc/#advanced-rpc-features","title":"Advanced RPC Features","text":""},{"location":"advanced/rpc/#rpc-with-authentication","title":"RPC with Authentication","text":"<pre><code>import hashlib\nimport hmac\nimport time\nfrom kn_sock import RPCServer, RPCClient\n\nclass AuthenticatedRPCServer(RPCServer):\n    \"\"\"RPC server with authentication support.\"\"\"\n\n    def __init__(self, host, port, secret_key):\n        super().__init__(host, port)\n        self.secret_key = secret_key\n        self.authenticated_clients = {}\n        self.session_timeout = 3600  # 1 hour\n\n    def authenticate_client(self, token, timestamp, signature):\n        \"\"\"Authenticate client using HMAC signature.\"\"\"\n\n        # Check timestamp (prevent replay attacks)\n        current_time = time.time()\n        if abs(current_time - timestamp) &gt; 300:  # 5 minutes tolerance\n            return False, \"Token expired\"\n\n        # Verify HMAC signature\n        expected_signature = hmac.new(\n            self.secret_key.encode(),\n            f\"{token}:{timestamp}\".encode(),\n            hashlib.sha256\n        ).hexdigest()\n\n        if not hmac.compare_digest(signature, expected_signature):\n            return False, \"Invalid signature\"\n\n        # Store authenticated client\n        self.authenticated_clients[token] = {\n            \"authenticated_at\": current_time,\n            \"last_activity\": current_time\n        }\n\n        return True, \"Authentication successful\"\n\n    def is_authenticated(self, token):\n        \"\"\"Check if client is authenticated.\"\"\"\n        if token not in self.authenticated_clients:\n            return False\n\n        client_info = self.authenticated_clients[token]\n        current_time = time.time()\n\n        # Check session timeout\n        if current_time - client_info[\"last_activity\"] &gt; self.session_timeout:\n            del self.authenticated_clients[token]\n            return False\n\n        # Update last activity\n        client_info[\"last_activity\"] = current_time\n        return True\n\n    def process_request(self, request_data, client_socket):\n        \"\"\"Process RPC request with authentication.\"\"\"\n\n        # Check for authentication request\n        if request_data.get(\"method\") == \"authenticate\":\n            token = request_data.get(\"params\", {}).get(\"token\")\n            timestamp = request_data.get(\"params\", {}).get(\"timestamp\")\n            signature = request_data.get(\"params\", {}).get(\"signature\")\n\n            success, message = self.authenticate_client(token, timestamp, signature)\n            return {\"result\": {\"success\": success, \"message\": message}}\n\n        # Check authentication for other requests\n        token = request_data.get(\"auth_token\")\n        if not token or not self.is_authenticated(token):\n            return {\"error\": \"Authentication required\"}\n\n        # Process authenticated request\n        return super().process_request(request_data, client_socket)\n\nclass SecureService:\n    \"\"\"Service with role-based access control.\"\"\"\n\n    def __init__(self, server):\n        self.server = server\n\n    def get_public_data(self):\n        \"\"\"Public method - no special permissions needed.\"\"\"\n        return {\"message\": \"This is public data\", \"timestamp\": time.time()}\n\n    def get_user_data(self, user_id):\n        \"\"\"User method - requires authenticated user.\"\"\"\n        return {\n            \"user_id\": user_id,\n            \"data\": f\"Private data for user {user_id}\",\n            \"timestamp\": time.time()\n        }\n\n    def admin_operation(self):\n        \"\"\"Admin method - requires admin role.\"\"\"\n        # In real implementation, check user roles\n        return {\"message\": \"Admin operation completed\", \"timestamp\": time.time()}\n\nclass AuthenticatedRPCClient(RPCClient):\n    \"\"\"RPC client with authentication support.\"\"\"\n\n    def __init__(self, host, port, secret_key):\n        super().__init__(host, port)\n        self.secret_key = secret_key\n        self.auth_token = None\n\n    def authenticate(self, username):\n        \"\"\"Authenticate with the server.\"\"\"\n\n        # Generate authentication token\n        timestamp = time.time()\n        token = f\"{username}:{timestamp}\"\n\n        # Create HMAC signature\n        signature = hmac.new(\n            self.secret_key.encode(),\n            f\"{token}:{timestamp}\".encode(),\n            hashlib.sha256\n        ).hexdigest()\n\n        # Send authentication request\n        result = self.call(\"authenticate\", {\n            \"token\": token,\n            \"timestamp\": timestamp,\n            \"signature\": signature\n        })\n\n        if result.get(\"success\"):\n            self.auth_token = token\n            return True\n        else:\n            raise Exception(f\"Authentication failed: {result.get('message')}\")\n\n    def call(self, method, *args, **kwargs):\n        \"\"\"Make authenticated RPC call.\"\"\"\n\n        # Add auth token to request if authenticated\n        if self.auth_token and method != \"authenticate\":\n            # Override parent's call method to add auth token\n            request_data = {\n                \"method\": method,\n                \"params\": {\"args\": args, \"kwargs\": kwargs},\n                \"auth_token\": self.auth_token\n            }\n            return self._send_request(request_data)\n        else:\n            return super().call(method, *args, **kwargs)\n\n# Usage example\ndef secure_rpc_example():\n    \"\"\"Example of secure RPC with authentication.\"\"\"\n\n    SECRET_KEY = \"your-secret-key-here\"\n\n    # Start authenticated server\n    server = AuthenticatedRPCServer('localhost', 8082, SECRET_KEY)\n    secure_service = SecureService(server)\n    server.register_service('secure', secure_service)\n\n    # Start server in background\n    import threading\n    server_thread = threading.Thread(target=server.start, daemon=True)\n    server_thread.start()\n\n    # Client usage\n    client = AuthenticatedRPCClient('localhost', 8082, SECRET_KEY)\n\n    try:\n        # Authenticate\n        client.authenticate(\"user123\")\n        print(\"Authentication successful\")\n\n        # Make authenticated calls\n        public_data = client.call('secure.get_public_data')\n        print(f\"Public data: {public_data}\")\n\n        user_data = client.call('secure.get_user_data', 'user123')\n        print(f\"User data: {user_data}\")\n\n        admin_result = client.call('secure.admin_operation')\n        print(f\"Admin result: {admin_result}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        client.close()\n</code></pre>"},{"location":"advanced/rpc/#rpc-with-middleware","title":"RPC with Middleware","text":"<pre><code>import time\nimport logging\nfrom kn_sock import RPCServer\n\nclass MiddlewareRPCServer(RPCServer):\n    \"\"\"RPC server with middleware support.\"\"\"\n\n    def __init__(self, host, port):\n        super().__init__(host, port)\n        self.middleware_stack = []\n\n    def add_middleware(self, middleware):\n        \"\"\"Add middleware to the server.\"\"\"\n        self.middleware_stack.append(middleware)\n\n    def process_request(self, request_data, client_socket):\n        \"\"\"Process request through middleware stack.\"\"\"\n\n        # Create request context\n        context = {\n            \"request\": request_data,\n            \"client_socket\": client_socket,\n            \"start_time\": time.time(),\n            \"metadata\": {}\n        }\n\n        # Process through middleware (before)\n        for middleware in self.middleware_stack:\n            if hasattr(middleware, \"before_request\"):\n                middleware.before_request(context)\n\n        try:\n            # Process the actual request\n            result = super().process_request(request_data, client_socket)\n            context[\"result\"] = result\n\n        except Exception as e:\n            context[\"error\"] = e\n            raise\n\n        finally:\n            # Process through middleware (after) - in reverse order\n            for middleware in reversed(self.middleware_stack):\n                if hasattr(middleware, \"after_request\"):\n                    middleware.after_request(context)\n\n        return result\n\nclass LoggingMiddleware:\n    \"\"\"Middleware for request/response logging.\"\"\"\n\n    def __init__(self):\n        self.logger = logging.getLogger(\"rpc.requests\")\n        self.logger.setLevel(logging.INFO)\n\n        # Create console handler\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n\n    def before_request(self, context):\n        \"\"\"Log incoming request.\"\"\"\n        request = context[\"request\"]\n        client_addr = context[\"client_socket\"].getpeername()\n\n        self.logger.info(f\"Request from {client_addr}: {request.get('method')} with params {request.get('params')}\")\n        context[\"metadata\"][\"log_id\"] = f\"{time.time()}_{client_addr[0]}_{client_addr[1]}\"\n\n    def after_request(self, context):\n        \"\"\"Log request completion.\"\"\"\n        duration = time.time() - context[\"start_time\"]\n        log_id = context[\"metadata\"].get(\"log_id\", \"unknown\")\n\n        if \"error\" in context:\n            self.logger.error(f\"Request {log_id} failed after {duration:.3f}s: {context['error']}\")\n        else:\n            self.logger.info(f\"Request {log_id} completed in {duration:.3f}s\")\n\nclass RateLimitMiddleware:\n    \"\"\"Middleware for rate limiting.\"\"\"\n\n    def __init__(self, max_requests_per_minute=60):\n        self.max_requests = max_requests_per_minute\n        self.request_history = {}  # client_ip -&gt; list of timestamps\n\n    def before_request(self, context):\n        \"\"\"Check rate limit before processing request.\"\"\"\n        client_ip = context[\"client_socket\"].getpeername()[0]\n        current_time = time.time()\n\n        # Clean old requests (older than 1 minute)\n        if client_ip in self.request_history:\n            self.request_history[client_ip] = [\n                timestamp for timestamp in self.request_history[client_ip]\n                if current_time - timestamp &lt; 60\n            ]\n        else:\n            self.request_history[client_ip] = []\n\n        # Check rate limit\n        if len(self.request_history[client_ip]) &gt;= self.max_requests:\n            raise Exception(f\"Rate limit exceeded for {client_ip}\")\n\n        # Add current request\n        self.request_history[client_ip].append(current_time)\n\nclass CachingMiddleware:\n    \"\"\"Middleware for response caching.\"\"\"\n\n    def __init__(self, cache_ttl=300):  # 5 minutes default\n        self.cache = {}\n        self.cache_ttl = cache_ttl\n\n    def _get_cache_key(self, request):\n        \"\"\"Generate cache key for request.\"\"\"\n        method = request.get(\"method\")\n        params = str(request.get(\"params\", {}))\n        return f\"{method}:{hash(params)}\"\n\n    def before_request(self, context):\n        \"\"\"Check cache before processing request.\"\"\"\n        request = context[\"request\"]\n        cache_key = self._get_cache_key(request)\n\n        if cache_key in self.cache:\n            cached_entry = self.cache[cache_key]\n            current_time = time.time()\n\n            # Check if cache entry is still valid\n            if current_time - cached_entry[\"timestamp\"] &lt; self.cache_ttl:\n                context[\"cached_result\"] = cached_entry[\"result\"]\n                context[\"cache_hit\"] = True\n                return\n\n        context[\"cache_key\"] = cache_key\n        context[\"cache_hit\"] = False\n\n    def after_request(self, context):\n        \"\"\"Cache the response after processing.\"\"\"\n        if not context.get(\"cache_hit\") and \"result\" in context:\n            cache_key = context.get(\"cache_key\")\n            if cache_key:\n                self.cache[cache_key] = {\n                    \"result\": context[\"result\"],\n                    \"timestamp\": time.time()\n                }\n\nclass MetricsMiddleware:\n    \"\"\"Middleware for collecting metrics.\"\"\"\n\n    def __init__(self):\n        self.metrics = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"avg_response_time\": 0,\n            \"method_counts\": {},\n            \"response_times\": []\n        }\n\n    def before_request(self, context):\n        \"\"\"Start metrics collection for request.\"\"\"\n        self.metrics[\"total_requests\"] += 1\n        method = context[\"request\"].get(\"method\", \"unknown\")\n\n        if method not in self.metrics[\"method_counts\"]:\n            self.metrics[\"method_counts\"][method] = 0\n        self.metrics[\"method_counts\"][method] += 1\n\n    def after_request(self, context):\n        \"\"\"Complete metrics collection for request.\"\"\"\n        duration = time.time() - context[\"start_time\"]\n        self.metrics[\"response_times\"].append(duration)\n\n        # Keep only last 1000 response times\n        if len(self.metrics[\"response_times\"]) &gt; 1000:\n            self.metrics[\"response_times\"].pop(0)\n\n        # Update average response time\n        self.metrics[\"avg_response_time\"] = sum(self.metrics[\"response_times\"]) / len(self.metrics[\"response_times\"])\n\n        if \"error\" in context:\n            self.metrics[\"failed_requests\"] += 1\n        else:\n            self.metrics[\"successful_requests\"] += 1\n\n    def get_metrics(self):\n        \"\"\"Get current metrics.\"\"\"\n        return self.metrics.copy()\n\n# Usage example\ndef middleware_rpc_example():\n    \"\"\"Example RPC server with middleware.\"\"\"\n\n    # Create server with middleware\n    server = MiddlewareRPCServer('localhost', 8083)\n\n    # Add middleware (order matters!)\n    server.add_middleware(LoggingMiddleware())\n    server.add_middleware(RateLimitMiddleware(max_requests_per_minute=30))\n    server.add_middleware(CachingMiddleware(cache_ttl=60))\n    metrics_middleware = MetricsMiddleware()\n    server.add_middleware(metrics_middleware)\n\n    # Register services\n    class CalculatorService:\n        def add(self, a, b):\n            time.sleep(0.1)  # Simulate work\n            return a + b\n\n        def expensive_calculation(self, n):\n            \"\"\"Expensive operation that benefits from caching.\"\"\"\n            time.sleep(1)  # Simulate expensive calculation\n            return sum(range(n))\n\n    calc_service = CalculatorService()\n    server.register_service('calc', calc_service)\n\n    # Register metrics endpoint\n    def get_metrics():\n        return metrics_middleware.get_metrics()\n\n    server.register_function('get_metrics', get_metrics)\n\n    print(\"Middleware RPC Server started on localhost:8083\")\n    print(\"Features enabled:\")\n    print(\"  - Request/Response logging\")\n    print(\"  - Rate limiting (30 requests/minute)\")\n    print(\"  - Response caching (60 seconds TTL)\")\n    print(\"  - Metrics collection\")\n    print(\"\\nAvailable methods:\")\n    print(\"  - calc.add(a, b)\")\n    print(\"  - calc.expensive_calculation(n)\")\n    print(\"  - get_metrics()\")\n\n    server.start()\n</code></pre>"},{"location":"advanced/rpc/#load-balanced-rpc","title":"Load Balanced RPC","text":"<pre><code>import random\nimport threading\nfrom kn_sock import RPCClient\n\nclass LoadBalancedRPCClient:\n    \"\"\"RPC client with load balancing across multiple servers.\"\"\"\n\n    def __init__(self, server_addresses, strategy=\"round_robin\"):\n        self.server_addresses = server_addresses\n        self.strategy = strategy\n        self.clients = {}\n        self.current_server = 0\n        self.server_health = {}\n\n        # Initialize connections\n        self.connect_to_servers()\n\n        # Start health monitoring\n        self.health_monitor_thread = threading.Thread(\n            target=self.monitor_server_health, \n            daemon=True\n        )\n        self.health_monitor_thread.start()\n\n    def connect_to_servers(self):\n        \"\"\"Connect to all servers.\"\"\"\n        for address in self.server_addresses:\n            try:\n                host, port = address.split(':')\n                client = RPCClient(host, int(port))\n                self.clients[address] = client\n                self.server_health[address] = True\n                print(f\"Connected to {address}\")\n            except Exception as e:\n                print(f\"Failed to connect to {address}: {e}\")\n                self.server_health[address] = False\n\n    def get_next_server(self):\n        \"\"\"Get next server based on load balancing strategy.\"\"\"\n        healthy_servers = [addr for addr, healthy in self.server_health.items() if healthy]\n\n        if not healthy_servers:\n            raise Exception(\"No healthy servers available\")\n\n        if self.strategy == \"round_robin\":\n            server = healthy_servers[self.current_server % len(healthy_servers)]\n            self.current_server += 1\n            return server\n\n        elif self.strategy == \"random\":\n            return random.choice(healthy_servers)\n\n        elif self.strategy == \"least_connections\":\n            # Simple implementation - could be improved with actual connection counting\n            return min(healthy_servers, key=lambda addr: self.get_connection_count(addr))\n\n        else:\n            return healthy_servers[0]  # Fallback to first healthy server\n\n    def get_connection_count(self, address):\n        \"\"\"Get connection count for a server (placeholder implementation).\"\"\"\n        # In real implementation, track active connections\n        return random.randint(1, 10)\n\n    def call(self, method, *args, **kwargs):\n        \"\"\"Make load-balanced RPC call.\"\"\"\n        max_retries = len(self.server_addresses)\n\n        for attempt in range(max_retries):\n            try:\n                server_address = self.get_next_server()\n                client = self.clients[server_address]\n\n                result = client.call(method, *args, **kwargs)\n                return result\n\n            except Exception as e:\n                print(f\"Call failed on {server_address}: {e}\")\n                self.server_health[server_address] = False\n\n                if attempt == max_retries - 1:\n                    raise Exception(f\"All servers failed for method {method}\")\n\n    def monitor_server_health(self):\n        \"\"\"Monitor server health periodically.\"\"\"\n        import time\n\n        while True:\n            time.sleep(10)  # Check every 10 seconds\n\n            for address in self.server_addresses:\n                try:\n                    if address in self.clients:\n                        # Try a simple health check call\n                        self.clients[address].call('health_check')\n                        self.server_health[address] = True\n                    else:\n                        # Try to reconnect\n                        host, port = address.split(':')\n                        client = RPCClient(host, int(port))\n                        self.clients[address] = client\n                        self.server_health[address] = True\n                        print(f\"Reconnected to {address}\")\n\n                except Exception:\n                    self.server_health[address] = False\n\n    def close_all(self):\n        \"\"\"Close all client connections.\"\"\"\n        for client in self.clients.values():\n            try:\n                client.close()\n            except:\n                pass\n\n# Service discovery with RPC\nclass ServiceRegistry:\n    \"\"\"Simple service registry for RPC servers.\"\"\"\n\n    def __init__(self):\n        self.services = {}  # service_name -&gt; list of server addresses\n        self.server_metadata = {}  # server_address -&gt; metadata\n\n    def register_service(self, service_name, server_address, metadata=None):\n        \"\"\"Register a service instance.\"\"\"\n        if service_name not in self.services:\n            self.services[service_name] = []\n\n        if server_address not in self.services[service_name]:\n            self.services[service_name].append(server_address)\n            self.server_metadata[server_address] = metadata or {}\n            print(f\"Registered {service_name} at {server_address}\")\n\n        return True\n\n    def unregister_service(self, service_name, server_address):\n        \"\"\"Unregister a service instance.\"\"\"\n        if service_name in self.services:\n            if server_address in self.services[service_name]:\n                self.services[service_name].remove(server_address)\n                if server_address in self.server_metadata:\n                    del self.server_metadata[server_address]\n                print(f\"Unregistered {service_name} at {server_address}\")\n                return True\n        return False\n\n    def discover_service(self, service_name):\n        \"\"\"Discover available instances of a service.\"\"\"\n        return self.services.get(service_name, [])\n\n    def list_services(self):\n        \"\"\"List all registered services.\"\"\"\n        return dict(self.services)\n\n# Usage example\ndef load_balanced_rpc_example():\n    \"\"\"Example of load-balanced RPC.\"\"\"\n\n    # Server addresses (you would start multiple RPC servers)\n    server_addresses = [\n        'localhost:8080',\n        'localhost:8081', \n        'localhost:8082'\n    ]\n\n    # Create load-balanced client\n    lb_client = LoadBalancedRPCClient(server_addresses, strategy=\"round_robin\")\n\n    try:\n        # Make load-balanced calls\n        for i in range(10):\n            result = lb_client.call('math.add', i, i * 2)\n            print(f\"Call {i}: {result}\")\n\n        # Concurrent calls\n        import concurrent.futures\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n            futures = []\n            for i in range(20):\n                future = executor.submit(lb_client.call, 'math.multiply', i, 2)\n                futures.append(future)\n\n            for i, future in enumerate(concurrent.futures.as_completed(futures)):\n                result = future.result()\n                print(f\"Concurrent call {i}: {result}\")\n\n    finally:\n        lb_client.close_all()\n</code></pre>"},{"location":"advanced/rpc/#protocol-buffers-with-rpc","title":"Protocol Buffers with RPC","text":"<pre><code># First, install protobuf: pip install protobuf\n\nfrom kn_sock import RPCServer, RPCClient\nimport person_pb2  # Generated from person.proto\n\n# person.proto content:\n\"\"\"\nsyntax = \"proto3\";\n\nmessage Person {\n    string name = 1;\n    int32 age = 2;\n    string email = 3;\n    repeated string hobbies = 4;\n}\n\nmessage PersonList {\n    repeated Person people = 1;\n}\n\"\"\"\n\nclass ProtobufPersonService:\n    \"\"\"RPC service using Protocol Buffers.\"\"\"\n\n    def __init__(self):\n        self.people = {}\n        self.next_id = 1\n\n    def create_person(self, person_data):\n        \"\"\"Create a person from protobuf data.\"\"\"\n        # Deserialize protobuf\n        person = person_pb2.Person()\n        person.ParseFromString(person_data)\n\n        # Store person\n        person_id = self.next_id\n        self.next_id += 1\n        self.people[person_id] = person\n\n        return person_id\n\n    def get_person(self, person_id):\n        \"\"\"Get a person as protobuf data.\"\"\"\n        if person_id in self.people:\n            return self.people[person_id].SerializeToString()\n        else:\n            raise ValueError(f\"Person {person_id} not found\")\n\n    def list_people(self):\n        \"\"\"Get all people as protobuf data.\"\"\"\n        person_list = person_pb2.PersonList()\n        for person in self.people.values():\n            person_list.people.append(person)\n\n        return person_list.SerializeToString()\n\n    def update_person(self, person_id, person_data):\n        \"\"\"Update a person with protobuf data.\"\"\"\n        if person_id not in self.people:\n            raise ValueError(f\"Person {person_id} not found\")\n\n        person = person_pb2.Person()\n        person.ParseFromString(person_data)\n        self.people[person_id] = person\n\n        return True\n\ndef protobuf_rpc_example():\n    \"\"\"Example using Protocol Buffers with RPC.\"\"\"\n\n    # Start server\n    server = RPCServer('localhost', 8084)\n    person_service = ProtobufPersonService()\n    server.register_service('person', person_service)\n\n    # Start server in background\n    import threading\n    server_thread = threading.Thread(target=server.start, daemon=True)\n    server_thread.start()\n\n    # Client usage\n    client = RPCClient('localhost', 8084)\n\n    try:\n        # Create person using protobuf\n        person = person_pb2.Person()\n        person.name = \"Alice Johnson\"\n        person.age = 30\n        person.email = \"alice@example.com\"\n        person.hobbies.extend([\"reading\", \"hiking\", \"photography\"])\n\n        # Serialize and send\n        person_data = person.SerializeToString()\n        person_id = client.call('person.create_person', person_data)\n        print(f\"Created person with ID: {person_id}\")\n\n        # Retrieve person\n        retrieved_data = client.call('person.get_person', person_id)\n\n        # Deserialize\n        retrieved_person = person_pb2.Person()\n        retrieved_person.ParseFromString(retrieved_data)\n\n        print(f\"Retrieved person: {retrieved_person.name}, age {retrieved_person.age}\")\n        print(f\"Email: {retrieved_person.email}\")\n        print(f\"Hobbies: {list(retrieved_person.hobbies)}\")\n\n        # Create more people\n        for i in range(3):\n            person = person_pb2.Person()\n            person.name = f\"Person {i+2}\"\n            person.age = 25 + i\n            person.email = f\"person{i+2}@example.com\"\n            person.hobbies.extend([f\"hobby{i+1}\", f\"hobby{i+2}\"])\n\n            person_data = person.SerializeToString()\n            client.call('person.create_person', person_data)\n\n        # List all people\n        people_data = client.call('person.list_people')\n        people_list = person_pb2.PersonList()\n        people_list.ParseFromString(people_data)\n\n        print(f\"\\nAll people ({len(people_list.people)}):\")\n        for person in people_list.people:\n            print(f\"  - {person.name}, age {person.age}\")\n\n    finally:\n        client.close()\n</code></pre>"},{"location":"advanced/rpc/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>import time\nimport threading\nimport statistics\nfrom collections import defaultdict, deque\n\nclass PerformanceMonitor:\n    \"\"\"Performance monitoring for RPC servers.\"\"\"\n\n    def __init__(self, window_size=1000):\n        self.window_size = window_size\n        self.call_times = deque(maxlen=window_size)\n        self.method_stats = defaultdict(lambda: {\n            \"count\": 0,\n            \"total_time\": 0,\n            \"times\": deque(maxlen=100)\n        })\n        self.error_count = 0\n        self.start_time = time.time()\n\n    def record_call(self, method, duration, success=True):\n        \"\"\"Record an RPC call.\"\"\"\n        self.call_times.append(duration)\n\n        stats = self.method_stats[method]\n        stats[\"count\"] += 1\n        stats[\"total_time\"] += duration\n        stats[\"times\"].append(duration)\n\n        if not success:\n            self.error_count += 1\n\n    def get_stats(self):\n        \"\"\"Get current performance statistics.\"\"\"\n        if not self.call_times:\n            return {\"error\": \"No data available\"}\n\n        total_calls = len(self.call_times)\n        avg_time = statistics.mean(self.call_times)\n        median_time = statistics.median(self.call_times)\n\n        stats = {\n            \"uptime\": time.time() - self.start_time,\n            \"total_calls\": total_calls,\n            \"error_count\": self.error_count,\n            \"error_rate\": self.error_count / total_calls if total_calls &gt; 0 else 0,\n            \"avg_call_time\": avg_time,\n            \"median_call_time\": median_time,\n            \"calls_per_second\": total_calls / (time.time() - self.start_time),\n            \"method_stats\": {}\n        }\n\n        # Add per-method statistics\n        for method, method_stats in self.method_stats.items():\n            if method_stats[\"times\"]:\n                stats[\"method_stats\"][method] = {\n                    \"count\": method_stats[\"count\"],\n                    \"avg_time\": method_stats[\"total_time\"] / method_stats[\"count\"],\n                    \"median_time\": statistics.median(method_stats[\"times\"]),\n                    \"min_time\": min(method_stats[\"times\"]),\n                    \"max_time\": max(method_stats[\"times\"])\n                }\n\n        return stats\n\nclass MonitoredRPCServer(RPCServer):\n    \"\"\"RPC server with built-in performance monitoring.\"\"\"\n\n    def __init__(self, host, port):\n        super().__init__(host, port)\n        self.monitor = PerformanceMonitor()\n\n    def process_request(self, request_data, client_socket):\n        \"\"\"Process request with performance monitoring.\"\"\"\n        method = request_data.get(\"method\", \"unknown\")\n        start_time = time.time()\n        success = True\n\n        try:\n            result = super().process_request(request_data, client_socket)\n            return result\n        except Exception as e:\n            success = False\n            raise\n        finally:\n            duration = time.time() - start_time\n            self.monitor.record_call(method, duration, success)\n\n    def get_performance_stats(self):\n        \"\"\"Get performance statistics.\"\"\"\n        return self.monitor.get_stats()\n\n# Register performance endpoint\ndef setup_monitored_server():\n    \"\"\"Set up RPC server with monitoring.\"\"\"\n\n    server = MonitoredRPCServer('localhost', 8085)\n\n    # Register the stats endpoint\n    server.register_function('get_stats', server.get_performance_stats)\n\n    # Add some example services\n    class BenchmarkService:\n        def fast_operation(self):\n            return \"fast\"\n\n        def slow_operation(self):\n            time.sleep(0.5)\n            return \"slow\"\n\n        def error_operation(self):\n            raise ValueError(\"Intentional error for testing\")\n\n    benchmark_service = BenchmarkService()\n    server.register_service('benchmark', benchmark_service)\n\n    return server\n\n# Usage\nif __name__ == \"__main__\":\n    server = setup_monitored_server()\n\n    print(\"Monitored RPC Server started on localhost:8085\")\n    print(\"Performance monitoring enabled\")\n    print(\"Available methods:\")\n    print(\"  - benchmark.fast_operation()\")\n    print(\"  - benchmark.slow_operation()\")\n    print(\"  - benchmark.error_operation()\")\n    print(\"  - get_stats()\")\n\n    server.start()\n</code></pre>"},{"location":"advanced/rpc/#see-also","title":"See Also","text":"<ul> <li>TCP Protocol - For reliable RPC transport</li> <li>JSON Communication - For JSON-based RPC</li> <li>Pub/Sub Messaging - For event-driven communication</li> <li>WebSocket Protocol - For real-time RPC</li> <li>Examples - RPC application examples</li> </ul>"},{"location":"advanced/video-chat/","title":"Video Chat","text":"<p>kn-sock provides real-time multi-client video chat with voice, allowing multiple users to join rooms and communicate with both video and audio in real time.</p>"},{"location":"advanced/video-chat/#overview","title":"Overview","text":"<p>Video chat features in kn-sock: - Multi-client support: Multiple users can join the same room and see/hear each other - Rooms/Channels: Users can join named rooms; only users in the same room see/hear each other - User Nicknames: Each client can set a nickname, which is shared with the server and other clients - Text Chat: Real-time text messaging with chat overlay on video window - Mute/Unmute: Toggle audio on/off with keyboard shortcut - Video On/Off: Toggle video camera on/off with keyboard shortcut - Real-time video and audio: Uses OpenCV for video and PyAudio for audio - Simple API: Easy to start a server or connect as a client</p>"},{"location":"advanced/video-chat/#basic-video-chat","title":"Basic Video Chat","text":""},{"location":"advanced/video-chat/#video-chat-server","title":"Video Chat Server","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\n\nserver = VideoChatServer(host='0.0.0.0', video_port=9000, audio_port=9001, text_port=9002)\nserver.start()\nprint('Video chat server started on ports 9000 (video), 9001 (audio), and 9002 (text).')\n\n# Keep the server running\ntry:\n    while True:\n        pass\nexcept KeyboardInterrupt:\n    print('Server stopped.')\n</code></pre>"},{"location":"advanced/video-chat/#video-chat-client","title":"Video Chat Client","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclient = VideoChatClient(\n    server_ip='127.0.0.1', \n    video_port=9000, \n    audio_port=9001, \n    text_port=9002, \n    room='myroom', \n    nickname='alice'\n)\nclient.start()\nprint('Connected to video chat server in room \"myroom\" as \"alice\".')\n\n# Keep the client running\ntry:\n    while client.running:\n        pass\nexcept KeyboardInterrupt:\n    print('Client stopped.')\n</code></pre>"},{"location":"advanced/video-chat/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"advanced/video-chat/#custom-server-configuration","title":"Custom Server Configuration","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\n\nserver = VideoChatServer(\n    host='0.0.0.0',\n    video_port=9000,\n    audio_port=9001,\n    text_port=9002,\n    max_clients_per_room=10,\n    enable_audio=True,\n    enable_video=True,\n    video_quality=70,\n    audio_sample_rate=44100\n)\nserver.start()\n</code></pre>"},{"location":"advanced/video-chat/#custom-client-configuration","title":"Custom Client Configuration","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclient = VideoChatClient(\n    server_ip='192.168.1.10',\n    video_port=9000,\n    audio_port=9001,\n    text_port=9002,\n    room='conference',\n    nickname='john',\n    enable_audio=True,\n    enable_video=True,\n    video_width=640,\n    video_height=480,\n    audio_channels=1,\n    audio_sample_rate=44100\n)\nclient.start()\n</code></pre>"},{"location":"advanced/video-chat/#client-controls","title":"Client Controls","text":"<p>When the video window is active, you can use these keyboard shortcuts:</p> <ul> <li><code>m</code>: Mute/unmute your microphone</li> <li><code>v</code>: Toggle your video camera on/off</li> <li><code>q</code>: Quit the application</li> </ul>"},{"location":"advanced/video-chat/#text-chat","title":"Text Chat","text":"<ul> <li>Type messages in the terminal and press Enter to send</li> <li>Chat messages appear as an overlay on the video window</li> <li>Messages include timestamps and sender nicknames</li> <li>Only users in the same room receive the messages</li> </ul>"},{"location":"advanced/video-chat/#cli-usage","title":"CLI Usage","text":""},{"location":"advanced/video-chat/#start-video-chat-server","title":"Start Video Chat Server","text":"<pre><code># Start with default settings\nkn-sock run-video-chat-server\n\n# Start with custom configuration\nkn-sock run-video-chat-server --host 0.0.0.0 --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre>"},{"location":"advanced/video-chat/#connect-to-video-chat-server","title":"Connect to Video Chat Server","text":"<pre><code># Connect with room and nickname\nkn-sock connect-video-chat 127.0.0.1 myroom alice\n\n# Connect with custom ports\nkn-sock connect-video-chat 192.168.1.10 conference john --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre>"},{"location":"advanced/video-chat/#use-cases","title":"Use Cases","text":""},{"location":"advanced/video-chat/#multi-room-conference-system","title":"Multi-Room Conference System","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\nimport threading\n\ndef start_conference_room(room_name, port_base):\n    \"\"\"Start a conference room\"\"\"\n    server = VideoChatServer(\n        host='0.0.0.0',\n        video_port=port_base,\n        audio_port=port_base + 1,\n        text_port=port_base + 2,\n        max_clients_per_room=20\n    )\n\n    print(f\"Starting conference room '{room_name}' on ports {port_base}, {port_base+1}, {port_base+2}\")\n    server.start()\n\n# Start multiple conference rooms\nrooms = [\n    (\"Engineering\", 9000),\n    (\"Marketing\", 9100),\n    (\"Sales\", 9200),\n    (\"Support\", 9300)\n]\n\nfor room_name, port_base in rooms:\n    thread = threading.Thread(\n        target=start_conference_room,\n        args=(room_name, port_base),\n        daemon=True\n    )\n    thread.start()\n</code></pre>"},{"location":"advanced/video-chat/#classroom-video-chat","title":"Classroom Video Chat","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclass ClassroomClient(VideoChatClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.is_teacher = kwargs.get('is_teacher', False)\n\n    def on_message_received(self, sender, message):\n        \"\"\"Handle incoming messages\"\"\"\n        if self.is_teacher:\n            # Teachers can see all messages\n            print(f\"[{sender}]: {message}\")\n        else:\n            # Students only see teacher messages and their own\n            if sender == \"teacher\" or sender == self.nickname:\n                print(f\"[{sender}]: {message}\")\n\n    def on_user_joined(self, nickname):\n        \"\"\"Handle user joining\"\"\"\n        if self.is_teacher:\n            print(f\"Student {nickname} joined the class\")\n        else:\n            print(f\"User {nickname} joined\")\n\n# Teacher client\nteacher = ClassroomClient(\n    server_ip='192.168.1.10',\n    room='math101',\n    nickname='teacher',\n    is_teacher=True\n)\nteacher.start()\n\n# Student client\nstudent = ClassroomClient(\n    server_ip='192.168.1.10',\n    room='math101',\n    nickname='student1',\n    is_teacher=False\n)\nstudent.start()\n</code></pre>"},{"location":"advanced/video-chat/#family-video-chat","title":"Family Video Chat","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclass FamilyChatClient(VideoChatClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.family_members = kwargs.get('family_members', [])\n\n    def on_user_joined(self, nickname):\n        \"\"\"Welcome family members\"\"\"\n        if nickname in self.family_members:\n            self.send_message(f\"Welcome back, {nickname}!\")\n        else:\n            self.send_message(f\"Welcome, {nickname}!\")\n\n    def on_user_left(self, nickname):\n        \"\"\"Say goodbye to family members\"\"\"\n        if nickname in self.family_members:\n            self.send_message(f\"See you later, {nickname}!\")\n\n# Family members\nfamily_members = [\"mom\", \"dad\", \"sister\", \"brother\"]\n\n# Create family chat client\nfamily_client = FamilyChatClient(\n    server_ip='192.168.1.10',\n    room='family',\n    nickname='me',\n    family_members=family_members\n)\nfamily_client.start()\n</code></pre>"},{"location":"advanced/video-chat/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/video-chat/#bandwidth-optimization","title":"Bandwidth Optimization","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\n# For slow connections\nclient = VideoChatClient(\n    server_ip='remote-server.com',\n    room='meeting',\n    nickname='user',\n    video_width=320,  # Lower resolution\n    video_height=240,\n    video_quality=50,  # Lower quality\n    enable_audio=True,\n    enable_video=True\n)\n\n# For high-quality connections\nclient = VideoChatClient(\n    server_ip='local-server',\n    room='meeting',\n    nickname='user',\n    video_width=1280,  # Higher resolution\n    video_height=720,\n    video_quality=90,  # Higher quality\n    enable_audio=True,\n    enable_video=True\n)\n</code></pre>"},{"location":"advanced/video-chat/#audio-optimization","title":"Audio Optimization","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\n# For voice-only meetings\nclient = VideoChatClient(\n    server_ip='192.168.1.10',\n    room='voice-meeting',\n    nickname='user',\n    enable_audio=True,\n    enable_video=False,  # Disable video for voice-only\n    audio_sample_rate=22050,  # Lower sample rate\n    audio_channels=1  # Mono audio\n)\n\n# For music/audio quality\nclient = VideoChatClient(\n    server_ip='192.168.1.10',\n    room='music-room',\n    nickname='user',\n    enable_audio=True,\n    enable_video=True,\n    audio_sample_rate=48000,  # Higher sample rate\n    audio_channels=2  # Stereo audio\n)\n</code></pre>"},{"location":"advanced/video-chat/#error-handling","title":"Error Handling","text":""},{"location":"advanced/video-chat/#connection-issues","title":"Connection Issues","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\nimport time\n\ndef resilient_video_chat():\n    while True:\n        try:\n            client = VideoChatClient(\n                server_ip='192.168.1.10',\n                room='meeting',\n                nickname='user'\n            )\n            client.start()\n        except Exception as e:\n            print(f\"Connection lost: {e}\")\n            print(\"Reconnecting in 5 seconds...\")\n            time.sleep(5)\n\nresilient_video_chat()\n</code></pre>"},{"location":"advanced/video-chat/#audiovideo-issues","title":"Audio/Video Issues","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\n# Test audio and video separately\ndef test_media():\n    try:\n        client = VideoChatClient(\n            server_ip='192.168.1.10',\n            room='test',\n            nickname='tester',\n            enable_audio=True,\n            enable_video=True\n        )\n\n        # Test video\n        if client.test_video():\n            print(\"\u2713 Video working\")\n        else:\n            print(\"\u2717 Video not working\")\n\n        # Test audio\n        if client.test_audio():\n            print(\"\u2713 Audio working\")\n        else:\n            print(\"\u2717 Audio not working\")\n\n    except Exception as e:\n        print(f\"Media test failed: {e}\")\n\ntest_media()\n</code></pre>"},{"location":"advanced/video-chat/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/video-chat/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"advanced/video-chat/#audio-issues-most-common","title":"Audio Issues (Most Common)","text":"<p>If you encounter PyAudio assertion errors or audio crashes:</p> <ol> <li> <p>Disable audio temporarily: <pre><code>python examples/video_chat_client.py 127.0.0.1 myroom alice --no-audio\n</code></pre></p> </li> <li> <p>Use the no-audio client: <pre><code>python examples/video_chat_client_no_audio.py 127.0.0.1 myroom alice\n</code></pre></p> </li> <li> <p>Test audio separately: <pre><code>python examples/test_audio_only.py\n</code></pre></p> </li> <li> <p>Install audio drivers (Arch Linux): <pre><code>sudo pacman -S pulseaudio pulseaudio-alsa\n</code></pre></p> </li> <li> <p>Set audio environment variables: <pre><code>export PULSE_SERVER=unix:/tmp/pulse-socket\nexport ALSA_PCM_CARD=0\n</code></pre></p> </li> </ol>"},{"location":"advanced/video-chat/#display-issues","title":"Display Issues","text":"<pre><code># Set display backend for OpenCV\nexport QT_QPA_PLATFORM=xcb\n</code></pre>"},{"location":"advanced/video-chat/#camera-issues","title":"Camera Issues","text":"<ul> <li>Make sure your camera is not in use by another application</li> <li>Check camera permissions</li> <li>Try different camera device numbers if you have multiple cameras</li> </ul>"},{"location":"advanced/video-chat/#dependencies","title":"Dependencies","text":"<pre><code># Install required packages\npip install opencv-python pyaudio numpy\n</code></pre> <p>Note: The video chat feature works perfectly without audio. If you have persistent audio issues, you can still use video and text chat functionality.</p>"},{"location":"advanced/video-chat/#requirements","title":"Requirements","text":""},{"location":"advanced/video-chat/#python-dependencies","title":"Python Dependencies","text":"<pre><code>pip install opencv-python pyaudio numpy\n</code></pre>"},{"location":"advanced/video-chat/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Webcam: For video functionality</li> <li>Microphone: For audio functionality</li> <li>Speakers/Headphones: For audio output</li> </ul>"},{"location":"advanced/video-chat/#network-requirements","title":"Network Requirements","text":"<ul> <li>TCP ports for video, audio, and text streams (default: 9000, 9001, and 9002)</li> <li>Sufficient bandwidth for video streaming</li> <li>Low latency for real-time communication</li> </ul>"},{"location":"advanced/video-chat/#related-topics","title":"Related Topics","text":"<ul> <li>Live Streaming - For one-to-many video streaming</li> <li>TCP Protocol - For underlying transport</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"network/arp/","title":"ARP Scanning","text":"<p>ARP (Address Resolution Protocol) scanning allows you to discover active devices on your local network by sending ARP requests and analyzing responses.</p> <p>\u26a0\ufe0f ETHICAL WARNING: ARP scanning is intended for use in authorized networks only. This tool should only be used in controlled IT environments, schools, or labs with proper authorization. Unauthorized network scanning may be illegal and unethical.</p>"},{"location":"network/arp/#features","title":"Features","text":"<ul> <li>Network Discovery: Find all active devices on a subnet</li> <li>MAC Address Resolution: Get MAC addresses for discovered devices</li> <li>Interface Auto-Detection: Automatically detect the best network interface</li> <li>Customizable Timeouts: Adjust scan speed and reliability</li> <li>Verbose Logging: Detailed output for troubleshooting</li> </ul>"},{"location":"network/arp/#installation","title":"Installation","text":"<p>ARP scanning requires the <code>scapy</code> library:</p> <pre><code>pip install scapy\n</code></pre> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/arp/#basic-usage","title":"Basic Usage","text":""},{"location":"network/arp/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import arp_scan\n\n# Scan a local network\ndevices = arp_scan(\"192.168.1.0/24\")\nfor device in devices:\n    print(f\"IP: {device['ip']}, MAC: {device['mac']}\")\n</code></pre>"},{"location":"network/arp/#command-line","title":"Command Line","text":"<pre><code># Basic scan\nknsock scan 192.168.1.0/24\n\n# Verbose output\nknsock scan 192.168.1.0/24 --verbose\n\n# Custom interface and timeout\nknsock scan 192.168.1.0/24 --interface eth0 --timeout 5\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/arp/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/arp/#custom-interface-selection","title":"Custom Interface Selection","text":"<pre><code>from kn_sock.network import arp_scan\n\n# Specify network interface\ndevices = arp_scan(\"192.168.1.0/24\", interface=\"eth0\")\n</code></pre>"},{"location":"network/arp/#verbose-logging","title":"Verbose Logging","text":"<pre><code>from kn_sock.network import arp_scan\n\n# Enable detailed logging\ndevices = arp_scan(\"192.168.1.0/24\", verbose=True)\n</code></pre>"},{"location":"network/arp/#simple-ipmac-pairs","title":"Simple IP/MAC Pairs","text":"<pre><code>from kn_sock.network.arp import arp_scan_simple\n\n# Get simple (IP, MAC) tuples\ndevice_pairs = arp_scan_simple(\"192.168.1.0/24\")\nfor ip, mac in device_pairs:\n    print(f\"{ip} -&gt; {mac}\")\n</code></pre>"},{"location":"network/arp/#network-information","title":"Network Information","text":"<pre><code>from kn_sock.network.arp import get_local_network_info\n\n# Get local network details\ninfo = get_local_network_info()\nprint(f\"Local IP: {info['local_ip']}\")\nprint(f\"Interface: {info['interface']}\")\nprint(f\"Gateway: {info['gateway']}\")\n</code></pre>"},{"location":"network/arp/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/arp/#common-network-ranges","title":"Common Network Ranges","text":"Range Description Example <code>/24</code> 256 addresses 192.168.1.0/24 <code>/16</code> 65,536 addresses 192.168.0.0/16 <code>/8</code> 16,777,216 addresses 10.0.0.0/8"},{"location":"network/arp/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/arp/#permission-issues","title":"Permission Issues","text":"<p>ARP scanning requires network access. On Linux/macOS, you may need to run with elevated privileges:</p> <pre><code>sudo knsock scan 192.168.1.0/24\n</code></pre>"},{"location":"network/arp/#no-devices-found","title":"No Devices Found","text":"<ol> <li>Check Network Range: Ensure you're scanning the correct subnet</li> <li>Verify Interface: Use <code>--interface</code> to specify the correct network interface</li> <li>Firewall: Some devices may not respond to ARP requests due to firewall settings</li> <li>Network Isolation: Ensure you're on the same network segment</li> </ol>"},{"location":"network/arp/#interface-detection","title":"Interface Detection","text":"<p>List available interfaces:</p> <pre><code>from kn_sock.network.monitor import get_network_interfaces\n\ninterfaces = get_network_interfaces()\nfor iface in interfaces:\n    print(f\"{iface['name']}: {iface['ip']}\")\n</code></pre>"},{"location":"network/arp/#timeout-issues","title":"Timeout Issues","text":"<p>Increase timeout for slower networks:</p> <pre><code>devices = arp_scan(\"192.168.1.0/24\", timeout=5)\n</code></pre>"},{"location":"network/arp/#security-considerations","title":"Security Considerations","text":"<ol> <li>Authorization: Only scan networks you own or have permission to monitor</li> <li>Legal Compliance: Ensure compliance with local network monitoring laws</li> <li>Network Impact: ARP scanning generates network traffic - use responsibly</li> <li>Detection: Some network monitoring tools may detect ARP scans</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"network/arp/#examples","title":"Examples","text":""},{"location":"network/arp/#network-inventory","title":"Network Inventory","text":"<pre><code>from kn_sock.network import arp_scan\n\ndef network_inventory():\n    \"\"\"Create a simple network inventory.\"\"\"\n    devices = arp_scan(\"192.168.1.0/24\", verbose=True)\n\n    print(f\"Network Inventory - Found {len(devices)} devices:\")\n    print(\"-\" * 50)\n\n    for i, device in enumerate(devices, 1):\n        print(f\"{i:2d}. IP: {device['ip']:15s} MAC: {device['mac']}\")\n\nif __name__ == \"__main__\":\n    network_inventory()\n</code></pre>"},{"location":"network/arp/#continuous-monitoring","title":"Continuous Monitoring","text":"<pre><code>import time\nfrom kn_sock.network import arp_scan\n\ndef monitor_network():\n    \"\"\"Monitor network for new devices.\"\"\"\n    known_devices = set()\n\n    while True:\n        current_devices = arp_scan(\"192.168.1.0/24\")\n        current_ips = {device['ip'] for device in current_devices}\n\n        # Find new devices\n        new_devices = current_ips - known_devices\n        if new_devices:\n            print(f\"New devices detected: {new_devices}\")\n\n        # Find disconnected devices\n        disconnected = known_devices - current_ips\n        if disconnected:\n            print(f\"Devices disconnected: {disconnected}\")\n\n        known_devices = current_ips\n        time.sleep(30)  # Check every 30 seconds\n\nif __name__ == \"__main__\":\n    monitor_network()\n</code></pre>"},{"location":"network/arp/#integration-with-mac-lookup","title":"Integration with MAC Lookup","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\n\ndef detailed_network_scan():\n    \"\"\"Scan network and identify device vendors.\"\"\"\n    devices = arp_scan(\"192.168.1.0/24\")\n\n    for device in devices:\n        # Lookup vendor information\n        vendor_info = mac_lookup(device['mac'], use_api=False)\n\n        print(f\"IP: {device['ip']}\")\n        print(f\"MAC: {device['mac']}\")\n        print(f\"Vendor: {vendor_info['vendor']}\")\n        print(\"-\" * 40)\n\nif __name__ == \"__main__\":\n    detailed_network_scan()\n</code></pre>"},{"location":"network/maclookup/","title":"MAC Address Lookup","text":"<p>MAC address lookup allows you to identify device vendors and manufacturers by analyzing the Organizationally Unique Identifier (OUI) in MAC addresses.</p> <p>\u26a0\ufe0f ETHICAL WARNING: MAC address lookup is intended for legitimate network management purposes only. This tool should only be used in authorized networks for device identification and network administration.</p>"},{"location":"network/maclookup/#features","title":"Features","text":"<ul> <li>Vendor Identification: Identify device manufacturers from MAC addresses</li> <li>Online API Integration: Use macvendors.co API for comprehensive database</li> <li>Offline Mode: Built-in OUI database for offline operation</li> <li>Batch Processing: Lookup multiple MAC addresses efficiently</li> <li>Format Validation: Validate MAC address formats</li> <li>API Key Support: Use API keys for higher rate limits</li> </ul>"},{"location":"network/maclookup/#installation","title":"Installation","text":"<p>MAC lookup requires the <code>requests</code> library for online lookups:</p> <pre><code>pip install requests\n</code></pre> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/maclookup/#basic-usage","title":"Basic Usage","text":""},{"location":"network/maclookup/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import mac_lookup\n\n# Lookup a single MAC address\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\")\nprint(f\"Vendor: {result['vendor']}\")\nprint(f\"OUI: {result['oui']}\")\n</code></pre>"},{"location":"network/maclookup/#command-line","title":"Command Line","text":"<pre><code># Basic lookup\nknsock mac-lookup 00:1A:2B:3C:4D:5E\n\n# Offline mode only\nknsock mac-lookup 00:1A:2B:3C:4D:5E --offline\n\n# With API key\nknsock mac-lookup 00:1A:2B:3C:4D:5E --api-key YOUR_API_KEY\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/maclookup/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/maclookup/#online-vs-offline-lookup","title":"Online vs Offline Lookup","text":"<pre><code>from kn_sock.network import mac_lookup\n\n# Online lookup (default)\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=True)\n\n# Offline lookup only\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=False)\n</code></pre>"},{"location":"network/maclookup/#batch-processing","title":"Batch Processing","text":"<pre><code>from kn_sock.network.mac_lookup import batch_mac_lookup\n\n# Lookup multiple MAC addresses\nmacs = [\n    \"00:1A:2B:3C:4D:5E\",\n    \"08:00:27:12:34:56\",\n    \"52:54:00:AB:CD:EF\"\n]\n\nresults = batch_mac_lookup(macs)\nfor result in results:\n    print(f\"{result['mac']}: {result['vendor']}\")\n</code></pre>"},{"location":"network/maclookup/#mac-address-validation","title":"MAC Address Validation","text":"<pre><code>from kn_sock.network.mac_lookup import validate_mac\n\n# Validate MAC address format\nmacs = [\n    \"00:1A:2B:3C:4D:5E\",  # Valid\n    \"00-1A-2B-3C-4D-5E\",  # Valid\n    \"001A2B3C4D5E\",        # Valid\n    \"00:1A:2B:3C:4D\",     # Invalid (too short)\n    \"invalid-mac\"          # Invalid\n]\n\nfor mac in macs:\n    is_valid = validate_mac(mac)\n    print(f\"{mac}: {'Valid' if is_valid else 'Invalid'}\")\n</code></pre>"},{"location":"network/maclookup/#api-key-usage","title":"API Key Usage","text":"<pre><code>from kn_sock.network.mac_lookup import mac_lookup_api\n\n# Use API key for higher rate limits\nresult = mac_lookup_api(\"00:1A:2B:3C:4D:5E\", api_key=\"YOUR_API_KEY\")\n</code></pre>"},{"location":"network/maclookup/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/maclookup/#mac-address-formats","title":"MAC Address Formats","text":"<p>The lookup functions accept various MAC address formats:</p> Format Example Description Colon-separated <code>00:1A:2B:3C:4D:5E</code> Standard format Hyphen-separated <code>00-1A-2B-3C-4D-5E</code> Alternative format No separators <code>001A2B3C4D5E</code> Compact format Mixed case <code>00:1a:2b:3c:4d:5e</code> Case insensitive"},{"location":"network/maclookup/#common-oui-examples","title":"Common OUI Examples","text":"OUI Vendor Description <code>00:50:56</code> VMware, Inc. Virtual machines <code>08:00:27</code> Oracle VirtualBox Virtual machines <code>52:54:00</code> QEMU Virtual machines <code>00:15:5D</code> Microsoft Corporation Hyper-V <code>00:16:3E</code> Xen Virtual machines <code>AC:DE:48</code> Private Locally administered"},{"location":"network/maclookup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/maclookup/#api-rate-limits","title":"API Rate Limits","text":"<p>If you encounter rate limiting:</p> <ol> <li>Use API Key: Get a free API key from macvendors.co</li> <li>Switch to Offline Mode: Use built-in database</li> <li>Batch Processing: Process multiple MACs in one request</li> </ol> <pre><code># Use API key\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", api_key=\"YOUR_API_KEY\")\n\n# Or use offline mode\nresult = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=False)\n</code></pre>"},{"location":"network/maclookup/#network-connectivity","title":"Network Connectivity","text":"<p>For online lookups, ensure internet connectivity:</p> <pre><code>import requests\n\ntry:\n    response = requests.get(\"https://api.macvendors.com/00:1A:2B\", timeout=5)\n    print(\"API is accessible\")\nexcept requests.RequestException:\n    print(\"API not accessible, using offline mode\")\n    result = mac_lookup(\"00:1A:2B:3C:4D:5E\", use_api=False)\n</code></pre>"},{"location":"network/maclookup/#invalid-mac-addresses","title":"Invalid MAC Addresses","text":"<p>Validate MAC addresses before lookup:</p> <pre><code>from kn_sock.network.mac_lookup import validate_mac\n\nmac = \"00:1A:2B:3C:4D:5E\"\nif validate_mac(mac):\n    result = mac_lookup(mac)\nelse:\n    print(\"Invalid MAC address format\")\n</code></pre>"},{"location":"network/maclookup/#security-considerations","title":"Security Considerations","text":"<ol> <li>Privacy: MAC addresses can reveal device information</li> <li>Network Security: Use for legitimate network administration only</li> <li>Data Protection: Be mindful of collected MAC address data</li> <li>API Keys: Keep API keys secure and don't share them</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"network/maclookup/#examples","title":"Examples","text":""},{"location":"network/maclookup/#network-device-inventory","title":"Network Device Inventory","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\n\ndef device_inventory():\n    \"\"\"Create detailed device inventory with vendor information.\"\"\"\n    # Scan network for devices\n    devices = arp_scan(\"192.168.1.0/24\")\n\n    print(\"Network Device Inventory\")\n    print(\"=\" * 60)\n\n    for device in devices:\n        # Lookup vendor information\n        vendor_info = mac_lookup(device['mac'], use_api=False)\n\n        print(f\"IP Address: {device['ip']}\")\n        print(f\"MAC Address: {device['mac']}\")\n        print(f\"Vendor: {vendor_info['vendor']}\")\n        print(f\"OUI: {vendor_info['oui']}\")\n        print(\"-\" * 40)\n\nif __name__ == \"__main__\":\n    device_inventory()\n</code></pre>"},{"location":"network/maclookup/#virtual-machine-detection","title":"Virtual Machine Detection","text":"<pre><code>from kn_sock.network import arp_scan, mac_lookup\n\ndef detect_virtual_machines():\n    \"\"\"Identify virtual machines on the network.\"\"\"\n    devices = arp_scan(\"192.168.1.0/24\")\n    vm_ouis = [\"00:50:56\", \"08:00:27\", \"52:54:00\", \"00:15:5D\", \"00:16:3E\"]\n\n    print(\"Virtual Machine Detection\")\n    print(\"=\" * 40)\n\n    for device in devices:\n        vendor_info = mac_lookup(device['mac'], use_api=False)\n        oui = vendor_info['oui']\n\n        if oui in vm_ouis:\n            print(f\"VM Detected: {device['ip']} ({vendor_info['vendor']})\")\n        else:\n            print(f\"Physical Device: {device['ip']} ({vendor_info['vendor']})\")\n\nif __name__ == \"__main__\":\n    detect_virtual_machines()\n</code></pre>"},{"location":"network/maclookup/#mac-address-validation-tool","title":"MAC Address Validation Tool","text":"<pre><code>from kn_sock.network.mac_lookup import validate_mac, mac_lookup\n\ndef validate_and_lookup():\n    \"\"\"Validate MAC addresses and lookup vendor information.\"\"\"\n    test_macs = [\n        \"00:1A:2B:3C:4D:5E\",\n        \"00-1A-2B-3C-4D-5E\",\n        \"001A2B3C4D5E\",\n        \"00:1A:2B:3C:4D\",  # Invalid\n        \"invalid-mac\"       # Invalid\n    ]\n\n    for mac in test_macs:\n        print(f\"MAC: {mac}\")\n\n        if validate_mac(mac):\n            try:\n                result = mac_lookup(mac, use_api=False)\n                print(f\"  Status: Valid\")\n                print(f\"  Vendor: {result['vendor']}\")\n                print(f\"  OUI: {result['oui']}\")\n            except Exception as e:\n                print(f\"  Status: Valid format, lookup failed: {e}\")\n        else:\n            print(f\"  Status: Invalid format\")\n\n        print(\"-\" * 30)\n\nif __name__ == \"__main__\":\n    validate_and_lookup()\n</code></pre>"},{"location":"network/maclookup/#batch-processing-with-error-handling","title":"Batch Processing with Error Handling","text":"<pre><code>from kn_sock.network.mac_lookup import batch_mac_lookup\n\ndef batch_lookup_with_errors():\n    \"\"\"Process multiple MAC addresses with error handling.\"\"\"\n    macs = [\n        \"00:1A:2B:3C:4D:5E\",  # Valid\n        \"08:00:27:12:34:56\",  # Valid\n        \"invalid-mac\",        # Invalid\n        \"52:54:00:AB:CD:EF\"   # Valid\n    ]\n\n    results = batch_mac_lookup(macs, use_api=False)\n\n    print(\"Batch MAC Lookup Results\")\n    print(\"=\" * 50)\n\n    for i, result in enumerate(results):\n        mac = macs[i]\n        print(f\"MAC: {mac}\")\n\n        if \"Error\" in result['vendor']:\n            print(f\"  Status: Error - {result['vendor']}\")\n        else:\n            print(f\"  Status: Success\")\n            print(f\"  Vendor: {result['vendor']}\")\n            print(f\"  OUI: {result['oui']}\")\n\n        print(\"-\" * 30)\n\nif __name__ == \"__main__\":\n    batch_lookup_with_errors()\n</code></pre>"},{"location":"network/monitor/","title":"DNS Monitoring","text":"<p>DNS monitoring allows you to capture and analyze DNS requests on your network, providing insights into network activity and device behavior.</p> <p>\u26a0\ufe0f ETHICAL WARNING: DNS monitoring is intended for use in authorized networks only. This tool should only be used in controlled IT environments, schools, or labs with proper authorization. Monitoring user traffic without consent may be illegal and unethical.</p>"},{"location":"network/monitor/#features","title":"Features","text":"<ul> <li>Real-time DNS Capture: Monitor DNS requests as they happen</li> <li>Detailed Query Information: Capture source IP, domain, and query type</li> <li>JSON Logging: Save captured data for analysis</li> <li>Statistical Analysis: Analyze DNS patterns and trends</li> <li>Asynchronous Monitoring: Run monitoring in background threads</li> <li>Interface Selection: Choose specific network interfaces to monitor</li> </ul>"},{"location":"network/monitor/#installation","title":"Installation","text":"<p>DNS monitoring requires the <code>scapy</code> library:</p> <pre><code>pip install scapy\n</code></pre> <p>Note: DNS monitoring requires root/administrator privileges for packet sniffing.</p> <p>For complete dependency information, see the API Reference.</p>"},{"location":"network/monitor/#basic-usage","title":"Basic Usage","text":""},{"location":"network/monitor/#python-api","title":"Python API","text":"<pre><code>from kn_sock.network import monitor_dns\n\n# Monitor DNS for 60 seconds\nresults = monitor_dns(duration=60)\nfor result in results:\n    print(f\"{result['source_ip']} -&gt; {result['domain']}\")\n</code></pre>"},{"location":"network/monitor/#command-line","title":"Command Line","text":"<pre><code># Basic monitoring (requires sudo)\nsudo knsock monitor\n\n# Monitor for 2 minutes with logging\nsudo knsock monitor --duration 120 --log dns_log.json\n\n# Verbose output\nsudo knsock monitor --duration 60 --verbose\n</code></pre> <p>For complete CLI documentation, see the API Reference.</p>"},{"location":"network/monitor/#advanced-usage","title":"Advanced Usage","text":""},{"location":"network/monitor/#logging-to-file","title":"Logging to File","text":"<pre><code>from kn_sock.network import monitor_dns\n\n# Save results to JSON file\nresults = monitor_dns(\n    duration=60, \n    log_file=\"dns_log.json\",\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#asynchronous-monitoring","title":"Asynchronous Monitoring","text":"<pre><code>from kn_sock.network.monitor import monitor_dns_async\nimport time\n\n# Start monitoring in background\nmonitor_thread = monitor_dns_async(\n    duration=120,\n    log_file=\"background_dns.json\"\n)\n\n# Do other work while monitoring\nprint(\"Monitoring started in background...\")\ntime.sleep(5)\n\n# Wait for monitoring to complete\nmonitor_thread.join()\nprint(\"Monitoring completed!\")\n</code></pre>"},{"location":"network/monitor/#custom-callback-function","title":"Custom Callback Function","text":"<pre><code>from kn_sock.network import monitor_dns\n\ndef dns_callback(result):\n    \"\"\"Process each DNS request in real-time.\"\"\"\n    print(f\"DNS Query: {result['source_ip']} -&gt; {result['domain']} ({result['query_type']})\")\n\n# Monitor with custom callback\nresults = monitor_dns(\n    duration=60,\n    callback=dns_callback,\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#interface-selection","title":"Interface Selection","text":"<pre><code>from kn_sock.network.monitor import get_network_interfaces, monitor_dns\n\n# Get available interfaces\ninterfaces = get_network_interfaces()\nfor iface in interfaces:\n    print(f\"Interface: {iface['name']}, IP: {iface['ip']}\")\n\n# Monitor specific interface\nresults = monitor_dns(\n    duration=60,\n    interface=\"eth0\",\n    verbose=True\n)\n</code></pre>"},{"location":"network/monitor/#log-analysis","title":"Log Analysis","text":""},{"location":"network/monitor/#basic-analysis","title":"Basic Analysis","text":"<pre><code>from kn_sock.network.monitor import analyze_dns_logs\n\n# Analyze captured DNS logs\nanalysis = analyze_dns_logs(\"dns_log.json\")\n\nprint(f\"Total requests: {analysis['total_requests']}\")\nprint(f\"Unique domains: {analysis['unique_domains']}\")\nprint(f\"Unique sources: {analysis['unique_sources']}\")\n\n# Top domains\nprint(\"\\nTop domains:\")\nfor domain, count in analysis['top_domains'][:5]:\n    print(f\"  {domain}: {count} requests\")\n</code></pre>"},{"location":"network/monitor/#advanced-analysis","title":"Advanced Analysis","text":"<pre><code>import json\nfrom kn_sock.network.monitor import analyze_dns_logs\n\ndef detailed_analysis(log_file):\n    \"\"\"Perform detailed DNS log analysis.\"\"\"\n    analysis = analyze_dns_logs(log_file)\n\n    print(\"DNS Analysis Report\")\n    print(\"=\" * 50)\n    print(f\"Analysis Time: {analysis['analysis_timestamp']}\")\n    print(f\"Total Requests: {analysis['total_requests']}\")\n    print(f\"Unique Domains: {analysis['unique_domains']}\")\n    print(f\"Unique Sources: {analysis['unique_sources']}\")\n\n    print(\"\\nTop 10 Domains:\")\n    for i, (domain, count) in enumerate(analysis['top_domains'][:10], 1):\n        print(f\"  {i:2d}. {domain:30s} {count:4d} requests\")\n\n    print(\"\\nTop 10 Sources:\")\n    for i, (source, count) in enumerate(analysis['top_sources'][:10], 1):\n        print(f\"  {i:2d}. {source:15s} {count:4d} requests\")\n\n    print(\"\\nQuery Type Distribution:\")\n    for qtype, count in analysis['query_type_distribution'].items():\n        print(f\"  {qtype:6s}: {count:4d} requests\")\n\nif __name__ == \"__main__\":\n    detailed_analysis(\"dns_log.json\")\n</code></pre>"},{"location":"network/monitor/#function-reference","title":"Function Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"network/monitor/#dns-query-types","title":"DNS Query Types","text":"Type Name Description 1 A IPv4 address 2 NS Name server 5 CNAME Canonical name 6 SOA Start of authority 12 PTR Pointer (reverse DNS) 15 MX Mail exchange 16 TXT Text record 28 AAAA IPv6 address 33 SRV Service record"},{"location":"network/monitor/#troubleshooting","title":"Troubleshooting","text":""},{"location":"network/monitor/#permission-issues","title":"Permission Issues","text":"<p>DNS monitoring requires root privileges for packet sniffing:</p> <pre><code># Linux/macOS\nsudo knsock monitor --duration 60\n\n# Or in Python\nsudo python -c \"from kn_sock.network import monitor_dns; monitor_dns(60)\"\n</code></pre>"},{"location":"network/monitor/#no-dns-requests-captured","title":"No DNS Requests Captured","text":"<ol> <li>Check Interface: Ensure you're monitoring the correct network interface</li> <li>Network Activity: Generate some DNS requests (browse web, ping hosts)</li> <li>Firewall: Some systems may block packet capture</li> <li>Virtual Environment: Ensure you're not in a restricted container</li> </ol>"},{"location":"network/monitor/#scapy-installation-issues","title":"Scapy Installation Issues","text":"<pre><code># Install scapy\npip install scapy\n\n# Or with system package manager\nsudo apt-get install python3-scapy  # Ubuntu/Debian\nsudo yum install python3-scapy      # CentOS/RHEL\n</code></pre>"},{"location":"network/monitor/#interface-detection","title":"Interface Detection","text":"<pre><code>from kn_sock.network.monitor import get_network_interfaces\n\ninterfaces = get_network_interfaces()\nprint(\"Available interfaces:\")\nfor iface in interfaces:\n    print(f\"  {iface['name']}: {iface['ip']}\")\n</code></pre>"},{"location":"network/monitor/#security-considerations","title":"Security Considerations","text":"<ol> <li>Authorization: Only monitor networks you own or have permission to monitor</li> <li>Legal Compliance: Ensure compliance with local privacy and surveillance laws</li> <li>Data Privacy: Be mindful of sensitive information in DNS queries</li> <li>Privilege Requirements: Requires elevated privileges for packet capture</li> <li>Network Impact: Minimal impact on network performance</li> </ol> <p>For complete security and legal information, see the API Reference.</p>"},{"location":"network/monitor/#examples","title":"Examples","text":""},{"location":"network/monitor/#real-time-dns-monitor","title":"Real-time DNS Monitor","text":"<pre><code>from kn_sock.network import monitor_dns\n\ndef real_time_monitor():\n    \"\"\"Monitor DNS requests in real-time with custom processing.\"\"\"\n    def process_dns(result):\n        # Filter for specific domains\n        if \"google.com\" in result['domain']:\n            print(f\"Google query from {result['source_ip']}: {result['domain']}\")\n\n        # Alert on suspicious domains\n        suspicious = [\"malware.com\", \"phishing.net\"]\n        if any(sus in result['domain'] for sus in suspicious):\n            print(f\"ALERT: Suspicious domain {result['domain']} from {result['source_ip']}\")\n\n    print(\"Starting real-time DNS monitoring...\")\n    print(\"Press Ctrl+C to stop\")\n\n    try:\n        results = monitor_dns(\n            duration=300,  # 5 minutes\n            callback=process_dns,\n            verbose=True\n        )\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped by user\")\n\nif __name__ == \"__main__\":\n    real_time_monitor()\n</code></pre>"},{"location":"network/monitor/#network-activity-dashboard","title":"Network Activity Dashboard","text":"<pre><code>import time\nfrom kn_sock.network import monitor_dns, analyze_dns_logs\n\ndef activity_dashboard():\n    \"\"\"Create a simple network activity dashboard.\"\"\"\n    log_file = \"activity_log.json\"\n\n    print(\"Network Activity Dashboard\")\n    print(\"=\" * 40)\n\n    # Monitor for 2 minutes\n    print(\"Monitoring network activity for 2 minutes...\")\n    results = monitor_dns(duration=120, log_file=log_file)\n\n    # Analyze results\n    analysis = analyze_dns_logs(log_file)\n\n    print(f\"\\nActivity Summary:\")\n    print(f\"Total DNS requests: {analysis['total_requests']}\")\n    print(f\"Active devices: {analysis['unique_sources']}\")\n    print(f\"Unique domains: {analysis['unique_domains']}\")\n\n    print(f\"\\nMost active domains:\")\n    for domain, count in analysis['top_domains'][:5]:\n        print(f\"  {domain}: {count} requests\")\n\n    print(f\"\\nMost active devices:\")\n    for source, count in analysis['top_sources'][:5]:\n        print(f\"  {source}: {count} requests\")\n\nif __name__ == \"__main__\":\n    activity_dashboard()\n</code></pre>"},{"location":"network/monitor/#continuous-monitoring-with-alerts","title":"Continuous Monitoring with Alerts","text":"<pre><code>import time\nimport json\nfrom datetime import datetime\nfrom kn_sock.network import monitor_dns\n\ndef continuous_monitor():\n    \"\"\"Continuous DNS monitoring with alerting.\"\"\"\n    alert_domains = [\"malware.com\", \"phishing.net\", \"suspicious.org\"]\n    log_file = f\"monitor_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\"\n\n    def alert_callback(result):\n        domain = result['domain']\n        source = result['source_ip']\n\n        # Check for alert domains\n        for alert_domain in alert_domains:\n            if alert_domain in domain:\n                alert_msg = f\"ALERT: {source} accessed {domain} at {result['timestamp']}\"\n                print(f\"\ud83d\udea8 {alert_msg}\")\n\n                # Log alert to file\n                with open(\"alerts.log\", \"a\") as f:\n                    f.write(f\"{alert_msg}\\n\")\n\n    print(\"Starting continuous DNS monitoring...\")\n    print(\"Alert domains:\", alert_domains)\n    print(\"Press Ctrl+C to stop\")\n\n    try:\n        while True:\n            print(f\"\\nMonitoring cycle started at {datetime.now()}\")\n            results = monitor_dns(\n                duration=60,  # 1 minute cycles\n                log_file=log_file,\n                callback=alert_callback,\n                verbose=False\n            )\n\n            print(f\"Captured {len(results)} DNS requests\")\n            time.sleep(5)  # Brief pause between cycles\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped\")\n\nif __name__ == \"__main__\":\n    continuous_monitor()\n</code></pre>"},{"location":"network/monitor/#dns-query-type-analysis","title":"DNS Query Type Analysis","text":"<pre><code>from kn_sock.network import monitor_dns, analyze_dns_logs\n\ndef query_type_analysis():\n    \"\"\"Analyze DNS query types and patterns.\"\"\"\n    print(\"DNS Query Type Analysis\")\n    print(\"=\" * 30)\n\n    # Monitor for 3 minutes\n    results = monitor_dns(duration=180, log_file=\"query_analysis.json\")\n\n    # Analyze results\n    analysis = analyze_dns_logs(\"query_analysis.json\")\n\n    print(f\"Total queries: {analysis['total_requests']}\")\n    print(f\"Query type distribution:\")\n\n    for qtype, count in analysis['query_type_distribution'].items():\n        percentage = (count / analysis['total_requests']) * 100\n        print(f\"  {qtype:6s}: {count:4d} ({percentage:5.1f}%)\")\n\n    # Analyze by time patterns\n    print(f\"\\nTop domains by query type:\")\n    for domain, count in analysis['top_domains'][:10]:\n        print(f\"  {domain}: {count} queries\")\n\nif __name__ == \"__main__\":\n    query_type_analysis()\n</code></pre>"},{"location":"protocols/file-transfer/","title":"File Transfer","text":"<p>kn-sock provides robust file transfer capabilities over TCP, supporting both synchronous and asynchronous operations with progress tracking.</p>"},{"location":"protocols/file-transfer/#overview","title":"Overview","text":"<p>File transfer features in kn-sock: - Reliable file transmission over TCP - Progress tracking with visual progress bars - Support for large files - Both synchronous and asynchronous operations - Automatic file metadata handling - Error handling and recovery</p>"},{"location":"protocols/file-transfer/#basic-file-transfer","title":"Basic File Transfer","text":""},{"location":"protocols/file-transfer/#file-server","title":"File Server","text":"<pre><code>from kn_sock import start_file_server\n\n# Start a file server that saves received files to /path/to/save/directory\nstart_file_server(8080, \"/path/to/save/directory\")\n</code></pre>"},{"location":"protocols/file-transfer/#file-client","title":"File Client","text":"<pre><code>from kn_sock import send_file\n\n# Send a file to the server\nsend_file(\"localhost\", 8080, \"path/to/your/file.txt\")\n</code></pre>"},{"location":"protocols/file-transfer/#file-server-with-custom-handler","title":"File Server with Custom Handler","text":"<pre><code>from kn_sock import start_file_server\n\ndef file_received_handler(filename, filepath, addr):\n    \"\"\"Called when a file is successfully received\"\"\"\n    print(f\"File '{filename}' received from {addr} and saved to {filepath}\")\n\nstart_file_server(8080, \"/path/to/save/directory\", handler=file_received_handler)\n</code></pre>"},{"location":"protocols/file-transfer/#asynchronous-file-transfer","title":"Asynchronous File Transfer","text":""},{"location":"protocols/file-transfer/#async-file-server","title":"Async File Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_file_server_async\n\nasync def main():\n    await start_file_server_async(8080, \"/path/to/save/directory\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/file-transfer/#async-file-client","title":"Async File Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_file_async\n\nasync def main():\n    await send_file_async(\"localhost\", 8080, \"path/to/your/file.txt\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/file-transfer/#progress-tracking","title":"Progress Tracking","text":"<p>All file transfer functions support progress bars using tqdm:</p>"},{"location":"protocols/file-transfer/#enable-progress-bar","title":"Enable Progress Bar","text":"<pre><code>from kn_sock import send_file\n\n# Show progress bar (default if tqdm is installed)\nsend_file('localhost', 8080, 'file.txt', show_progress=True)\n</code></pre>"},{"location":"protocols/file-transfer/#disable-progress-bar","title":"Disable Progress Bar","text":"<pre><code>from kn_sock import send_file\n\n# Disable progress bar\nsend_file('localhost', 8080, 'file.txt', show_progress=False)\n</code></pre>"},{"location":"protocols/file-transfer/#custom-progress-callback","title":"Custom Progress Callback","text":"<pre><code>from kn_sock import send_file\n\ndef progress_callback(bytes_sent, total_bytes, filename):\n    percentage = (bytes_sent / total_bytes) * 100\n    print(f\"Sending {filename}: {percentage:.1f}% complete\")\n\nsend_file('localhost', 8080, 'file.txt', progress_callback=progress_callback)\n</code></pre>"},{"location":"protocols/file-transfer/#advanced-file-transfer","title":"Advanced File Transfer","text":""},{"location":"protocols/file-transfer/#multiple-file-transfer","title":"Multiple File Transfer","text":"<pre><code>import os\nfrom kn_sock import send_file\n\ndef send_directory(host, port, directory_path):\n    \"\"\"Send all files in a directory\"\"\"\n    for filename in os.listdir(directory_path):\n        filepath = os.path.join(directory_path, filename)\n        if os.path.isfile(filepath):\n            print(f\"Sending {filename}...\")\n            send_file(host, port, filepath)\n\n# Send all files in a directory\nsend_directory(\"localhost\", 8080, \"/path/to/directory\")\n</code></pre>"},{"location":"protocols/file-transfer/#selective-file-transfer","title":"Selective File Transfer","text":"<pre><code>import os\nfrom kn_sock import send_file\n\ndef send_files_by_extension(host, port, directory_path, extensions):\n    \"\"\"Send files with specific extensions\"\"\"\n    for filename in os.listdir(directory_path):\n        if any(filename.endswith(ext) for ext in extensions):\n            filepath = os.path.join(directory_path, filename)\n            if os.path.isfile(filepath):\n                print(f\"Sending {filename}...\")\n                send_file(host, port, filepath)\n\n# Send only image files\nsend_files_by_extension(\"localhost\", 8080, \"/path/to/directory\", ['.jpg', '.png', '.gif'])\n</code></pre>"},{"location":"protocols/file-transfer/#file-transfer-with-metadata","title":"File Transfer with Metadata","text":"<pre><code>import os\nimport json\nfrom kn_sock import send_json, send_file\n\ndef send_file_with_metadata(host, port, filepath):\n    \"\"\"Send file metadata first, then the file\"\"\"\n    filename = os.path.basename(filepath)\n    file_size = os.path.getsize(filepath)\n    file_modified = os.path.getmtime(filepath)\n\n    # Send metadata\n    metadata = {\n        \"filename\": filename,\n        \"size\": file_size,\n        \"modified\": file_modified,\n        \"type\": \"file_transfer\"\n    }\n    send_json(host, port, metadata)\n\n    # Send the actual file\n    send_file(host, port, filepath)\n\nsend_file_with_metadata(\"localhost\", 8080, \"document.pdf\")\n</code></pre>"},{"location":"protocols/file-transfer/#error-handling","title":"Error Handling","text":""},{"location":"protocols/file-transfer/#file-transfer-errors","title":"File Transfer Errors","text":"<pre><code>from kn_sock.errors import FileTransferError, ConnectionTimeoutError\n\ntry:\n    send_file(\"localhost\", 8080, \"large_file.zip\")\nexcept FileTransferError as e:\n    print(f\"File transfer failed: {e}\")\nexcept ConnectionTimeoutError:\n    print(\"Connection timed out during file transfer\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"protocols/file-transfer/#server-side-error-handling","title":"Server-side Error Handling","text":"<pre><code>from kn_sock import start_file_server\nimport os\n\ndef handle_file_error(error, addr):\n    \"\"\"Handle file transfer errors\"\"\"\n    print(f\"Error receiving file from {addr}: {error}\")\n\ndef validate_file(filename, filepath):\n    \"\"\"Validate received files\"\"\"\n    # Check file size\n    if os.path.getsize(filepath) &gt; 100 * 1024 * 1024:  # 100MB limit\n        raise ValueError(\"File too large\")\n\n    # Check file extension\n    allowed_extensions = ['.txt', '.pdf', '.jpg', '.png']\n    if not any(filename.endswith(ext) for ext in allowed_extensions):\n        raise ValueError(\"File type not allowed\")\n\nstart_file_server(\n    8080, \n    \"/path/to/save/directory\",\n    error_handler=handle_file_error,\n    validator=validate_file\n)\n</code></pre>"},{"location":"protocols/file-transfer/#performance-optimization","title":"Performance Optimization","text":""},{"location":"protocols/file-transfer/#chunked-transfer","title":"Chunked Transfer","text":"<p>For very large files, consider chunked transfer:</p> <pre><code>from kn_sock.utils import chunked_file_reader\nfrom kn_sock import send_tcp_bytes\n\ndef send_large_file_chunked(host, port, filepath, chunk_size=1024*1024):\n    \"\"\"Send large file in chunks\"\"\"\n    filename = os.path.basename(filepath)\n\n    # Send file info\n    file_info = {\n        \"filename\": filename,\n        \"size\": os.path.getsize(filepath),\n        \"chunk_size\": chunk_size\n    }\n    send_json(host, port, file_info)\n\n    # Send file in chunks\n    for chunk in chunked_file_reader(filepath, chunk_size):\n        send_tcp_bytes(host, port, chunk)\n</code></pre>"},{"location":"protocols/file-transfer/#compression","title":"Compression","text":"<p>For bandwidth optimization, use compression:</p> <pre><code>from kn_sock.compression import compress_data\nimport gzip\n\ndef send_compressed_file(host, port, filepath):\n    \"\"\"Send compressed file\"\"\"\n    with open(filepath, 'rb') as f:\n        data = f.read()\n\n    compressed_data = gzip.compress(data)\n    send_tcp_bytes(host, port, compressed_data)\n</code></pre>"},{"location":"protocols/file-transfer/#use-cases","title":"Use Cases","text":""},{"location":"protocols/file-transfer/#backup-system","title":"Backup System","text":"<pre><code>import schedule\nimport time\nfrom kn_sock import send_file\n\ndef backup_files():\n    \"\"\"Daily backup of important files\"\"\"\n    files_to_backup = [\n        \"/path/to/database.sql\",\n        \"/path/to/config.json\",\n        \"/path/to/logs/\"\n    ]\n\n    for filepath in files_to_backup:\n        try:\n            send_file(\"backup-server\", 8080, filepath)\n            print(f\"Backed up {filepath}\")\n        except Exception as e:\n            print(f\"Failed to backup {filepath}: {e}\")\n\n# Schedule daily backup at 2 AM\nschedule.every().day.at(\"02:00\").do(backup_files)\n\nwhile True:\n    schedule.run_pending()\n    time.sleep(60)\n</code></pre>"},{"location":"protocols/file-transfer/#log-file-transfer","title":"Log File Transfer","text":"<pre><code>import os\nfrom datetime import datetime\nfrom kn_sock import send_file\n\ndef transfer_logs():\n    \"\"\"Transfer log files older than 1 day\"\"\"\n    log_directory = \"/var/log/myapp\"\n    cutoff_time = datetime.now().timestamp() - 86400  # 24 hours ago\n\n    for filename in os.listdir(log_directory):\n        filepath = os.path.join(log_directory, filename)\n        if os.path.isfile(filepath) and os.path.getmtime(filepath) &lt; cutoff_time:\n            try:\n                send_file(\"log-server\", 8080, filepath)\n                print(f\"Transferred log file: {filename}\")\n            except Exception as e:\n                print(f\"Failed to transfer {filename}: {e}\")\n</code></pre>"},{"location":"protocols/file-transfer/#media-file-distribution","title":"Media File Distribution","text":"<pre><code>import os\nfrom kn_sock import send_file\n\ndef distribute_media_files(host, port, media_directory):\n    \"\"\"Distribute media files to multiple servers\"\"\"\n    media_extensions = ['.mp4', '.avi', '.mkv', '.mp3', '.wav']\n\n    for filename in os.listdir(media_directory):\n        if any(filename.endswith(ext) for ext in media_extensions):\n            filepath = os.path.join(media_directory, filename)\n            if os.path.isfile(filepath):\n                print(f\"Distributing {filename}...\")\n                send_file(host, port, filepath, show_progress=True)\n\n# Distribute to multiple servers\nservers = [\n    (\"server1\", 8080),\n    (\"server2\", 8080),\n    (\"server3\", 8080)\n]\n\nfor host, port in servers:\n    distribute_media_files(host, port, \"/path/to/media\")\n</code></pre>"},{"location":"protocols/file-transfer/#cli-usage","title":"CLI Usage","text":"<pre><code># Start a file server\nkn-sock run-file-server 8080 /path/to/save/directory\n\n# Send a file\nkn-sock send-file localhost 8080 path/to/your/file.txt\n\n# Send file with progress\nkn-sock send-file localhost 8080 large_file.zip --show-progress\n</code></pre>"},{"location":"protocols/file-transfer/#best-practices","title":"Best Practices","text":"<ol> <li>Use progress tracking: Enable progress bars for large files</li> <li>Handle errors gracefully: Implement proper error handling</li> <li>Validate files: Check file size and type on the server side</li> <li>Use compression: For large files or slow connections</li> <li>Implement retry logic: For unreliable network connections</li> <li>Monitor disk space: Ensure sufficient space on the receiving server</li> <li>Use appropriate chunk sizes: Balance memory usage and performance</li> </ol>"},{"location":"protocols/file-transfer/#configuration-options","title":"Configuration Options","text":"Parameter Description Default <code>show_progress</code> Show progress bar True (if tqdm installed) <code>progress_callback</code> Custom progress function None <code>chunk_size</code> Bytes per chunk 4096 <code>timeout</code> Transfer timeout 30 seconds"},{"location":"protocols/file-transfer/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable file transfer</li> <li>JSON Communication - For file metadata exchange</li> <li>Compression - For optimizing transfer size</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/json/","title":"JSON Communication","text":"<p>kn-sock provides built-in support for JSON communication, making it easy to send and receive structured data over sockets.</p>"},{"location":"protocols/json/#overview","title":"Overview","text":"<p>JSON communication in kn-sock: - Automatically serializes Python objects to JSON - Handles encoding/decoding transparently - Supports both synchronous and asynchronous operations - Provides error handling for invalid JSON - Works over both TCP and UDP</p>"},{"location":"protocols/json/#basic-json-communication","title":"Basic JSON Communication","text":""},{"location":"protocols/json/#json-server","title":"JSON Server","text":"<pre><code>from kn_sock import start_json_server\n\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n\n    # Process the JSON data\n    message_type = data.get('type')\n    payload = data.get('payload')\n\n    # Send a JSON response\n    response = {\n        \"status\": \"received\",\n        \"message_type\": message_type,\n        \"timestamp\": time.time()\n    }\n    client_socket.sendall(json.dumps(response).encode('utf-8'))\n\nstart_json_server(8080, handle_json_message)\n</code></pre>"},{"location":"protocols/json/#json-client","title":"JSON Client","text":"<pre><code>from kn_sock import send_json\n\n# Send a simple JSON object\nmessage = {\"message\": \"Hello, World!\"}\nsend_json(\"localhost\", 8080, message)\n\n# Send a complex JSON object\ndata = {\n    \"type\": \"user_data\",\n    \"payload\": {\n        \"user_id\": 123,\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    },\n    \"timestamp\": time.time()\n}\nsend_json(\"localhost\", 8080, data)\n</code></pre>"},{"location":"protocols/json/#asynchronous-json-communication","title":"Asynchronous JSON Communication","text":""},{"location":"protocols/json/#async-json-server","title":"Async JSON Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_json_server_async\n\nasync def handle_json_message(data, addr, writer):\n    \"\"\"\n    Handle incoming JSON messages asynchronously.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n\n    response = {\"status\": \"received\", \"data\": data}\n    writer.write(json.dumps(response).encode('utf-8'))\n    await writer.drain()\n\nasyncio.run(start_json_server_async(8080, handle_json_message))\n</code></pre>"},{"location":"protocols/json/#async-json-client","title":"Async JSON Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_json_async\n\nasync def main():\n    data = {\"message\": \"Hello, async JSON!\"}\n    await send_json_async(\"localhost\", 8080, data)\n\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/json/#json-response-helpers","title":"JSON Response Helpers","text":"<p>kn-sock provides helper functions for sending JSON responses:</p>"},{"location":"protocols/json/#synchronous-response","title":"Synchronous Response","text":"<pre><code>from kn_sock import send_json_response\n\ndef handle_message(data, addr, client_socket):\n    # Process the message...\n\n    # Send a JSON response\n    response_data = {\n        \"status\": \"success\",\n        \"result\": \"processed\",\n        \"timestamp\": time.time()\n    }\n    send_json_response(client_socket, response_data)\n</code></pre>"},{"location":"protocols/json/#asynchronous-response","title":"Asynchronous Response","text":"<pre><code>from kn_sock import send_json_response_async\n\nasync def handle_message(data, addr, writer):\n    # Process the message...\n\n    # Send a JSON response\n    response_data = {\n        \"status\": \"success\",\n        \"result\": \"processed\",\n        \"timestamp\": time.time()\n    }\n    await send_json_response_async(writer, response_data)\n</code></pre>"},{"location":"protocols/json/#error-handling","title":"Error Handling","text":""},{"location":"protocols/json/#invalid-json-handling","title":"Invalid JSON Handling","text":"<pre><code>from kn_sock.errors import InvalidJSONError\n\ndef handle_json_message(data, addr, client_socket):\n    try:\n        # Process JSON data\n        message_type = data.get('type')\n        # ... rest of processing\n    except InvalidJSONError as e:\n        error_response = {\n            \"error\": \"invalid_json\",\n            \"message\": str(e)\n        }\n        send_json_response(client_socket, error_response)\n</code></pre>"},{"location":"protocols/json/#timeout-handling","title":"Timeout Handling","text":"<pre><code>from kn_sock.errors import ConnectionTimeoutError\n\ntry:\n    response = send_json(\"localhost\", 8080, data, timeout=5)\nexcept ConnectionTimeoutError:\n    print(\"Request timed out\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"protocols/json/#use-cases","title":"Use Cases","text":""},{"location":"protocols/json/#api-like-communication","title":"API-like Communication","text":"<pre><code># Server\ndef handle_api_request(data, addr, client_socket):\n    endpoint = data.get('endpoint')\n    params = data.get('params', {})\n\n    if endpoint == 'get_user':\n        user_id = params.get('user_id')\n        user = get_user_by_id(user_id)  # Your function\n        response = {\"status\": \"success\", \"data\": user}\n    elif endpoint == 'create_user':\n        user_data = params.get('user_data')\n        new_user = create_user(user_data)  # Your function\n        response = {\"status\": \"success\", \"data\": new_user}\n    else:\n        response = {\"status\": \"error\", \"message\": \"Unknown endpoint\"}\n\n    send_json_response(client_socket, response)\n\n# Client\ndef get_user(user_id):\n    request = {\n        \"endpoint\": \"get_user\",\n        \"params\": {\"user_id\": user_id}\n    }\n    send_json(\"localhost\", 8080, request)\n</code></pre>"},{"location":"protocols/json/#configuration-exchange","title":"Configuration Exchange","text":"<pre><code># Server\ndef handle_config_request(data, addr, client_socket):\n    config_type = data.get('config_type')\n\n    configs = {\n        'database': {\n            'host': 'localhost',\n            'port': 5432,\n            'name': 'myapp'\n        },\n        'redis': {\n            'host': 'localhost',\n            'port': 6379\n        }\n    }\n\n    config = configs.get(config_type, {})\n    response = {\"config\": config}\n    send_json_response(client_socket, response)\n\n# Client\ndef get_config(config_type):\n    request = {\"config_type\": config_type}\n    send_json(\"localhost\", 8080, request)\n</code></pre>"},{"location":"protocols/json/#event-broadcasting","title":"Event Broadcasting","text":"<pre><code># Server\ndef handle_event(data, addr, client_socket):\n    event_type = data.get('event_type')\n    event_data = data.get('event_data')\n\n    # Broadcast to all connected clients\n    broadcast_event = {\n        \"type\": \"broadcast\",\n        \"event_type\": event_type,\n        \"event_data\": event_data,\n        \"timestamp\": time.time()\n    }\n\n    # Send to all clients (implementation depends on your client tracking)\n    for client in connected_clients:\n        send_json_response(client, broadcast_event)\n\n# Client\ndef send_event(event_type, event_data):\n    event = {\n        \"event_type\": event_type,\n        \"event_data\": event_data\n    }\n    send_json(\"localhost\", 8080, event)\n</code></pre>"},{"location":"protocols/json/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"protocols/json/#request-response-with-correlation","title":"Request-Response with Correlation","text":"<pre><code>import uuid\n\n# Client\ndef send_request_with_correlation(endpoint, params):\n    correlation_id = str(uuid.uuid4())\n    request = {\n        \"correlation_id\": correlation_id,\n        \"endpoint\": endpoint,\n        \"params\": params,\n        \"timestamp\": time.time()\n    }\n    send_json(\"localhost\", 8080, request)\n    return correlation_id\n\n# Server\ndef handle_correlated_request(data, addr, client_socket):\n    correlation_id = data.get('correlation_id')\n    endpoint = data.get('endpoint')\n    params = data.get('params')\n\n    # Process request...\n    result = process_request(endpoint, params)\n\n    response = {\n        \"correlation_id\": correlation_id,\n        \"status\": \"success\",\n        \"result\": result,\n        \"timestamp\": time.time()\n    }\n    send_json_response(client_socket, response)\n</code></pre>"},{"location":"protocols/json/#batch-operations","title":"Batch Operations","text":"<pre><code># Client\ndef send_batch_operations(operations):\n    batch = {\n        \"type\": \"batch\",\n        \"operations\": operations,\n        \"batch_id\": str(uuid.uuid4())\n    }\n    send_json(\"localhost\", 8080, batch)\n\n# Server\ndef handle_batch_operations(data, addr, client_socket):\n    operations = data.get('operations', [])\n    batch_id = data.get('batch_id')\n\n    results = []\n    for op in operations:\n        result = process_operation(op)\n        results.append(result)\n\n    response = {\n        \"type\": \"batch_response\",\n        \"batch_id\": batch_id,\n        \"results\": results\n    }\n    send_json_response(client_socket, response)\n</code></pre>"},{"location":"protocols/json/#validation-and-decorators","title":"Validation and Decorators","text":"<p>kn-sock provides decorators for JSON validation:</p> <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, client_socket):\n    # data is guaranteed to be a valid JSON object (dict)\n    message_type = data.get('type')\n    # ... rest of processing\n</code></pre>"},{"location":"protocols/json/#performance-considerations","title":"Performance Considerations","text":""},{"location":"protocols/json/#large-json-objects","title":"Large JSON Objects","text":"<p>For large JSON objects, consider compression:</p> <pre><code>from kn_sock.compression import compress_data, decompress_data\n\n# Client\ndef send_large_json(data):\n    json_str = json.dumps(data)\n    compressed = compress_data(json_str.encode('utf-8'))\n    send_tcp_bytes(\"localhost\", 8080, compressed)\n\n# Server\ndef handle_compressed_json(data, addr, client_socket):\n    decompressed = decompress_data(data)\n    json_data = json.loads(decompressed.decode('utf-8'))\n    # Process json_data...\n</code></pre>"},{"location":"protocols/json/#streaming-json","title":"Streaming JSON","text":"<p>For very large datasets, consider streaming:</p> <pre><code>def send_json_stream(host, port, data_generator):\n    for chunk in data_generator:\n        json_chunk = json.dumps(chunk)\n        send_tcp_message(host, port, json_chunk)\n</code></pre>"},{"location":"protocols/json/#cli-usage","title":"CLI Usage","text":"<pre><code># Send JSON data via CLI\nkn-sock send-json localhost 8080 '{\"message\": \"Hello\", \"type\": \"greeting\"}'\n</code></pre>"},{"location":"protocols/json/#best-practices","title":"Best Practices","text":"<ol> <li>Use consistent message structure: Define a standard format for your JSON messages</li> <li>Include timestamps: Add timestamps for debugging and logging</li> <li>Handle errors gracefully: Always provide meaningful error responses</li> <li>Validate input: Use decorators or manual validation for critical data</li> <li>Use correlation IDs: For request-response patterns, include correlation IDs</li> <li>Consider compression: For large JSON objects, use compression</li> <li>Document your API: Clearly document the expected JSON structure</li> </ol>"},{"location":"protocols/json/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable JSON communication</li> <li>UDP Protocol - For fast JSON messaging</li> <li>File Transfer - For large data transfer</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/secure-tcp/","title":"Secure TCP (SSL/TLS)","text":"<p>kn-sock provides comprehensive SSL/TLS support for secure, encrypted communication over TCP connections.</p>"},{"location":"protocols/secure-tcp/#overview","title":"Overview","text":"<p>Secure TCP features in kn-sock: - Full SSL/TLS encryption support - Both synchronous and asynchronous operations - Client and server certificate validation - Mutual TLS (mTLS) support - Configurable security parameters - Integration with connection pooling</p>"},{"location":"protocols/secure-tcp/#basic-ssltls-setup","title":"Basic SSL/TLS Setup","text":""},{"location":"protocols/secure-tcp/#synchronous-secure-tcp-server","title":"Synchronous Secure TCP Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#synchronous-secure-tcp-client","title":"Synchronous Secure TCP Client","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\"\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#asynchronous-ssltls","title":"Asynchronous SSL/TLS","text":""},{"location":"protocols/secure-tcp/#async-secure-tcp-server","title":"Async Secure TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_ssl_tcp_server\n\nasync def handle_secure(data, addr, writer):\n    print(f\"Received from {addr}: {data.decode()}\")\n    writer.write(b\"Secure response\")\n    await writer.drain()\n\nasyncio.run(start_async_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n))\n</code></pre>"},{"location":"protocols/secure-tcp/#async-secure-tcp-client","title":"Async Secure TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_ssl_tcp_message_async\n\nasyncio.run(send_ssl_tcp_message_async(\n    \"localhost\", 8443, \"Hello Secure\"\n))\n</code></pre>"},{"location":"protocols/secure-tcp/#certificate-management","title":"Certificate Management","text":""},{"location":"protocols/secure-tcp/#generating-self-signed-certificates","title":"Generating Self-Signed Certificates","text":"<p>For testing and development:</p> <pre><code># Generate private key\nopenssl genrsa -out server.key 2048\n\n# Generate certificate signing request\nopenssl req -new -key server.key -out server.csr\n\n# Generate self-signed certificate\nopenssl x509 -req -in server.csr -signkey server.key -out server.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#generating-ca-signed-certificates","title":"Generating CA-Signed Certificates","text":"<p>For production use:</p> <pre><code># Generate CA private key\nopenssl genrsa -out ca.key 2048\n\n# Generate CA certificate\nopenssl req -new -x509 -key ca.key -out ca.crt -days 3650\n\n# Generate server private key\nopenssl genrsa -out server.key 2048\n\n# Generate server certificate signing request\nopenssl req -new -key server.key -out server.csr\n\n# Sign server certificate with CA\nopenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -out server.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#client-certificates-mtls","title":"Client Certificates (mTLS)","text":"<p>For mutual TLS authentication:</p> <pre><code># Generate client private key\nopenssl genrsa -out client.key 2048\n\n# Generate client certificate signing request\nopenssl req -new -key client.key -out client.csr\n\n# Sign client certificate with CA\nopenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -out client.crt -days 365\n</code></pre>"},{"location":"protocols/secure-tcp/#advanced-ssltls-configuration","title":"Advanced SSL/TLS Configuration","text":""},{"location":"protocols/secure-tcp/#server-with-ca-verification","title":"Server with CA Verification","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # CA certificate for client verification\n    require_client_cert=True  # Require client certificates\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#client-with-certificate-authentication","title":"Client with Certificate Authentication","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\",\n    cafile=\"ca.crt\",  # CA certificate for server verification\n    certfile=\"client.crt\",  # Client certificate\n    keyfile=\"client.key\",  # Client private key\n    verify=True  # Verify server certificate\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#custom-ssl-context","title":"Custom SSL Context","text":"<pre><code>import ssl\nfrom kn_sock import start_ssl_tcp_server\n\ndef create_ssl_context():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile=\"server.crt\", keyfile=\"server.key\")\n    context.load_verify_locations(cafile=\"ca.crt\")\n    context.verify_mode = ssl.CERT_REQUIRED\n    context.check_hostname = False\n    return context\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    ssl_context=create_ssl_context()\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#security-best-practices","title":"Security Best Practices","text":""},{"location":"protocols/secure-tcp/#certificate-validation","title":"Certificate Validation","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\n# Always verify server certificates in production\nsend_ssl_tcp_message(\n    \"example.com\", 443, \"Hello\",\n    cafile=\"trusted_ca.crt\",\n    verify=True\n)\n\n# For testing only - disable verification\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello\",\n    verify=False  # Only for development/testing\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#strong-cipher-suites","title":"Strong Cipher Suites","text":"<pre><code>import ssl\nfrom kn_sock import start_ssl_tcp_server\n\ndef create_secure_context():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile=\"server.crt\", keyfile=\"server.key\")\n\n    # Set strong cipher suites\n    context.set_ciphers('ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256')\n\n    # Set minimum TLS version\n    context.minimum_version = ssl.TLSVersion.TLSv1_2\n\n    return context\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    ssl_context=create_secure_context()\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#certificate-revocation","title":"Certificate Revocation","text":"<pre><code>import ssl\nfrom kn_sock import start_ssl_tcp_server\n\ndef create_context_with_crl():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile=\"server.crt\", keyfile=\"server.key\")\n    context.load_verify_locations(cafile=\"ca.crt\", capath=None, cadata=None)\n\n    # Load certificate revocation list\n    context.load_verify_locations(cafile=\"ca.crt\")\n    context.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF\n\n    return context\n</code></pre>"},{"location":"protocols/secure-tcp/#error-handling","title":"Error Handling","text":""},{"location":"protocols/secure-tcp/#ssltls-errors","title":"SSL/TLS Errors","text":"<pre><code>from kn_sock.errors import EasySocketError\nimport ssl\n\ntry:\n    send_ssl_tcp_message(\"localhost\", 8443, \"Hello\")\nexcept ssl.SSLError as e:\n    print(f\"SSL error: {e}\")\nexcept EasySocketError as e:\n    print(f\"Socket error: {e}\")\n</code></pre>"},{"location":"protocols/secure-tcp/#certificate-validation-errors","title":"Certificate Validation Errors","text":"<pre><code>import ssl\n\ntry:\n    send_ssl_tcp_message(\n        \"localhost\", 8443, \"Hello\",\n        cafile=\"ca.crt\",\n        verify=True\n    )\nexcept ssl.SSLCertVerificationError as e:\n    print(f\"Certificate verification failed: {e}\")\nexcept ssl.SSLError as e:\n    print(f\"SSL error: {e}\")\n</code></pre>"},{"location":"protocols/secure-tcp/#connection-pooling-with-ssl","title":"Connection Pooling with SSL","text":""},{"location":"protocols/secure-tcp/#secure-connection-pool","title":"Secure Connection Pool","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool(\n    'localhost', 8443, max_size=5, idle_timeout=30,\n    ssl=True, \n    cafile=\"ca.crt\", \n    certfile=\"client.crt\", \n    keyfile=\"client.key\", \n    verify=True\n)\n\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello Secure\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()\n</code></pre>"},{"location":"protocols/secure-tcp/#use-cases","title":"Use Cases","text":""},{"location":"protocols/secure-tcp/#secure-api-server","title":"Secure API Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\nimport json\n\ndef handle_api_request(data, addr, client_socket):\n    try:\n        request = json.loads(data.decode())\n        endpoint = request.get('endpoint')\n\n        if endpoint == 'get_data':\n            response = {\"status\": \"success\", \"data\": \"sensitive_data\"}\n        else:\n            response = {\"status\": \"error\", \"message\": \"Unknown endpoint\"}\n\n        client_socket.sendall(json.dumps(response).encode())\n    except json.JSONDecodeError:\n        error_response = {\"status\": \"error\", \"message\": \"Invalid JSON\"}\n        client_socket.sendall(json.dumps(error_response).encode())\n\nstart_ssl_tcp_server(\n    8443,\n    handle_api_request,\n    certfile=\"api_server.crt\",\n    keyfile=\"api_server.key\",\n    cafile=\"ca.crt\",\n    require_client_cert=True\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#secure-file-transfer","title":"Secure File Transfer","text":"<pre><code>from kn_sock import start_ssl_tcp_server, send_ssl_tcp_message\n\ndef handle_secure_file_transfer(data, addr, client_socket):\n    # Handle secure file transfer\n    filename = data.decode().strip()\n\n    try:\n        with open(filename, 'rb') as f:\n            file_data = f.read()\n\n        # Send file size first\n        size_msg = f\"SIZE:{len(file_data)}\".encode()\n        client_socket.sendall(size_msg)\n\n        # Send file data\n        client_socket.sendall(file_data)\n\n    except FileNotFoundError:\n        error_msg = \"ERROR:File not found\".encode()\n        client_socket.sendall(error_msg)\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure_file_transfer,\n    certfile=\"file_server.crt\",\n    keyfile=\"file_server.key\"\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#database-connection-proxy","title":"Database Connection Proxy","text":"<pre><code>from kn_sock import start_ssl_tcp_server\nimport psycopg2\n\ndef handle_db_query(data, addr, client_socket):\n    try:\n        query = data.decode()\n\n        # Connect to database\n        conn = psycopg2.connect(\n            host=\"localhost\",\n            database=\"myapp\",\n            user=\"dbuser\",\n            password=\"dbpass\"\n        )\n\n        cursor = conn.cursor()\n        cursor.execute(query)\n        result = cursor.fetchall()\n\n        response = {\"status\": \"success\", \"data\": result}\n        client_socket.sendall(json.dumps(response).encode())\n\n        cursor.close()\n        conn.close()\n\n    except Exception as e:\n        error_response = {\"status\": \"error\", \"message\": str(e)}\n        client_socket.sendall(json.dumps(error_response).encode())\n\nstart_ssl_tcp_server(\n    8443,\n    handle_db_query,\n    certfile=\"db_proxy.crt\",\n    keyfile=\"db_proxy.key\",\n    cafile=\"ca.crt\",\n    require_client_cert=True\n)\n</code></pre>"},{"location":"protocols/secure-tcp/#cli-usage","title":"CLI Usage","text":"<pre><code># Start a secure server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key\n\n# Start with client certificate verification\nkn-sock run-ssl-tcp-server 8443 server.crt server.key --cafile ca.crt --require-client-cert\n\n# Send a secure message\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\"\n\n# Send with client certificate\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\" --cafile ca.crt --certfile client.crt --keyfile client.key\n</code></pre>"},{"location":"protocols/secure-tcp/#security-checklist","title":"Security Checklist","text":"<ul> <li> Use strong private keys (2048+ bits)</li> <li> Validate server certificates in production</li> <li> Use CA-signed certificates for production</li> <li> Implement certificate revocation checking</li> <li> Use strong cipher suites</li> <li> Set minimum TLS version to 1.2 or higher</li> <li> Regularly rotate certificates</li> <li> Monitor for certificate expiration</li> <li> Implement proper error handling</li> <li> Use mutual TLS for sensitive applications</li> </ul>"},{"location":"protocols/secure-tcp/#troubleshooting","title":"Troubleshooting","text":""},{"location":"protocols/secure-tcp/#common-ssl-issues","title":"Common SSL Issues","text":"<ol> <li>Certificate verification failed</li> <li>Ensure CA certificate is correct</li> <li>Check certificate expiration dates</li> <li> <p>Verify certificate chain</p> </li> <li> <p>Private key mismatch</p> </li> <li>Ensure private key matches certificate</li> <li> <p>Check file permissions</p> </li> <li> <p>Cipher suite mismatch</p> </li> <li>Update to supported cipher suites</li> <li> <p>Check TLS version compatibility</p> </li> <li> <p>Hostname verification failed</p> </li> <li>Use correct hostname in certificate</li> <li>Or disable hostname verification for testing</li> </ol>"},{"location":"protocols/secure-tcp/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For basic TCP communication</li> <li>Connection Pooling - For efficient secure connections</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/tcp/","title":"TCP Protocol","text":"<p>TCP (Transmission Control Protocol) provides reliable, ordered, and error-checked delivery of data between applications. kn-sock makes TCP communication simple and efficient.</p>"},{"location":"protocols/tcp/#overview","title":"Overview","text":"<p>TCP is connection-oriented, meaning: - A connection must be established before data can be sent - Data is delivered in the same order it was sent - Lost packets are automatically retransmitted - Connections are explicitly closed</p>"},{"location":"protocols/tcp/#synchronous-tcp","title":"Synchronous TCP","text":""},{"location":"protocols/tcp/#basic-tcp-server","title":"Basic TCP Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming TCP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"protocols/tcp/#basic-tcp-client","title":"Basic TCP Client","text":"<pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"protocols/tcp/#threaded-tcp-server","title":"Threaded TCP Server","text":"<p>For handling multiple clients concurrently:</p> <pre><code>from kn_sock import start_threaded_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_threaded_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"protocols/tcp/#sending-raw-bytes","title":"Sending Raw Bytes","text":"<pre><code>from kn_sock import send_tcp_bytes\n\n# Send raw bytes instead of strings\ndata = b'\\x01\\x02\\x03\\x04'\nsend_tcp_bytes(\"localhost\", 8080, data)\n</code></pre>"},{"location":"protocols/tcp/#asynchronous-tcp","title":"Asynchronous TCP","text":""},{"location":"protocols/tcp/#async-tcp-server","title":"Async TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_tcp_server\n\nasync def handle_tcp_message(data, addr, writer):\n    \"\"\"\n    Handle incoming TCP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    writer.write(b\"Message received\")\n    await writer.drain()\n\nasyncio.run(start_async_tcp_server(8080, handle_tcp_message))\n</code></pre>"},{"location":"protocols/tcp/#async-tcp-client","title":"Async TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"protocols/tcp/#secure-tcp-ssltls","title":"Secure TCP (SSL/TLS)","text":"<p>kn-sock supports secure TCP communication using SSL/TLS for encrypted connections.</p>"},{"location":"protocols/tcp/#synchronous-secure-tcp-server","title":"Synchronous Secure TCP Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # Optional, for client cert verification\n    require_client_cert=True  # For mutual TLS\n)\n</code></pre>"},{"location":"protocols/tcp/#synchronous-secure-tcp-client","title":"Synchronous Secure TCP Client","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\",\n    cafile=\"ca.crt\",  # Optional, for server verification\n    certfile=\"client.crt\", keyfile=\"client.key\"  # For mutual TLS\n)\n</code></pre>"},{"location":"protocols/tcp/#asynchronous-secure-tcp-server","title":"Asynchronous Secure TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_ssl_tcp_server\n\nasync def handle_secure(data, addr, writer):\n    print(f\"Received from {addr}: {data.decode()}\")\n    writer.write(b\"Secure response\")\n    await writer.drain()\n\nasyncio.run(start_async_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n))\n</code></pre>"},{"location":"protocols/tcp/#asynchronous-secure-tcp-client","title":"Asynchronous Secure TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_ssl_tcp_message_async\n\nasyncio.run(send_ssl_tcp_message_async(\n    \"localhost\", 8443, \"Hello Secure\"\n))\n</code></pre>"},{"location":"protocols/tcp/#ssltls-configuration","title":"SSL/TLS Configuration","text":"Parameter Description Required <code>certfile</code> Path to server certificate (PEM) Yes <code>keyfile</code> Path to private key (PEM) Yes <code>cafile</code> CA certificate for verification No <code>require_client_cert</code> Require client certificate (mutual TLS) No <code>verify</code> Verify server certificate (client) Yes (default: True)"},{"location":"protocols/tcp/#generating-ssl-certificates","title":"Generating SSL Certificates","text":"<p>For testing, generate self-signed certificates:</p> <pre><code># Generate private key\nopenssl genrsa -out server.key 2048\n\n# Generate certificate\nopenssl req -new -x509 -key server.key -out server.crt -days 365\n\n# For client certificates (mutual TLS)\nopenssl genrsa -out client.key 2048\nopenssl req -new -key client.key -out client.csr\nopenssl x509 -req -in client.csr -CA server.crt -CAkey server.key -out client.crt\n</code></pre>"},{"location":"protocols/tcp/#tcp-connection-pooling","title":"TCP Connection Pooling","text":"<p>For high-performance applications that make frequent connections, use connection pooling:</p>"},{"location":"protocols/tcp/#basic-connection-pool","title":"Basic Connection Pool","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool('localhost', 8080, max_size=5, idle_timeout=30)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()  # Clean up all connections\n</code></pre>"},{"location":"protocols/tcp/#secure-connection-pool","title":"Secure Connection Pool","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool(\n    'localhost', 8443, max_size=5, idle_timeout=30,\n    ssl=True, cafile=\"ca.crt\", certfile=\"client.crt\", keyfile=\"client.key\", verify=True\n)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello Secure\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()\n</code></pre>"},{"location":"protocols/tcp/#pool-configuration","title":"Pool Configuration","text":"Parameter Description Default <code>max_size</code> Maximum number of pooled connections 10 <code>idle_timeout</code> Seconds before idle connections are closed 60 <code>ssl</code> Enable SSL/TLS False <code>cafile</code> CA certificate for verification None <code>certfile</code> Client certificate None <code>keyfile</code> Client private key None <code>verify</code> Verify server certificate True"},{"location":"protocols/tcp/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>All TCP server functions support graceful shutdown using shutdown events:</p> <pre><code>import threading\nfrom kn_sock import start_tcp_server\n\nshutdown_event = threading.Event()\n\ndef handler(data, addr, client_socket):\n    # Check if shutdown was requested\n    if shutdown_event.is_set():\n        return\n    # Process message...\n    pass\n\n# Start server\nserver_thread = threading.Thread(\n    target=start_tcp_server,\n    args=(8080, handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n\n# Later, to shutdown gracefully:\nshutdown_event.set()\n</code></pre>"},{"location":"protocols/tcp/#error-handling","title":"Error Handling","text":"<pre><code>from kn_sock.errors import EasySocketError, ConnectionTimeoutError, PortInUseError\n\ntry:\n    start_tcp_server(8080, handler)\nexcept PortInUseError:\n    print(\"Port 8080 is already in use\")\nexcept EasySocketError as e:\n    print(f\"Socket error: {e}\")\n\ntry:\n    send_tcp_message(\"localhost\", 8080, \"Hello\")\nexcept ConnectionTimeoutError:\n    print(\"Connection timed out\")\nexcept EasySocketError as e:\n    print(f\"Client error: {e}\")\n</code></pre>"},{"location":"protocols/tcp/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use connection pooling for frequent connections</li> <li>Use async servers for high-concurrency applications</li> <li>Implement proper error handling for production use</li> <li>Use SSL/TLS for sensitive data transmission</li> <li>Set appropriate timeouts for your use case</li> </ol>"},{"location":"protocols/tcp/#cli-usage","title":"CLI Usage","text":"<pre><code># Start a TCP server\nkn-sock run-tcp-server 8080\n\n# Send a TCP message\nkn-sock send-tcp localhost 8080 \"Hello, World!\"\n\n# Start a secure TCP server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key\n\n# Send a secure TCP message\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\"\n</code></pre>"},{"location":"protocols/tcp/#related-topics","title":"Related Topics","text":"<ul> <li>UDP Protocol - For connectionless communication</li> <li>JSON Communication - For structured data exchange</li> <li>File Transfer - For file transmission over TCP</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/udp/","title":"UDP Protocol","text":"<p>UDP (User Datagram Protocol) provides connectionless, unreliable communication between applications. kn-sock makes UDP messaging simple and efficient.</p>"},{"location":"protocols/udp/#overview","title":"Overview","text":"<p>UDP is connectionless, meaning: - No connection establishment required - No guarantee of delivery order - No automatic retransmission of lost packets - Lower overhead than TCP - Ideal for real-time applications</p>"},{"location":"protocols/udp/#synchronous-udp","title":"Synchronous UDP","text":""},{"location":"protocols/udp/#basic-udp-server","title":"Basic UDP Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    \"\"\"\n    Handle incoming UDP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        server_socket (socket.socket): The server socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"protocols/udp/#basic-udp-client","title":"Basic UDP Client","text":"<pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"protocols/udp/#udp-server-with-response","title":"UDP Server with Response","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    message = data.decode('utf-8')\n    print(f\"Received from {addr}: {message}\")\n\n    # Send a response back to the client\n    response = f\"Echo: {message}\"\n    server_socket.sendto(response.encode('utf-8'), addr)\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"protocols/udp/#asynchronous-udp","title":"Asynchronous UDP","text":""},{"location":"protocols/udp/#async-udp-server","title":"Async UDP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def handle_udp_message(data, addr, transport):\n    \"\"\"\n    Handle incoming UDP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        transport (asyncio.DatagramTransport): The transport object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nasyncio.run(start_udp_server_async(8080, handle_udp_message))\n</code></pre>"},{"location":"protocols/udp/#async-udp-client","title":"Async UDP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasyncio.run(send_udp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"protocols/udp/#udp-multicast","title":"UDP Multicast","text":"<p>UDP multicast allows sending messages to multiple recipients simultaneously.</p>"},{"location":"protocols/udp/#multicast-server","title":"Multicast Server","text":"<pre><code>from kn_sock import start_udp_multicast_server\n\ndef handle_multicast_message(data, addr, server_socket):\n    print(f\"Received multicast from {addr}: {data.decode('utf-8')}\")\n\n# Listen on multicast group 224.0.0.1\nstart_udp_multicast_server(\"224.0.0.1\", 8080, handle_multicast_message)\n</code></pre>"},{"location":"protocols/udp/#multicast-client","title":"Multicast Client","text":"<pre><code>from kn_sock import send_udp_multicast\n\n# Send to multicast group 224.0.0.1\nsend_udp_multicast(\"224.0.0.1\", 8080, \"Hello, multicast world!\")\n</code></pre>"},{"location":"protocols/udp/#multicast-configuration","title":"Multicast Configuration","text":"Parameter Description Default <code>group</code> Multicast group address Required <code>port</code> Port number Required <code>ttl</code> Time-to-live for multicast packets 1 <code>listen_ip</code> IP to listen on for multicast '0.0.0.0'"},{"location":"protocols/udp/#use-cases","title":"Use Cases","text":""},{"location":"protocols/udp/#real-time-data-broadcasting","title":"Real-time Data Broadcasting","text":"<pre><code>from kn_sock import start_udp_server\nimport time\n\ndef broadcast_sensor_data(data, addr, server_socket):\n    # Broadcast sensor data to all clients\n    timestamp = time.time()\n    message = f\"Sensor: {data}, Time: {timestamp}\"\n    print(f\"Broadcasting: {message}\")\n\nstart_udp_server(8080, broadcast_sensor_data)\n</code></pre>"},{"location":"protocols/udp/#gamingreal-time-applications","title":"Gaming/Real-time Applications","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_game_update(data, addr, server_socket):\n    # Handle real-time game updates\n    game_state = data.decode('utf-8')\n    print(f\"Game update from {addr}: {game_state}\")\n\n    # Broadcast to other players\n    # (Implementation depends on your game logic)\n\nstart_udp_server(8080, handle_game_update)\n</code></pre>"},{"location":"protocols/udp/#iot-device-communication","title":"IoT Device Communication","text":"<pre><code>from kn_sock import start_udp_server\nimport json\n\ndef handle_iot_message(data, addr, server_socket):\n    try:\n        message = json.loads(data.decode('utf-8'))\n        device_id = message.get('device_id')\n        sensor_value = message.get('value')\n\n        print(f\"Device {device_id}: {sensor_value}\")\n\n        # Send acknowledgment\n        ack = json.dumps({\"status\": \"received\", \"device_id\": device_id})\n        server_socket.sendto(ack.encode('utf-8'), addr)\n\n    except json.JSONDecodeError:\n        print(f\"Invalid JSON from {addr}\")\n\nstart_udp_server(8080, handle_iot_message)\n</code></pre>"},{"location":"protocols/udp/#error-handling","title":"Error Handling","text":"<pre><code>from kn_sock.errors import EasySocketError, ConnectionTimeoutError\n\ntry:\n    start_udp_server(8080, handler)\nexcept EasySocketError as e:\n    print(f\"UDP server error: {e}\")\n\ntry:\n    send_udp_message(\"localhost\", 8080, \"Hello\")\nexcept EasySocketError as e:\n    print(f\"UDP client error: {e}\")\n</code></pre>"},{"location":"protocols/udp/#performance-considerations","title":"Performance Considerations","text":""},{"location":"protocols/udp/#message-size","title":"Message Size","text":"<p>UDP has a maximum message size limit. For large data:</p> <pre><code>def send_large_data(host, port, data):\n    # Split large data into chunks\n    chunk_size = 1024\n    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]\n\n    for i, chunk in enumerate(chunks):\n        message = f\"CHUNK:{i}:{len(chunks)}:{chunk.hex()}\"\n        send_udp_message(host, port, message)\n</code></pre>"},{"location":"protocols/udp/#reliability","title":"Reliability","text":"<p>For applications requiring reliability, implement your own acknowledgment system:</p> <pre><code>def reliable_udp_send(host, port, message, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            send_udp_message(host, port, message)\n            # Wait for acknowledgment\n            # (Implementation depends on your protocol)\n            return True\n        except EasySocketError:\n            if attempt == max_retries - 1:\n                raise\n            time.sleep(0.1 * (attempt + 1))  # Exponential backoff\n</code></pre>"},{"location":"protocols/udp/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>import threading\nfrom kn_sock import start_udp_server\n\nshutdown_event = threading.Event()\n\ndef handler(data, addr, server_socket):\n    if shutdown_event.is_set():\n        return\n    # Process message...\n    pass\n\nserver_thread = threading.Thread(\n    target=start_udp_server,\n    args=(8080, handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n\n# Later, to shutdown gracefully:\nshutdown_event.set()\n</code></pre>"},{"location":"protocols/udp/#cli-usage","title":"CLI Usage","text":"<pre><code># Start a UDP server\nkn-sock run-udp-server 8080\n\n# Send a UDP message\nkn-sock send-udp localhost 8080 \"Hello, World!\"\n\n# Send multicast message\nkn-sock send-udp-multicast 224.0.0.1 8080 \"Hello, multicast!\"\n</code></pre>"},{"location":"protocols/udp/#best-practices","title":"Best Practices","text":"<ol> <li>Handle packet loss: UDP doesn't guarantee delivery</li> <li>Implement timeouts: Set appropriate timeouts for your use case</li> <li>Use appropriate message sizes: Keep messages under MTU size</li> <li>Consider reliability needs: Implement acknowledgments if needed</li> <li>Use multicast wisely: Only for one-to-many communication</li> <li>Handle network errors: Implement proper error handling</li> </ol>"},{"location":"protocols/udp/#when-to-use-udp","title":"When to Use UDP","text":""},{"location":"protocols/udp/#use-udp-for","title":"Use UDP for:","text":"<ul> <li>Real-time applications (gaming, streaming)</li> <li>Broadcasting/multicasting</li> <li>Simple request-response protocols</li> <li>Applications where speed is more important than reliability</li> <li>IoT device communication</li> </ul>"},{"location":"protocols/udp/#use-tcp-instead-for","title":"Use TCP instead for:","text":"<ul> <li>File transfers</li> <li>Database connections</li> <li>Applications requiring guaranteed delivery</li> <li>Complex protocols requiring ordered data</li> </ul>"},{"location":"protocols/udp/#related-topics","title":"Related Topics","text":"<ul> <li>TCP Protocol - For reliable, connection-oriented communication</li> <li>JSON Communication - For structured data over UDP</li> <li>API Reference - Complete function documentation </li> </ul>"},{"location":"protocols/websocket/","title":"WebSocket Protocol","text":"<p>WebSockets provide full-duplex communication over a single TCP connection. kn-sock offers comprehensive WebSocket support for real-time applications.</p>"},{"location":"protocols/websocket/#overview","title":"Overview","text":"<p>WebSocket features in kn-sock: - Full-duplex communication: Send and receive simultaneously - Real-time messaging: Low-latency bidirectional communication - Connection persistence: Long-lived connections with automatic reconnection - Custom protocols: Support for WebSocket subprotocols - Async and sync support: Both synchronous and asynchronous implementations - Built-in ping/pong: Automatic connection health monitoring</p>"},{"location":"protocols/websocket/#basic-websocket-usage","title":"Basic WebSocket Usage","text":""},{"location":"protocols/websocket/#websocket-server","title":"WebSocket Server","text":"<pre><code>from kn_sock import start_websocket_server\nimport threading\n\ndef handle_websocket_client(client_socket, address):\n    \"\"\"\n    Handle WebSocket client connections.\n\n    Args:\n        client_socket: The WebSocket client connection\n        address: Client address tuple (host, port)\n    \"\"\"\n    print(f\"WebSocket client connected from {address}\")\n\n    try:\n        while True:\n            # Receive message from client\n            message = client_socket.recv()\n            if message:\n                print(f\"Received: {message}\")\n\n                # Echo the message back\n                client_socket.send(f\"Echo: {message}\")\n            else:\n                # Client disconnected\n                break\n\n    except Exception as e:\n        print(f\"Error handling client {address}: {e}\")\n    finally:\n        print(f\"Client {address} disconnected\")\n        client_socket.close()\n\n# Start WebSocket server\nshutdown_event = threading.Event()\nstart_websocket_server(\"localhost\", 8765, handle_websocket_client, shutdown_event)\n</code></pre>"},{"location":"protocols/websocket/#websocket-client","title":"WebSocket Client","text":"<pre><code>from kn_sock import connect_websocket\nimport time\n\ndef websocket_client_example():\n    \"\"\"Example WebSocket client.\"\"\"\n\n    # Connect to WebSocket server\n    ws = connect_websocket(\"localhost\", 8765)\n\n    try:\n        # Send messages\n        ws.send(\"Hello WebSocket!\")\n        ws.send(\"How are you?\")\n\n        # Receive responses\n        for _ in range(2):\n            response = ws.recv()\n            print(f\"Server response: {response}\")\n\n        # Send JSON data\n        import json\n        data = {\"type\": \"message\", \"content\": \"JSON message\", \"timestamp\": time.time()}\n        ws.send(json.dumps(data))\n\n        response = ws.recv()\n        print(f\"JSON response: {response}\")\n\n    finally:\n        ws.close()\n\n# Run the client\nwebsocket_client_example()\n</code></pre>"},{"location":"protocols/websocket/#asynchronous-websocket","title":"Asynchronous WebSocket","text":""},{"location":"protocols/websocket/#async-websocket-server","title":"Async WebSocket Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_websocket_server\n\nasync def handle_async_websocket(websocket, path):\n    \"\"\"\n    Handle async WebSocket connections.\n\n    Args:\n        websocket: The WebSocket connection\n        path: The requested path\n    \"\"\"\n    print(f\"Async WebSocket client connected: {path}\")\n\n    try:\n        async for message in websocket:\n            print(f\"Received: {message}\")\n\n            # Process the message\n            if message.startswith(\"ping\"):\n                await websocket.send(\"pong\")\n            elif message.startswith(\"echo\"):\n                await websocket.send(f\"Echo: {message[5:]}\")\n            else:\n                await websocket.send(f\"Processed: {message}\")\n\n    except Exception as e:\n        print(f\"Error in async handler: {e}\")\n\n# Start async WebSocket server\nasync def main():\n    server = await start_async_websocket_server(\n        \"localhost\", 8765, handle_async_websocket\n    )\n    print(\"Async WebSocket server started on ws://localhost:8765\")\n    await server.wait_closed()\n\n# Run the server\nasyncio.run(main())\n</code></pre>"},{"location":"protocols/websocket/#async-websocket-client","title":"Async WebSocket Client","text":"<pre><code>import asyncio\nfrom kn_sock import async_connect_websocket\n\nasync def async_websocket_client():\n    \"\"\"Example async WebSocket client.\"\"\"\n\n    # Connect to async WebSocket server\n    async with async_connect_websocket(\"localhost\", 8765) as websocket:\n\n        # Send multiple messages\n        messages = [\"ping\", \"echo Hello\", \"async message\"]\n\n        for message in messages:\n            await websocket.send(message)\n            response = await websocket.recv()\n            print(f\"Response: {response}\")\n\n            # Small delay between messages\n            await asyncio.sleep(0.5)\n\n# Run the async client\nasyncio.run(async_websocket_client())\n</code></pre>"},{"location":"protocols/websocket/#advanced-websocket-features","title":"Advanced WebSocket Features","text":""},{"location":"protocols/websocket/#websocket-with-custom-protocol","title":"WebSocket with Custom Protocol","text":"<pre><code>from kn_sock import start_websocket_server\n\nclass ChatProtocol:\n    \"\"\"Custom chat protocol for WebSocket.\"\"\"\n\n    def __init__(self):\n        self.clients = {}\n        self.rooms = {}\n\n    def handle_client(self, client_socket, address):\n        \"\"\"Handle client with custom protocol.\"\"\"\n        client_id = f\"{address[0]}:{address[1]}\"\n        self.clients[client_id] = client_socket\n\n        try:\n            # Send welcome message\n            welcome = {\n                \"type\": \"welcome\",\n                \"client_id\": client_id,\n                \"message\": \"Connected to chat server\"\n            }\n            client_socket.send(json.dumps(welcome))\n\n            while True:\n                message = client_socket.recv()\n                if not message:\n                    break\n\n                try:\n                    data = json.loads(message)\n                    self.process_message(client_id, data)\n                except json.JSONDecodeError:\n                    self.send_error(client_socket, \"Invalid JSON format\")\n\n        except Exception as e:\n            print(f\"Error with client {client_id}: {e}\")\n        finally:\n            self.cleanup_client(client_id)\n\n    def process_message(self, client_id, data):\n        \"\"\"Process incoming message based on type.\"\"\"\n        message_type = data.get(\"type\")\n\n        if message_type == \"join_room\":\n            self.join_room(client_id, data.get(\"room\"))\n        elif message_type == \"leave_room\":\n            self.leave_room(client_id, data.get(\"room\"))\n        elif message_type == \"chat_message\":\n            self.broadcast_message(client_id, data)\n        elif message_type == \"private_message\":\n            self.send_private_message(client_id, data)\n        else:\n            self.send_error(self.clients[client_id], f\"Unknown message type: {message_type}\")\n\n    def join_room(self, client_id, room_name):\n        \"\"\"Add client to a chat room.\"\"\"\n        if room_name not in self.rooms:\n            self.rooms[room_name] = set()\n\n        self.rooms[room_name].add(client_id)\n\n        # Notify client\n        response = {\n            \"type\": \"room_joined\",\n            \"room\": room_name,\n            \"members\": len(self.rooms[room_name])\n        }\n        self.clients[client_id].send(json.dumps(response))\n\n        # Notify other room members\n        notification = {\n            \"type\": \"user_joined\",\n            \"user\": client_id,\n            \"room\": room_name\n        }\n        self.broadcast_to_room(room_name, notification, exclude=client_id)\n\n    def broadcast_message(self, sender_id, data):\n        \"\"\"Broadcast message to room members.\"\"\"\n        room_name = data.get(\"room\")\n        message = data.get(\"message\")\n\n        if room_name not in self.rooms or sender_id not in self.rooms[room_name]:\n            self.send_error(self.clients[sender_id], \"Not in specified room\")\n            return\n\n        broadcast_data = {\n            \"type\": \"chat_message\",\n            \"sender\": sender_id,\n            \"room\": room_name,\n            \"message\": message,\n            \"timestamp\": time.time()\n        }\n\n        self.broadcast_to_room(room_name, broadcast_data)\n\n    def broadcast_to_room(self, room_name, data, exclude=None):\n        \"\"\"Broadcast data to all clients in a room.\"\"\"\n        if room_name not in self.rooms:\n            return\n\n        message = json.dumps(data)\n        for client_id in self.rooms[room_name]:\n            if client_id != exclude and client_id in self.clients:\n                try:\n                    self.clients[client_id].send(message)\n                except Exception as e:\n                    print(f\"Error sending to {client_id}: {e}\")\n                    self.cleanup_client(client_id)\n\n    def send_error(self, client_socket, error_message):\n        \"\"\"Send error message to client.\"\"\"\n        error_data = {\n            \"type\": \"error\",\n            \"message\": error_message\n        }\n        client_socket.send(json.dumps(error_data))\n\n    def cleanup_client(self, client_id):\n        \"\"\"Clean up client from all data structures.\"\"\"\n        # Remove from all rooms\n        for room_name, members in self.rooms.items():\n            if client_id in members:\n                members.remove(client_id)\n\n                # Notify remaining room members\n                notification = {\n                    \"type\": \"user_left\",\n                    \"user\": client_id,\n                    \"room\": room_name\n                }\n                self.broadcast_to_room(room_name, notification)\n\n        # Remove from clients\n        if client_id in self.clients:\n            del self.clients[client_id]\n\n# Use the custom protocol\nprotocol = ChatProtocol()\nstart_websocket_server(\"localhost\", 8765, protocol.handle_client)\n</code></pre>"},{"location":"protocols/websocket/#websocket-with-heartbeat","title":"WebSocket with Heartbeat","text":"<pre><code>import threading\nimport time\nfrom kn_sock import start_websocket_server\n\nclass HeartbeatWebSocketServer:\n    \"\"\"WebSocket server with heartbeat monitoring.\"\"\"\n\n    def __init__(self):\n        self.clients = {}\n        self.heartbeat_interval = 30  # seconds\n        self.heartbeat_timeout = 60   # seconds\n        self.running = True\n\n        # Start heartbeat monitor thread\n        threading.Thread(target=self.heartbeat_monitor, daemon=True).start()\n\n    def handle_client(self, client_socket, address):\n        \"\"\"Handle client with heartbeat monitoring.\"\"\"\n        client_id = f\"{address[0]}:{address[1]}\"\n\n        # Register client\n        self.clients[client_id] = {\n            \"socket\": client_socket,\n            \"last_ping\": time.time(),\n            \"connected\": True\n        }\n\n        print(f\"Client {client_id} connected\")\n\n        try:\n            while self.clients[client_id][\"connected\"]:\n                message = client_socket.recv(timeout=1.0)  # Non-blocking receive\n\n                if message:\n                    if message == \"pong\":\n                        # Update last ping time\n                        self.clients[client_id][\"last_ping\"] = time.time()\n                        print(f\"Received pong from {client_id}\")\n                    else:\n                        # Process regular message\n                        print(f\"Message from {client_id}: {message}\")\n                        client_socket.send(f\"Echo: {message}\")\n\n        except Exception as e:\n            print(f\"Error with client {client_id}: {e}\")\n        finally:\n            self.cleanup_client(client_id)\n\n    def heartbeat_monitor(self):\n        \"\"\"Monitor client heartbeats and send pings.\"\"\"\n        while self.running:\n            current_time = time.time()\n\n            # Check all clients\n            dead_clients = []\n            for client_id, client_info in self.clients.items():\n                last_ping = client_info[\"last_ping\"]\n\n                # Check if client is unresponsive\n                if current_time - last_ping &gt; self.heartbeat_timeout:\n                    print(f\"Client {client_id} timed out\")\n                    dead_clients.append(client_id)\n\n                # Send ping if needed\n                elif current_time - last_ping &gt; self.heartbeat_interval:\n                    try:\n                        client_info[\"socket\"].send(\"ping\")\n                        print(f\"Sent ping to {client_id}\")\n                    except Exception as e:\n                        print(f\"Failed to ping {client_id}: {e}\")\n                        dead_clients.append(client_id)\n\n            # Clean up dead clients\n            for client_id in dead_clients:\n                self.cleanup_client(client_id)\n\n            time.sleep(5)  # Check every 5 seconds\n\n    def cleanup_client(self, client_id):\n        \"\"\"Clean up disconnected client.\"\"\"\n        if client_id in self.clients:\n            self.clients[client_id][\"connected\"] = False\n            try:\n                self.clients[client_id][\"socket\"].close()\n            except:\n                pass\n            del self.clients[client_id]\n            print(f\"Client {client_id} cleaned up\")\n\n# Start heartbeat server\nserver = HeartbeatWebSocketServer()\nstart_websocket_server(\"localhost\", 8765, server.handle_client)\n</code></pre>"},{"location":"protocols/websocket/#websocket-client-patterns","title":"WebSocket Client Patterns","text":""},{"location":"protocols/websocket/#reconnecting-websocket-client","title":"Reconnecting WebSocket Client","text":"<pre><code>import time\nimport threading\nfrom kn_sock import connect_websocket\n\nclass ReconnectingWebSocketClient:\n    \"\"\"WebSocket client with automatic reconnection.\"\"\"\n\n    def __init__(self, host, port, reconnect_interval=5):\n        self.host = host\n        self.port = port\n        self.reconnect_interval = reconnect_interval\n        self.websocket = None\n        self.connected = False\n        self.running = True\n        self.message_queue = []\n\n    def connect(self):\n        \"\"\"Connect to WebSocket server.\"\"\"\n        try:\n            self.websocket = connect_websocket(self.host, self.port)\n            self.connected = True\n            print(f\"Connected to WebSocket server at {self.host}:{self.port}\")\n\n            # Send queued messages\n            self.send_queued_messages()\n\n            return True\n        except Exception as e:\n            print(f\"Failed to connect: {e}\")\n            return False\n\n    def disconnect(self):\n        \"\"\"Disconnect from WebSocket server.\"\"\"\n        self.running = False\n        self.connected = False\n\n        if self.websocket:\n            try:\n                self.websocket.close()\n            except:\n                pass\n            self.websocket = None\n\n    def send_message(self, message):\n        \"\"\"Send message to server (queue if not connected).\"\"\"\n        if self.connected and self.websocket:\n            try:\n                self.websocket.send(message)\n                return True\n            except Exception as e:\n                print(f\"Failed to send message: {e}\")\n                self.connected = False\n                self.message_queue.append(message)\n                return False\n        else:\n            # Queue message for later\n            self.message_queue.append(message)\n            return False\n\n    def send_queued_messages(self):\n        \"\"\"Send all queued messages.\"\"\"\n        while self.message_queue and self.connected:\n            message = self.message_queue.pop(0)\n            if not self.send_message(message):\n                # Re-queue if sending fails\n                self.message_queue.insert(0, message)\n                break\n\n    def receive_messages(self):\n        \"\"\"Receive messages in a loop.\"\"\"\n        while self.running:\n            if self.connected and self.websocket:\n                try:\n                    message = self.websocket.recv(timeout=1.0)\n                    if message:\n                        self.handle_message(message)\n                except Exception as e:\n                    print(f\"Error receiving message: {e}\")\n                    self.connected = False\n            else:\n                time.sleep(0.1)\n\n    def handle_message(self, message):\n        \"\"\"Handle received message (override in subclass).\"\"\"\n        print(f\"Received: {message}\")\n\n    def run(self):\n        \"\"\"Main client loop with automatic reconnection.\"\"\"\n        # Start receive thread\n        receive_thread = threading.Thread(target=self.receive_messages, daemon=True)\n        receive_thread.start()\n\n        while self.running:\n            if not self.connected:\n                print(\"Attempting to connect...\")\n                if self.connect():\n                    continue\n                else:\n                    print(f\"Reconnecting in {self.reconnect_interval} seconds...\")\n                    time.sleep(self.reconnect_interval)\n            else:\n                time.sleep(1)\n\n# Usage example\nclient = ReconnectingWebSocketClient(\"localhost\", 8765)\n\n# Start client in background\nclient_thread = threading.Thread(target=client.run, daemon=True)\nclient_thread.start()\n\n# Send messages\nfor i in range(10):\n    client.send_message(f\"Message {i}\")\n    time.sleep(2)\n\n# Cleanup\nclient.disconnect()\n</code></pre>"},{"location":"protocols/websocket/#websocket-security","title":"WebSocket Security","text":""},{"location":"protocols/websocket/#secure-websocket-wss","title":"Secure WebSocket (WSS)","text":"<pre><code>import ssl\nfrom kn_sock import start_websocket_server\n\ndef secure_websocket_server():\n    \"\"\"Start a secure WebSocket server with SSL/TLS.\"\"\"\n\n    def handle_secure_client(client_socket, address):\n        print(f\"Secure WebSocket client connected from {address}\")\n\n        try:\n            while True:\n                message = client_socket.recv()\n                if not message:\n                    break\n\n                print(f\"Secure message: {message}\")\n                client_socket.send(f\"Secure echo: {message}\")\n\n        except Exception as e:\n            print(f\"Error in secure handler: {e}\")\n        finally:\n            client_socket.close()\n\n    # SSL configuration\n    ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ssl_context.load_cert_chain(\"server.crt\", \"server.key\")\n\n    # Start secure server\n    start_websocket_server(\n        \"localhost\", 8765, \n        handle_secure_client,\n        ssl_context=ssl_context\n    )\n\n# Connect to secure WebSocket\nfrom kn_sock import connect_websocket\n\ndef secure_websocket_client():\n    \"\"\"Connect to secure WebSocket server.\"\"\"\n\n    # SSL configuration for client\n    ssl_context = ssl.create_default_context()\n    ssl_context.check_hostname = False  # For self-signed certificates\n    ssl_context.verify_mode = ssl.CERT_NONE\n\n    ws = connect_websocket(\n        \"localhost\", 8765,\n        ssl_context=ssl_context\n    )\n\n    ws.send(\"Secure message\")\n    response = ws.recv()\n    print(f\"Secure response: {response}\")\n\n    ws.close()\n</code></pre>"},{"location":"protocols/websocket/#performance-optimization","title":"Performance Optimization","text":""},{"location":"protocols/websocket/#connection-pooling","title":"Connection Pooling","text":"<pre><code>import queue\nimport threading\nfrom kn_sock import connect_websocket\n\nclass WebSocketPool:\n    \"\"\"WebSocket connection pool for high-performance clients.\"\"\"\n\n    def __init__(self, host, port, pool_size=10):\n        self.host = host\n        self.port = port\n        self.pool_size = pool_size\n        self.pool = queue.Queue()\n        self.lock = threading.Lock()\n\n        # Create initial connections\n        self.create_pool()\n\n    def create_pool(self):\n        \"\"\"Create initial pool of connections.\"\"\"\n        for _ in range(self.pool_size):\n            try:\n                ws = connect_websocket(self.host, self.port)\n                self.pool.put(ws)\n            except Exception as e:\n                print(f\"Failed to create pooled connection: {e}\")\n\n    def get_connection(self, timeout=10):\n        \"\"\"Get a connection from the pool.\"\"\"\n        try:\n            return self.pool.get(timeout=timeout)\n        except queue.Empty:\n            # Create new connection if pool is empty\n            return connect_websocket(self.host, self.port)\n\n    def return_connection(self, ws):\n        \"\"\"Return a connection to the pool.\"\"\"\n        if self.pool.qsize() &lt; self.pool_size:\n            self.pool.put(ws)\n        else:\n            # Pool is full, close the connection\n            ws.close()\n\n    def send_message(self, message):\n        \"\"\"Send message using pooled connection.\"\"\"\n        ws = self.get_connection()\n        try:\n            ws.send(message)\n            response = ws.recv()\n            return response\n        finally:\n            self.return_connection(ws)\n\n    def close_all(self):\n        \"\"\"Close all pooled connections.\"\"\"\n        while not self.pool.empty():\n            try:\n                ws = self.pool.get_nowait()\n                ws.close()\n            except queue.Empty:\n                break\n\n# Usage\npool = WebSocketPool(\"localhost\", 8765, pool_size=5)\n\n# Send multiple messages efficiently\nfor i in range(100):\n    response = pool.send_message(f\"Pooled message {i}\")\n    print(f\"Response {i}: {response}\")\n\npool.close_all()\n</code></pre>"},{"location":"protocols/websocket/#troubleshooting","title":"Troubleshooting","text":""},{"location":"protocols/websocket/#common-websocket-issues","title":"Common WebSocket Issues","text":""},{"location":"protocols/websocket/#connection-refused","title":"Connection Refused","text":"<pre><code>try:\n    ws = connect_websocket(\"localhost\", 8765)\nexcept ConnectionRefusedError:\n    print(\"WebSocket server is not running or port is incorrect\")\n</code></pre>"},{"location":"protocols/websocket/#handshake-failure","title":"Handshake Failure","text":"<pre><code>try:\n    ws = connect_websocket(\"localhost\", 8765, resource=\"/ws\")\nexcept Exception as e:\n    if \"handshake\" in str(e).lower():\n        print(\"WebSocket handshake failed - check server configuration\")\n</code></pre>"},{"location":"protocols/websocket/#message-size-limits","title":"Message Size Limits","text":"<pre><code># Configure maximum message size\nws = connect_websocket(\"localhost\", 8765, max_size=1024*1024)  # 1MB\n</code></pre>"},{"location":"protocols/websocket/#debugging-websocket-connections","title":"Debugging WebSocket Connections","text":"<pre><code>import logging\n\n# Enable WebSocket debugging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger('websocket')\n\ndef debug_websocket_handler(client_socket, address):\n    \"\"\"Debug WebSocket handler with detailed logging.\"\"\"\n    logger.info(f\"Client connected: {address}\")\n\n    try:\n        while True:\n            message = client_socket.recv()\n            if not message:\n                logger.info(f\"Client {address} disconnected\")\n                break\n\n            logger.debug(f\"Received from {address}: {message}\")\n            response = f\"Debug echo: {message}\"\n            client_socket.send(response)\n            logger.debug(f\"Sent to {address}: {response}\")\n\n    except Exception as e:\n        logger.error(f\"Error with client {address}: {e}\")\n    finally:\n        client_socket.close()\n        logger.info(f\"Closed connection to {address}\")\n</code></pre>"},{"location":"protocols/websocket/#see-also","title":"See Also","text":"<ul> <li>TCP Protocol - For reliable connection-based communication</li> <li>JSON Communication - For structured data over WebSockets</li> <li>Real-time Examples - WebSocket application examples</li> <li>Advanced Features - Live streaming and video chat</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"}]}